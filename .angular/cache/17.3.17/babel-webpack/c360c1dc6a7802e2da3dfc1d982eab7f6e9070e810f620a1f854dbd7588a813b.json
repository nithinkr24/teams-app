{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"../util/helpers.js\";\nimport { AbortError } from \"../abort-controller/AbortError.js\";\nimport { createClientLogger } from \"../logger/logger.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nconst retryPolicyLogger = createClientLogger(\"ts-http-runtime retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        let response;\n        let responseError;\n        let retryCount = -1;\n        retryRequest: while (true) {\n          retryCount += 1;\n          response = undefined;\n          responseError = undefined;\n          try {\n            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n            response = yield next(request);\n            logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n          } catch (e) {\n            logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n            // RestErrors are valid targets for the retry strategies.\n            // If none of the retry strategies can work with them, they will be thrown later in this policy.\n            // If the received error is not a RestError, it is immediately thrown.\n            responseError = e;\n            if (!e || responseError.name !== \"RestError\") {\n              throw e;\n            }\n            response = responseError.response;\n          }\n          if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            logger.error(`Retry ${retryCount}: Request aborted.`);\n            const abortError = new AbortError();\n            throw abortError;\n          }\n          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n            logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n            if (responseError) {\n              throw responseError;\n            } else if (response) {\n              return response;\n            } else {\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            }\n          }\n          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n          strategiesLoop: for (const strategy of strategies) {\n            const strategyLogger = strategy.logger || logger;\n            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n            const modifiers = strategy.retry({\n              retryCount,\n              response,\n              responseError\n            });\n            if (modifiers.skipStrategy) {\n              strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n              continue strategiesLoop;\n            }\n            const {\n              errorToThrow,\n              retryAfterInMs,\n              redirectTo\n            } = modifiers;\n            if (errorToThrow) {\n              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n              throw errorToThrow;\n            }\n            if (retryAfterInMs || retryAfterInMs === 0) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n              yield delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n              continue retryRequest;\n            }\n            if (redirectTo) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n              request.url = redirectTo;\n              continue retryRequest;\n            }\n          }\n          if (responseError) {\n            logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n            throw responseError;\n          }\n          if (response) {\n            logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n            return response;\n          }\n          // If all the retries skip and there's no response,\n          // we're still in the retry loop, so a new request will be sent\n          // until `maxRetries` is reached.\n        }\n      })();\n    }\n  };\n}","map":{"version":3,"names":["delay","AbortError","createClientLogger","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","maxRetries","logger","name","sendRequest","request","next","_asyncToGenerator","_a","_b","response","responseError","retryCount","retryRequest","undefined","info","requestId","e","error","abortSignal","aborted","abortError","Error","length","strategiesLoop","strategy","strategyLogger","modifiers","retry","skipStrategy","errorToThrow","retryAfterInMs","redirectTo","url"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/policies/retryPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"../util/helpers.js\";\nimport { AbortError } from \"../abort-controller/AbortError.js\";\nimport { createClientLogger } from \"../logger/logger.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nconst retryPolicyLogger = createClientLogger(\"ts-http-runtime retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    const logger = options.logger || retryPolicyLogger;\n    return {\n        name: retryPolicyName,\n        async sendRequest(request, next) {\n            var _a, _b;\n            let response;\n            let responseError;\n            let retryCount = -1;\n            retryRequest: while (true) {\n                retryCount += 1;\n                response = undefined;\n                responseError = undefined;\n                try {\n                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n                    response = await next(request);\n                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n                }\n                catch (e) {\n                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n                    // RestErrors are valid targets for the retry strategies.\n                    // If none of the retry strategies can work with them, they will be thrown later in this policy.\n                    // If the received error is not a RestError, it is immediately thrown.\n                    responseError = e;\n                    if (!e || responseError.name !== \"RestError\") {\n                        throw e;\n                    }\n                    response = responseError.response;\n                }\n                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                    logger.error(`Retry ${retryCount}: Request aborted.`);\n                    const abortError = new AbortError();\n                    throw abortError;\n                }\n                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n                    if (responseError) {\n                        throw responseError;\n                    }\n                    else if (response) {\n                        return response;\n                    }\n                    else {\n                        throw new Error(\"Maximum retries reached with no response or error to throw\");\n                    }\n                }\n                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n                strategiesLoop: for (const strategy of strategies) {\n                    const strategyLogger = strategy.logger || logger;\n                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n                    const modifiers = strategy.retry({\n                        retryCount,\n                        response,\n                        responseError,\n                    });\n                    if (modifiers.skipStrategy) {\n                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n                        continue strategiesLoop;\n                    }\n                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n                    if (errorToThrow) {\n                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n                        throw errorToThrow;\n                    }\n                    if (retryAfterInMs || retryAfterInMs === 0) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n                        await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n                        continue retryRequest;\n                    }\n                    if (redirectTo) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n                        request.url = redirectTo;\n                        continue retryRequest;\n                    }\n                }\n                if (responseError) {\n                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n                    throw responseError;\n                }\n                if (response) {\n                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n                    return response;\n                }\n                // If all the retries skip and there's no response,\n                // we're still in the retry loop, so a new request will be sent\n                // until `maxRetries` is reached.\n            }\n        },\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}