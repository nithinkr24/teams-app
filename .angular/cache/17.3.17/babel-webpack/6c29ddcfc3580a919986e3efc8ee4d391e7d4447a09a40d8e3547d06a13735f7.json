{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __rest } from \"tslib\";\nimport { logger } from \"./models/logger.js\";\nimport { serializeCommunicationIdentifier } from \"@azure/communication-common\";\nimport { mapToAddChatParticipantsRequestRestModel, mapToChatMessageSdkModel, mapToChatParticipantSdkModel, mapToChatThreadPropertiesSdkModel, mapToReadReceiptSdkModel } from \"./models/mappers.js\";\nimport { ChatApiClient } from \"./generated/src/index.js\";\nimport { createCommunicationTokenCredentialPolicy } from \"./credential/communicationTokenCredentialPolicy.js\";\nimport { tracingClient } from \"./generated/src/tracing.js\";\nconst minimumTypingIntervalInMilliSeconds = 8000;\n/**\n * The client to do chat operations\n */\nexport class ChatThreadClient {\n  constructor(endpoint, threadId, credential, options = {}) {\n    this.endpoint = endpoint;\n    this.timeOfLastTypingRequest = undefined;\n    this.threadId = threadId;\n    this.tokenCredential = credential;\n    const internalPipelineOptions = Object.assign(Object.assign({}, options), {\n      loggingOptions: {\n        logger: logger.info\n      }\n    });\n    this.client = new ChatApiClient(this.endpoint, Object.assign({\n      endpoint: this.endpoint\n    }, internalPipelineOptions));\n    const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);\n    this.client.pipeline.addPolicy(authPolicy);\n  }\n  /**\n   * Gets a chat thread.\n   * Returns the chat thread.\n   * @param options -  Operation options.\n   */\n  getProperties(options = {}) {\n    var _this = this;\n    return tracingClient.withSpan(\"ChatClient-GetProperties\", options, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (updatedOptions) {\n        const result = yield _this.client.chatThread.getChatThreadProperties(_this.threadId, updatedOptions);\n        return mapToChatThreadPropertiesSdkModel(result);\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Updates a thread's topic.\n   * @param topic - The topic needs to be updated to.\n   * @param options - Operation options.\n   */\n  updateTopic(topic, options = {}) {\n    var _this2 = this;\n    return tracingClient.withSpan(\"ChatThreadClient-UpdateTopic\", options, /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (updatedOptions) {\n        yield _this2.client.chatThread.updateChatThreadProperties(_this2.threadId, {\n          topic: topic\n        }, updatedOptions);\n      });\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Updates a thread's properties.\n   * @param options - Operation options.\n   */\n  // beta release already named this option as UpdateChatThreadPropertiesOptions\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  updateProperties(options = {}) {\n    var _this3 = this;\n    return tracingClient.withSpan(\"ChatThreadClient-UpdateProperties\", options, /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (updatedOptions) {\n        yield _this3.client.chatThread.updateChatThreadProperties(_this3.threadId, options, updatedOptions);\n      });\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Sends a chat message to a thread identified by threadId.\n   * Returns the id of the created message.\n   * @param request - Request for sending a message.\n   * @param options - Operation options.\n   */\n  sendMessage(request, options = {}) {\n    var _this4 = this;\n    return tracingClient.withSpan(\"ChatThreadClient-SendMessage\", options, /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (updatedOptions) {\n        // reset typing notification clock\n        _this4.timeOfLastTypingRequest = undefined;\n        const result = yield _this4.client.chatThread.sendChatMessage(_this4.threadId, Object.assign(Object.assign({}, request), options), updatedOptions);\n        return result;\n      });\n      return function (_x4) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Gets a chat message identified by messageId.\n   * Returns the specific message.\n   * @param messageId - The message id of the message.\n   * @param options - Operation options.\n   */\n  getMessage(messageId, options = {}) {\n    var _this5 = this;\n    return tracingClient.withSpan(\"ChatThreadClient-GetMessage\", options, /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (updatedOptions) {\n        const result = yield _this5.client.chatThread.getChatMessage(_this5.threadId, messageId, updatedOptions);\n        return mapToChatMessageSdkModel(result);\n      });\n      return function (_x5) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n  }\n  listMessagesPage(pageSettings_1) {\n    return __asyncGenerator(this, arguments, function* listMessagesPage_1(pageSettings, options = {}) {\n      if (!pageSettings.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatMessages(this.threadId, options));\n        pageSettings.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));\n        }\n      }\n      while (pageSettings.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, options));\n        pageSettings.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  listMessagesAll(options) {\n    return __asyncGenerator(this, arguments, function* listMessagesAll_1() {\n      var _a, e_1, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listMessagesPage({}, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Gets a list of message from a thread identified by threadId.\n   * Returns the list of the messages.\n   * @param options - Get messages options.\n   */\n  listMessages(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(\"ChatThreadClient-ListMessages\", options);\n    try {\n      const iter = this.listMessagesAll(updatedOptions);\n      return {\n        next() {\n          return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        byPage: (settings = {}) => {\n          return this.listMessagesPage(settings, updatedOptions);\n        }\n      };\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes a message identified by threadId and messageId\n   * @param messageId - The message id of the message.\n   * @param options - Operation options.\n   */\n  deleteMessage(messageId, options = {}) {\n    var _this6 = this;\n    return tracingClient.withSpan(\"ChatThreadClient-DeleteMessage\", options, /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator(function* (updatedOptions) {\n        yield _this6.client.chatThread.deleteChatMessage(_this6.threadId, messageId, updatedOptions);\n      });\n      return function (_x6) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Updates a message identified by threadId and messageId\n   * @param messageId - The message id of the message.\n   * @param options - Operation options.\n   */\n  updateMessage(_x7) {\n    var _this7 = this;\n    return _asyncToGenerator(function* (messageId, options = {}) {\n      return tracingClient.withSpan(\"ChatThreadClient-UpdateMessage\", options, /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (updatedOptions) {\n          yield _this7.client.chatThread.updateChatMessage(_this7.threadId, messageId, options, updatedOptions);\n        });\n        return function (_x8) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  /**\n   * Adds the details of chat participants belonging to the thread identified by threadId.\n   * @param request - Thread participants' details to add in the thread roster\n   * @param options - Operation options.\n   */\n  addParticipants(_x9) {\n    var _this8 = this;\n    return _asyncToGenerator(function* (request, options = {}) {\n      return tracingClient.withSpan(\"ChatThreadClient-AddParticipants\", options, /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator(function* (updatedOptions) {\n          const result = yield _this8.client.chatThread.addChatParticipants(_this8.threadId, mapToAddChatParticipantsRequestRestModel(request), updatedOptions);\n          return result;\n        });\n        return function (_x0) {\n          return _ref8.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  listParticipantsPage(continuationState_1) {\n    return __asyncGenerator(this, arguments, function* listParticipantsPage_1(continuationState, options = {}) {\n      if (!continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatParticipants(this.threadId, options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  listParticipantsAll(options) {\n    return __asyncGenerator(this, arguments, function* listParticipantsAll_1() {\n      var _a, e_2, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listParticipantsPage({}, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Gets the participants of the thread identified by threadId.\n   * Returns the lists of the participants.\n   * @param options - Operation options.\n   */\n  listParticipants(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(\"ChatThreadClient-ListParticipants\", options);\n    try {\n      const iter = this.listParticipantsAll(updatedOptions);\n      return {\n        next() {\n          return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        byPage: (settings = {}) => {\n          return this.listParticipantsPage(settings, updatedOptions);\n        }\n      };\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Removes participant from the thread identified by threadId.\n   * @param participant - Thread participant to remove from the thread roster\n   * @param options - Operation options.\n   */\n  removeParticipant(_x1) {\n    var _this9 = this;\n    return _asyncToGenerator(function* (participant, options = {}) {\n      return tracingClient.withSpan(\"ChatThreadClient-RemoveParticipant\", options, /*#__PURE__*/function () {\n        var _ref9 = _asyncToGenerator(function* (updatedOptions) {\n          yield _this9.client.chatThread.removeChatParticipant(_this9.threadId, serializeCommunicationIdentifier(participant), updatedOptions);\n        });\n        return function (_x10) {\n          return _ref9.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  /**\n   * Sends a typing notification to the thread.\n   * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval\n   * @param options - - Operation options\n   * @returns True if the typing message notification could be sent, otherwise false.\n   */\n  sendTypingNotification() {\n    var _this0 = this;\n    return _asyncToGenerator(function* (options = {}) {\n      return tracingClient.withSpan(\"ChatThreadClient-SendTypingNotification\", options, /*#__PURE__*/function () {\n        var _ref0 = _asyncToGenerator(function* (updatedOptions) {\n          const dateNow = new Date();\n          const {\n              senderDisplayName\n            } = updatedOptions,\n            restOptions = __rest(updatedOptions, [\"senderDisplayName\"]);\n          if (_this0.canPostTypingNotification(dateNow)) {\n            _this0.timeOfLastTypingRequest = dateNow;\n            yield _this0.client.chatThread.sendTypingNotification(_this0.threadId, Object.assign({\n              sendTypingNotificationRequest: {\n                senderDisplayName: senderDisplayName\n              }\n            }, restOptions));\n            return true;\n          }\n          logger.info(`Typing Notification NOT Send. [thread_id=${_this0.threadId}]`);\n          return false;\n        });\n        return function (_x11) {\n          return _ref0.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  /**\n   * Sends a read receipt to the thread identified by threadId.\n   * @param request - Request for sending a read receipt\n   * @param options - Operation options.\n   */\n  sendReadReceipt(_x12) {\n    var _this1 = this;\n    return _asyncToGenerator(function* (request, options = {}) {\n      return tracingClient.withSpan(\"ChatThreadClient-SendReadReceipt\", options, /*#__PURE__*/function () {\n        var _ref1 = _asyncToGenerator(function* (updatedOptions) {\n          yield _this1.client.chatThread.sendChatReadReceipt(_this1.threadId, request, updatedOptions);\n        });\n        return function (_x13) {\n          return _ref1.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  listReadReceiptsPage(continuationState_1) {\n    return __asyncGenerator(this, arguments, function* listReadReceiptsPage_1(continuationState, options = {}) {\n      if (!continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceipts(this.threadId, options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  listReadReceiptsAll(options) {\n    return __asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {\n      var _a, e_3, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listReadReceiptsPage({}, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  /**\n   * Gets a list of read receipt from a thread identified by threadId.\n   * Returns the list of the messages.\n   * @param options - Get messages options.\n   */\n  listReadReceipts(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(\"ChatThreadClient-ListChatReadReceipts\", options);\n    try {\n      const iter = this.listReadReceiptsAll(updatedOptions);\n      return {\n        next() {\n          return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        byPage: (settings = {}) => {\n          return this.listReadReceiptsPage(settings, updatedOptions);\n        }\n      };\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  canPostTypingNotification(dateNow) {\n    if (this.timeOfLastTypingRequest) {\n      const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();\n      if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {\n        logger.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceMappingURL=chatThreadClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}