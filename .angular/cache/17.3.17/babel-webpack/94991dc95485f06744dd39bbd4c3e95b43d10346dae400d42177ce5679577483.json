{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isNodeLike } from \"../util/checkEnvironment.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n  var _a;\n  const formDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : formDataMap[key] = [];\n    formDataMap[key].push(value);\n  }\n  return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n  return {\n    name: formDataPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n          request.formData = formDataToFormDataMap(request.body);\n          request.body = undefined;\n        }\n        if (request.formData) {\n          const contentType = request.headers.get(\"Content-Type\");\n          if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n            request.body = wwwFormUrlEncode(request.formData);\n          } else {\n            yield prepareFormData(request.formData, request);\n          }\n          request.formData = undefined;\n        }\n        return next(request);\n      })();\n    }\n  };\n}\nfunction wwwFormUrlEncode(formData) {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\nfunction prepareFormData(_x, _x2) {\n  return _prepareFormData.apply(this, arguments);\n} //# sourceMappingURL=formDataPolicy.js.map\nfunction _prepareFormData() {\n  _prepareFormData = _asyncToGenerator(function* (formData, request) {\n    // validate content type (multipart/form-data)\n    const contentType = request.headers.get(\"Content-Type\");\n    if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n      // content type is specified and is not multipart/form-data. Exit.\n      return;\n    }\n    request.headers.set(\"Content-Type\", contentType !== null && contentType !== void 0 ? contentType : \"multipart/form-data\");\n    // set body to MultipartRequestBody using content from FormDataMap\n    const parts = [];\n    for (const [fieldName, values] of Object.entries(formData)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        if (typeof value === \"string\") {\n          parts.push({\n            headers: createHttpHeaders({\n              \"Content-Disposition\": `form-data; name=\"${fieldName}\"`\n            }),\n            body: stringToUint8Array(value, \"utf-8\")\n          });\n        } else if (value === undefined || value === null || typeof value !== \"object\") {\n          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n        } else {\n          // using || instead of ?? here since if value.name is empty we should create a file name\n          const fileName = value.name || \"blob\";\n          const headers = createHttpHeaders();\n          headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n          // again, || is used since an empty value.type means the content type is unset\n          headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n          parts.push({\n            headers,\n            body: value\n          });\n        }\n      }\n    }\n    request.multipartBody = {\n      parts\n    };\n  });\n  return _prepareFormData.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}