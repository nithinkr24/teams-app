{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { ConnectionState } from \"@azure/communication-signaling\";\nimport { mapToChatParticipantRestModel, mapToCreateChatThreadOptionsRestModel, mapToCreateChatThreadResultSdkModel } from \"./models/mappers.js\";\nimport { ChatApiClient } from \"./generated/src/index.js\";\nimport { ChatThreadClient } from \"./chatThreadClient.js\";\nimport { EventEmitter } from \"events\";\nimport { createCommunicationTokenCredentialPolicy } from \"./credential/communicationTokenCredentialPolicy.js\";\nimport { generateUuid } from \"./models/uuid.js\";\nimport { getSignalingClient } from \"./signaling/signalingClient.js\";\nimport { logger } from \"./models/logger.js\";\nimport { tracingClient } from \"./generated/src/tracing.js\";\n/**\n * The client to do chat operations\n */\nexport class ChatClient {\n  /**\n   * Creates an instance of the ChatClient for a given resource and user.\n   *\n   * @param endpoint - The url of the Communication Services resource.\n   * @param credential - The token credential. Use AzureCommunicationTokenCredential from \\@azure/communication-common to create a credential.\n   * @param options - Additional client options.\n   */\n  constructor(endpoint, credential, options = {}) {\n    this.endpoint = endpoint;\n    this.signalingClient = undefined;\n    this.emitter = new EventEmitter();\n    this.isRealtimeNotificationsStarted = false;\n    this.tokenCredential = credential;\n    const internalPipelineOptions = Object.assign(Object.assign({}, options), {\n      loggingOptions: {\n        logger: logger.info\n      }\n    });\n    this.client = new ChatApiClient(this.endpoint, Object.assign({\n      endpoint: this.endpoint\n    }, internalPipelineOptions));\n    const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);\n    this.client.pipeline.addPolicy(authPolicy);\n    this.clientOptions = Object.assign({}, options);\n    this.clientOptions.signalingClientOptions = Object.assign(Object.assign({}, this.clientOptions.signalingClientOptions), {\n      resourceEndpoint: this.endpoint,\n      gatewayApiVersion: this.client.apiVersion\n    });\n    this.signalingClient = getSignalingClient(credential, logger, this.clientOptions.signalingClientOptions);\n  }\n  /**\n   * Returns ChatThreadClient with the specific thread id.\n   * @param threadId - Thread ID for the ChatThreadClient\n   */\n  getChatThreadClient(threadId) {\n    return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);\n  }\n  /**\n   * Creates a chat thread.\n   * Returns thread client with the id of the created thread.\n   * @param request - Request for creating a chat thread.\n   * @param options - Operation options.\n   */\n  createChatThread(_x) {\n    var _this = this;\n    return _asyncToGenerator(function* (request, options = {}) {\n      return tracingClient.withSpan(\"ChatClient-CreateChatThread\", options, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updatedOptions) {\n          var _a, _b;\n          // We generate an UUID if the user does not provide an idempotencyToken value\n          updatedOptions.idempotencyToken = (_a = updatedOptions.idempotencyToken) !== null && _a !== void 0 ? _a : generateUuid();\n          const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);\n          const result = yield _this.client.chat.createChatThread({\n            topic: request.topic,\n            participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map(participant => mapToChatParticipantRestModel(participant)),\n            metadata: options.metadata,\n            retentionPolicy: options.retentionPolicy\n          }, updatedRestModelOptions);\n          return mapToCreateChatThreadResultSdkModel(result);\n        });\n        return function (_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  listChatThreadsPage(continuationState_1) {\n    return __asyncGenerator(this, arguments, function* listChatThreadsPage_1(continuationState, options = {}) {\n      if (!continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chat.listChatThreads(options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value);\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, options));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value);\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  listChatThreadsAll(options) {\n    return __asyncGenerator(this, arguments, function* listChatThreadsAll_1() {\n      var _a, e_1, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listChatThreadsPage({}, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Gets the list of chat threads of a user.\n   * @param options - List chat threads options.\n   */\n  listChatThreads(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(\"ChatClient-ListChatThreads\", options);\n    try {\n      const iter = this.listChatThreadsAll(updatedOptions);\n      return {\n        next() {\n          return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        byPage: (settings = {}) => {\n          return this.listChatThreadsPage(settings, updatedOptions);\n        }\n      };\n    } catch (e) {\n      span.setStatus({\n        error: e,\n        status: \"error\"\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes a chat thread.\n   * @param threadId - The ID of the thread to delete.\n   * @param options -  Operation options.\n   */\n  deleteChatThread(_x3) {\n    var _this2 = this;\n    return _asyncToGenerator(function* (threadId, options = {}) {\n      return tracingClient.withSpan(\"ChatClient-DeleteChatThread\", options, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (updatedOptions) {\n          yield _this2.client.chat.deleteChatThread(threadId, updatedOptions);\n        });\n        return function (_x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }).apply(this, arguments);\n  }\n  /**\n   * Start receiving realtime notifications.\n   * Call this function before subscribing to any event.\n   */\n  startRealtimeNotifications() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.signalingClient === undefined) {\n        throw new Error(\"Realtime notifications are not supported in node js.\");\n      }\n      if (_this3.isRealtimeNotificationsStarted) {\n        return;\n      }\n      _this3.isRealtimeNotificationsStarted = true;\n      yield _this3.signalingClient.start();\n      _this3.subscribeToSignalingEvents();\n    })();\n  }\n  /**\n   * Stop receiving realtime notifications.\n   * This function would unsubscribe to all events.\n   */\n  stopRealtimeNotifications() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_this4.signalingClient === undefined) {\n        throw new Error(\"Realtime notifications are not supported in node js.\");\n      }\n      _this4.isRealtimeNotificationsStarted = false;\n      yield _this4.signalingClient.stop();\n      _this4.emitter.removeAllListeners();\n    })();\n  }\n  on(event, listener) {\n    if (this.signalingClient === undefined) {\n      throw new Error(\"Realtime notifications are only supported in the browser.\");\n    }\n    if (!this.isRealtimeNotificationsStarted && event !== \"realTimeNotificationConnected\" && event !== \"realTimeNotificationDisconnected\") {\n      throw new Error(\"You must call startRealtimeNotifications before you can subscribe to events.\");\n    }\n    this.emitter.on(event, listener);\n  }\n  off(event, listener) {\n    if (this.signalingClient === undefined) {\n      throw new Error(\"Realtime notifications are only supported in the browser.\");\n    }\n    this.emitter.removeListener(event, listener);\n  }\n  subscribeToSignalingEvents() {\n    if (this.signalingClient === undefined) {\n      throw new Error(\"Realtime notifications are only supported in the browser.\");\n    }\n    this.signalingClient.on(\"connectionChanged\", payload => {\n      if (payload === ConnectionState.Connected) {\n        this.emitter.emit(\"realTimeNotificationConnected\");\n      } else if (payload === ConnectionState.Disconnected) {\n        this.emitter.emit(\"realTimeNotificationDisconnected\");\n      }\n    });\n    this.signalingClient.on(\"chatMessageReceived\", payload => {\n      this.emitter.emit(\"chatMessageReceived\", payload);\n    });\n    this.signalingClient.on(\"chatMessageEdited\", payload => {\n      this.emitter.emit(\"chatMessageEdited\", payload);\n    });\n    this.signalingClient.on(\"chatMessageDeleted\", payload => {\n      this.emitter.emit(\"chatMessageDeleted\", payload);\n    });\n    this.signalingClient.on(\"typingIndicatorReceived\", payload => {\n      this.emitter.emit(\"typingIndicatorReceived\", payload);\n    });\n    this.signalingClient.on(\"readReceiptReceived\", payload => {\n      this.emitter.emit(\"readReceiptReceived\", payload);\n    });\n    this.signalingClient.on(\"chatThreadCreated\", payload => {\n      this.emitter.emit(\"chatThreadCreated\", payload);\n    });\n    this.signalingClient.on(\"chatThreadDeleted\", payload => {\n      this.emitter.emit(\"chatThreadDeleted\", payload);\n    });\n    this.signalingClient.on(\"chatThreadPropertiesUpdated\", payload => {\n      this.emitter.emit(\"chatThreadPropertiesUpdated\", payload);\n    });\n    this.signalingClient.on(\"participantsAdded\", payload => {\n      this.emitter.emit(\"participantsAdded\", payload);\n    });\n    this.signalingClient.on(\"participantsRemoved\", payload => {\n      this.emitter.emit(\"participantsRemoved\", payload);\n    });\n  }\n}\n//# sourceMappingURL=chatClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}