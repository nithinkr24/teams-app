{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { parseToken } from \"./tokenParser.js\";\nconst expiredToken = {\n  token: \"\",\n  expiresOnTimestamp: -10\n};\nconst minutesToMs = minutes => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\nexport class AutoRefreshTokenCredential {\n  constructor(refreshArgs) {\n    this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;\n    this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.disposed = false;\n    const {\n      tokenRefresher,\n      token,\n      refreshProactively\n    } = refreshArgs;\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n  getToken(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.isTokenExpiringSoon(_this.currentToken)) {\n        return _this.currentToken;\n      }\n      if (!_this.isTokenValid(_this.currentToken)) {\n        const updatePromise = _this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);\n        yield updatePromise;\n      }\n      return _this.currentToken;\n    })();\n  }\n  dispose() {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n  updateTokenAndReschedule(abortSignal) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.activeTokenUpdating) {\n        return _this2.activeTokenUpdating;\n      }\n      _this2.activeTokenUpdating = _this2.refreshTokenAndReschedule(abortSignal);\n      try {\n        yield _this2.activeTokenUpdating;\n      } finally {\n        _this2.activeTokenUpdating = null;\n      }\n    })();\n  }\n  refreshTokenAndReschedule(abortSignal) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const newToken = yield _this3.refreshToken(abortSignal);\n      if (!_this3.isTokenValid(newToken)) {\n        throw new Error(\"The token returned from the tokenRefresher is expired.\");\n      }\n      _this3.currentToken = newToken;\n      if (_this3.refreshProactively) {\n        _this3.scheduleRefresh();\n      }\n    })();\n  }\n  refreshToken(abortSignal) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this4.activeTokenFetching) {\n          _this4.activeTokenFetching = _this4.refresh(abortSignal);\n        }\n        return parseToken(yield _this4.activeTokenFetching);\n      } finally {\n        _this4.activeTokenFetching = null;\n      }\n    })();\n  }\n  scheduleRefresh() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n    let timespanInMs = null;\n    if (this.isTokenExpiringSoon(this.currentToken)) {\n      // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n    } else {\n      // Schedule the next refresh for when it gets in to the soon-to-expire window.\n      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n    }\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n  isTokenValid(token) {\n    return token && Date.now() < token.expiresOnTimestamp;\n  }\n  isTokenExpiringSoon(token) {\n    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n  }\n}","map":{"version":3,"names":["parseToken","expiredToken","token","expiresOnTimestamp","minutesToMs","minutes","defaultExpiringSoonInterval","defaultRefreshAfterLifetimePercentage","AutoRefreshTokenCredential","constructor","refreshArgs","expiringSoonIntervalInMs","refreshAfterLifetimePercentage","activeTokenFetching","activeTokenUpdating","disposed","tokenRefresher","refreshProactively","refresh","currentToken","scheduleRefresh","getToken","options","_this","_asyncToGenerator","isTokenExpiringSoon","isTokenValid","updatePromise","updateTokenAndReschedule","abortSignal","dispose","activeTimeout","clearTimeout","_this2","refreshTokenAndReschedule","_this3","newToken","refreshToken","Error","_this4","tokenTtlInMs","Date","now","timespanInMs","setTimeout"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/communication-common/dist/browser/autoRefreshTokenCredential.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { parseToken } from \"./tokenParser.js\";\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes) => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\nexport class AutoRefreshTokenCredential {\n    constructor(refreshArgs) {\n        this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;\n        this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n        this.activeTokenFetching = null;\n        this.activeTokenUpdating = null;\n        this.disposed = false;\n        const { tokenRefresher, token, refreshProactively } = refreshArgs;\n        this.refresh = tokenRefresher;\n        this.currentToken = token ? parseToken(token) : expiredToken;\n        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;\n        if (this.refreshProactively) {\n            this.scheduleRefresh();\n        }\n    }\n    async getToken(options) {\n        if (!this.isTokenExpiringSoon(this.currentToken)) {\n            return this.currentToken;\n        }\n        if (!this.isTokenValid(this.currentToken)) {\n            const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);\n            await updatePromise;\n        }\n        return this.currentToken;\n    }\n    dispose() {\n        this.disposed = true;\n        this.activeTokenFetching = null;\n        this.activeTokenUpdating = null;\n        this.currentToken = expiredToken;\n        if (this.activeTimeout) {\n            clearTimeout(this.activeTimeout);\n        }\n    }\n    async updateTokenAndReschedule(abortSignal) {\n        if (this.activeTokenUpdating) {\n            return this.activeTokenUpdating;\n        }\n        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n        try {\n            await this.activeTokenUpdating;\n        }\n        finally {\n            this.activeTokenUpdating = null;\n        }\n    }\n    async refreshTokenAndReschedule(abortSignal) {\n        const newToken = await this.refreshToken(abortSignal);\n        if (!this.isTokenValid(newToken)) {\n            throw new Error(\"The token returned from the tokenRefresher is expired.\");\n        }\n        this.currentToken = newToken;\n        if (this.refreshProactively) {\n            this.scheduleRefresh();\n        }\n    }\n    async refreshToken(abortSignal) {\n        try {\n            if (!this.activeTokenFetching) {\n                this.activeTokenFetching = this.refresh(abortSignal);\n            }\n            return parseToken(await this.activeTokenFetching);\n        }\n        finally {\n            this.activeTokenFetching = null;\n        }\n    }\n    scheduleRefresh() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.activeTimeout) {\n            clearTimeout(this.activeTimeout);\n        }\n        const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n        let timespanInMs = null;\n        if (this.isTokenExpiringSoon(this.currentToken)) {\n            // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n            timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n        }\n        else {\n            // Schedule the next refresh for when it gets in to the soon-to-expire window.\n            timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n        }\n        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n    }\n    isTokenValid(token) {\n        return token && Date.now() < token.expiresOnTimestamp;\n    }\n    isTokenExpiringSoon(token) {\n        return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}