{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nimport { randomUUID } from \"../util/uuidUtils.js\";\nimport { concat } from \"../util/concat.js\";\nfunction generateBoundary() {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\nfunction encodeHeaders(headers) {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\nfunction getLength(source) {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\nfunction getTotalLength(sources) {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\nfunction buildRequestBody(_x, _x2, _x3) {\n  return _buildRequestBody.apply(this, arguments);\n}\n/**\n * Name of multipart policy\n */\nfunction _buildRequestBody() {\n  _buildRequestBody = _asyncToGenerator(function* (request, parts, boundary) {\n    const sources = [stringToUint8Array(`--${boundary}`, \"utf-8\"), ...parts.flatMap(part => [stringToUint8Array(\"\\r\\n\", \"utf-8\"), stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"), stringToUint8Array(\"\\r\\n\", \"utf-8\"), part.body, stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\")]), stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\")];\n    const contentLength = getTotalLength(sources);\n    if (contentLength) {\n      request.headers.set(\"Content-Length\", contentLength);\n    }\n    request.body = yield concat(sources);\n  });\n  return _buildRequestBody.apply(this, arguments);\n}\nexport const multipartPolicyName = \"multipartPolicy\";\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);\nfunction assertValidBoundary(boundary) {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n  if (Array.from(boundary).some(x => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n  return {\n    name: multipartPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a;\n        if (!request.multipartBody) {\n          return next(request);\n        }\n        if (request.body) {\n          throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n        }\n        let boundary = request.multipartBody.boundary;\n        const contentTypeHeader = (_a = request.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"multipart/mixed\";\n        const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n        if (!parsedHeader) {\n          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);\n        }\n        const [, contentType, parsedBoundary] = parsedHeader;\n        if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);\n        }\n        boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;\n        if (boundary) {\n          assertValidBoundary(boundary);\n        } else {\n          boundary = generateBoundary();\n        }\n        request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n        yield buildRequestBody(request, request.multipartBody.parts, boundary);\n        request.multipartBody = undefined;\n        return next(request);\n      })();\n    }\n  };\n}","map":{"version":3,"names":["stringToUint8Array","isBlob","randomUUID","concat","generateBoundary","encodeHeaders","headers","result","key","value","getLength","source","Uint8Array","byteLength","size","undefined","getTotalLength","sources","total","partLength","buildRequestBody","_x","_x2","_x3","_buildRequestBody","apply","arguments","_asyncToGenerator","request","parts","boundary","flatMap","part","body","contentLength","set","multipartPolicyName","maxBoundaryLength","validBoundaryCharacters","Set","assertValidBoundary","length","Error","Array","from","some","x","has","multipartPolicy","name","sendRequest","next","_a","multipartBody","contentTypeHeader","get","parsedHeader","match","contentType","parsedBoundary"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/policies/multipartPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nimport { randomUUID } from \"../util/uuidUtils.js\";\nimport { concat } from \"../util/concat.js\";\nfunction generateBoundary() {\n    return `----AzSDKFormBoundary${randomUUID()}`;\n}\nfunction encodeHeaders(headers) {\n    let result = \"\";\n    for (const [key, value] of headers) {\n        result += `${key}: ${value}\\r\\n`;\n    }\n    return result;\n}\nfunction getLength(source) {\n    if (source instanceof Uint8Array) {\n        return source.byteLength;\n    }\n    else if (isBlob(source)) {\n        // if was created using createFile then -1 means we have an unknown size\n        return source.size === -1 ? undefined : source.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction getTotalLength(sources) {\n    let total = 0;\n    for (const source of sources) {\n        const partLength = getLength(source);\n        if (partLength === undefined) {\n            return undefined;\n        }\n        else {\n            total += partLength;\n        }\n    }\n    return total;\n}\nasync function buildRequestBody(request, parts, boundary) {\n    const sources = [\n        stringToUint8Array(`--${boundary}`, \"utf-8\"),\n        ...parts.flatMap((part) => [\n            stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n            stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n            stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n            part.body,\n            stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n        ]),\n        stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n    ];\n    const contentLength = getTotalLength(sources);\n    if (contentLength) {\n        request.headers.set(\"Content-Length\", contentLength);\n    }\n    request.body = await concat(sources);\n}\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);\nfunction assertValidBoundary(boundary) {\n    if (boundary.length > maxBoundaryLength) {\n        throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n    }\n    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n        throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n    }\n}\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n    return {\n        name: multipartPolicyName,\n        async sendRequest(request, next) {\n            var _a;\n            if (!request.multipartBody) {\n                return next(request);\n            }\n            if (request.body) {\n                throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n            }\n            let boundary = request.multipartBody.boundary;\n            const contentTypeHeader = (_a = request.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"multipart/mixed\";\n            const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n            if (!parsedHeader) {\n                throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);\n            }\n            const [, contentType, parsedBoundary] = parsedHeader;\n            if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n                throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);\n            }\n            boundary !== null && boundary !== void 0 ? boundary : (boundary = parsedBoundary);\n            if (boundary) {\n                assertValidBoundary(boundary);\n            }\n            else {\n                boundary = generateBoundary();\n            }\n            request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n            await buildRequestBody(request, request.multipartBody.parts, boundary);\n            request.multipartBody = undefined;\n            return next(request);\n        },\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}