{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"../util/helpers.js\";\nimport { AbortError } from \"../abort-controller/AbortError.js\";\nimport { createClientLogger } from \"../logger/logger.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nconst retryPolicyLogger = createClientLogger(\"ts-http-runtime retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        let response;\n        let responseError;\n        let retryCount = -1;\n        retryRequest: while (true) {\n          retryCount += 1;\n          response = undefined;\n          responseError = undefined;\n          try {\n            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n            response = yield next(request);\n            logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n          } catch (e) {\n            logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n            // RestErrors are valid targets for the retry strategies.\n            // If none of the retry strategies can work with them, they will be thrown later in this policy.\n            // If the received error is not a RestError, it is immediately thrown.\n            responseError = e;\n            if (!e || responseError.name !== \"RestError\") {\n              throw e;\n            }\n            response = responseError.response;\n          }\n          if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            logger.error(`Retry ${retryCount}: Request aborted.`);\n            const abortError = new AbortError();\n            throw abortError;\n          }\n          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n            logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n            if (responseError) {\n              throw responseError;\n            } else if (response) {\n              return response;\n            } else {\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            }\n          }\n          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n          strategiesLoop: for (const strategy of strategies) {\n            const strategyLogger = strategy.logger || logger;\n            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n            const modifiers = strategy.retry({\n              retryCount,\n              response,\n              responseError\n            });\n            if (modifiers.skipStrategy) {\n              strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n              continue strategiesLoop;\n            }\n            const {\n              errorToThrow,\n              retryAfterInMs,\n              redirectTo\n            } = modifiers;\n            if (errorToThrow) {\n              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n              throw errorToThrow;\n            }\n            if (retryAfterInMs || retryAfterInMs === 0) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n              yield delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n              continue retryRequest;\n            }\n            if (redirectTo) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n              request.url = redirectTo;\n              continue retryRequest;\n            }\n          }\n          if (responseError) {\n            logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n            throw responseError;\n          }\n          if (response) {\n            logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n            return response;\n          }\n          // If all the retries skip and there's no response,\n          // we're still in the retry loop, so a new request will be sent\n          // until `maxRetries` is reached.\n        }\n      })();\n    }\n  };\n}\n//# sourceMappingURL=retryPolicy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}