{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isNodeLike } from \"../util/checkEnvironment.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n  var _a;\n  const formDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : formDataMap[key] = [];\n    formDataMap[key].push(value);\n  }\n  return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n  return {\n    name: formDataPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n          request.formData = formDataToFormDataMap(request.body);\n          request.body = undefined;\n        }\n        if (request.formData) {\n          const contentType = request.headers.get(\"Content-Type\");\n          if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n            request.body = wwwFormUrlEncode(request.formData);\n          } else {\n            yield prepareFormData(request.formData, request);\n          }\n          request.formData = undefined;\n        }\n        return next(request);\n      })();\n    }\n  };\n}\nfunction wwwFormUrlEncode(formData) {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\nfunction prepareFormData(_x, _x2) {\n  return _prepareFormData.apply(this, arguments);\n}\nfunction _prepareFormData() {\n  _prepareFormData = _asyncToGenerator(function* (formData, request) {\n    // validate content type (multipart/form-data)\n    const contentType = request.headers.get(\"Content-Type\");\n    if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n      // content type is specified and is not multipart/form-data. Exit.\n      return;\n    }\n    request.headers.set(\"Content-Type\", contentType !== null && contentType !== void 0 ? contentType : \"multipart/form-data\");\n    // set body to MultipartRequestBody using content from FormDataMap\n    const parts = [];\n    for (const [fieldName, values] of Object.entries(formData)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        if (typeof value === \"string\") {\n          parts.push({\n            headers: createHttpHeaders({\n              \"Content-Disposition\": `form-data; name=\"${fieldName}\"`\n            }),\n            body: stringToUint8Array(value, \"utf-8\")\n          });\n        } else if (value === undefined || value === null || typeof value !== \"object\") {\n          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n        } else {\n          // using || instead of ?? here since if value.name is empty we should create a file name\n          const fileName = value.name || \"blob\";\n          const headers = createHttpHeaders();\n          headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n          // again, || is used since an empty value.type means the content type is unset\n          headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n          parts.push({\n            headers,\n            body: value\n          });\n        }\n      }\n    }\n    request.multipartBody = {\n      parts\n    };\n  });\n  return _prepareFormData.apply(this, arguments);\n}","map":{"version":3,"names":["stringToUint8Array","isNodeLike","createHttpHeaders","formDataPolicyName","formDataToFormDataMap","formData","_a","formDataMap","key","value","entries","push","formDataPolicy","name","sendRequest","request","next","_asyncToGenerator","FormData","body","undefined","contentType","headers","get","indexOf","wwwFormUrlEncode","prepareFormData","urlSearchParams","URLSearchParams","Object","Array","isArray","subValue","append","toString","_x","_x2","_prepareFormData","apply","arguments","startsWith","set","parts","fieldName","values","Error","fileName","type","multipartBody"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/policies/formDataPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isNodeLike } from \"../util/checkEnvironment.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n    var _a;\n    const formDataMap = {};\n    for (const [key, value] of formData.entries()) {\n        (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : (formDataMap[key] = []);\n        formDataMap[key].push(value);\n    }\n    return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n    return {\n        name: formDataPolicyName,\n        async sendRequest(request, next) {\n            if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n                request.formData = formDataToFormDataMap(request.body);\n                request.body = undefined;\n            }\n            if (request.formData) {\n                const contentType = request.headers.get(\"Content-Type\");\n                if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n                    request.body = wwwFormUrlEncode(request.formData);\n                }\n                else {\n                    await prepareFormData(request.formData, request);\n                }\n                request.formData = undefined;\n            }\n            return next(request);\n        },\n    };\n}\nfunction wwwFormUrlEncode(formData) {\n    const urlSearchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(formData)) {\n        if (Array.isArray(value)) {\n            for (const subValue of value) {\n                urlSearchParams.append(key, subValue.toString());\n            }\n        }\n        else {\n            urlSearchParams.append(key, value.toString());\n        }\n    }\n    return urlSearchParams.toString();\n}\nasync function prepareFormData(formData, request) {\n    // validate content type (multipart/form-data)\n    const contentType = request.headers.get(\"Content-Type\");\n    if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n        // content type is specified and is not multipart/form-data. Exit.\n        return;\n    }\n    request.headers.set(\"Content-Type\", contentType !== null && contentType !== void 0 ? contentType : \"multipart/form-data\");\n    // set body to MultipartRequestBody using content from FormDataMap\n    const parts = [];\n    for (const [fieldName, values] of Object.entries(formData)) {\n        for (const value of Array.isArray(values) ? values : [values]) {\n            if (typeof value === \"string\") {\n                parts.push({\n                    headers: createHttpHeaders({\n                        \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n                    }),\n                    body: stringToUint8Array(value, \"utf-8\"),\n                });\n            }\n            else if (value === undefined || value === null || typeof value !== \"object\") {\n                throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n            }\n            else {\n                // using || instead of ?? here since if value.name is empty we should create a file name\n                const fileName = value.name || \"blob\";\n                const headers = createHttpHeaders();\n                headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n                // again, || is used since an empty value.type means the content type is unset\n                headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n                parts.push({\n                    headers,\n                    body: value,\n                });\n            }\n        }\n    }\n    request.multipartBody = { parts };\n}\n"],"mappings":";AAAA;AACA;AACA,SAASA,kBAAkB,QAAQ,0BAA0B;AAC7D,SAASC,UAAU,QAAQ,6BAA6B;AACxD,SAASC,iBAAiB,QAAQ,mBAAmB;AACrD;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAG,gBAAgB;AAClD,SAASC,qBAAqBA,CAACC,QAAQ,EAAE;EACrC,IAAIC,EAAE;EACN,MAAMC,WAAW,GAAG,CAAC,CAAC;EACtB,KAAK,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,IAAIJ,QAAQ,CAACK,OAAO,CAAC,CAAC,EAAE;IAC3C,CAACJ,EAAE,GAAGC,WAAW,CAACC,GAAG,CAAC,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAIC,WAAW,CAACC,GAAG,CAAC,GAAG,EAAG;IAChFD,WAAW,CAACC,GAAG,CAAC,CAACG,IAAI,CAACF,KAAK,CAAC;EAChC;EACA,OAAOF,WAAW;AACtB;AACA;AACA;AACA;AACA,OAAO,SAASK,cAAcA,CAAA,EAAG;EAC7B,OAAO;IACHC,IAAI,EAAEV,kBAAkB;IAClBW,WAAWA,CAACC,OAAO,EAAEC,IAAI,EAAE;MAAA,OAAAC,iBAAA;QAC7B,IAAIhB,UAAU,IAAI,OAAOiB,QAAQ,KAAK,WAAW,IAAIH,OAAO,CAACI,IAAI,YAAYD,QAAQ,EAAE;UACnFH,OAAO,CAACV,QAAQ,GAAGD,qBAAqB,CAACW,OAAO,CAACI,IAAI,CAAC;UACtDJ,OAAO,CAACI,IAAI,GAAGC,SAAS;QAC5B;QACA,IAAIL,OAAO,CAACV,QAAQ,EAAE;UAClB,MAAMgB,WAAW,GAAGN,OAAO,CAACO,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;UACvD,IAAIF,WAAW,IAAIA,WAAW,CAACG,OAAO,CAAC,mCAAmC,CAAC,KAAK,CAAC,CAAC,EAAE;YAChFT,OAAO,CAACI,IAAI,GAAGM,gBAAgB,CAACV,OAAO,CAACV,QAAQ,CAAC;UACrD,CAAC,MACI;YACD,MAAMqB,eAAe,CAACX,OAAO,CAACV,QAAQ,EAAEU,OAAO,CAAC;UACpD;UACAA,OAAO,CAACV,QAAQ,GAAGe,SAAS;QAChC;QACA,OAAOJ,IAAI,CAACD,OAAO,CAAC;MAAC;IACzB;EACJ,CAAC;AACL;AACA,SAASU,gBAAgBA,CAACpB,QAAQ,EAAE;EAChC,MAAMsB,eAAe,GAAG,IAAIC,eAAe,CAAC,CAAC;EAC7C,KAAK,MAAM,CAACpB,GAAG,EAAEC,KAAK,CAAC,IAAIoB,MAAM,CAACnB,OAAO,CAACL,QAAQ,CAAC,EAAE;IACjD,IAAIyB,KAAK,CAACC,OAAO,CAACtB,KAAK,CAAC,EAAE;MACtB,KAAK,MAAMuB,QAAQ,IAAIvB,KAAK,EAAE;QAC1BkB,eAAe,CAACM,MAAM,CAACzB,GAAG,EAAEwB,QAAQ,CAACE,QAAQ,CAAC,CAAC,CAAC;MACpD;IACJ,CAAC,MACI;MACDP,eAAe,CAACM,MAAM,CAACzB,GAAG,EAAEC,KAAK,CAACyB,QAAQ,CAAC,CAAC,CAAC;IACjD;EACJ;EACA,OAAOP,eAAe,CAACO,QAAQ,CAAC,CAAC;AACrC;AAAC,SACcR,eAAeA,CAAAS,EAAA,EAAAC,GAAA;EAAA,OAAAC,gBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,iBAAA;EAAAA,gBAAA,GAAApB,iBAAA,CAA9B,WAA+BZ,QAAQ,EAAEU,OAAO,EAAE;IAC9C;IACA,MAAMM,WAAW,GAAGN,OAAO,CAACO,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;IACvD,IAAIF,WAAW,IAAI,CAACA,WAAW,CAACmB,UAAU,CAAC,qBAAqB,CAAC,EAAE;MAC/D;MACA;IACJ;IACAzB,OAAO,CAACO,OAAO,CAACmB,GAAG,CAAC,cAAc,EAAEpB,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,qBAAqB,CAAC;IACzH;IACA,MAAMqB,KAAK,GAAG,EAAE;IAChB,KAAK,MAAM,CAACC,SAAS,EAAEC,MAAM,CAAC,IAAIf,MAAM,CAACnB,OAAO,CAACL,QAAQ,CAAC,EAAE;MACxD,KAAK,MAAMI,KAAK,IAAIqB,KAAK,CAACC,OAAO,CAACa,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC,EAAE;QAC3D,IAAI,OAAOnC,KAAK,KAAK,QAAQ,EAAE;UAC3BiC,KAAK,CAAC/B,IAAI,CAAC;YACPW,OAAO,EAAEpB,iBAAiB,CAAC;cACvB,qBAAqB,EAAE,oBAAoByC,SAAS;YACxD,CAAC,CAAC;YACFxB,IAAI,EAAEnB,kBAAkB,CAACS,KAAK,EAAE,OAAO;UAC3C,CAAC,CAAC;QACN,CAAC,MACI,IAAIA,KAAK,KAAKW,SAAS,IAAIX,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;UACzE,MAAM,IAAIoC,KAAK,CAAC,4BAA4BF,SAAS,KAAKlC,KAAK,+CAA+C,CAAC;QACnH,CAAC,MACI;UACD;UACA,MAAMqC,QAAQ,GAAGrC,KAAK,CAACI,IAAI,IAAI,MAAM;UACrC,MAAMS,OAAO,GAAGpB,iBAAiB,CAAC,CAAC;UACnCoB,OAAO,CAACmB,GAAG,CAAC,qBAAqB,EAAE,oBAAoBE,SAAS,gBAAgBG,QAAQ,GAAG,CAAC;UAC5F;UACAxB,OAAO,CAACmB,GAAG,CAAC,cAAc,EAAEhC,KAAK,CAACsC,IAAI,IAAI,0BAA0B,CAAC;UACrEL,KAAK,CAAC/B,IAAI,CAAC;YACPW,OAAO;YACPH,IAAI,EAAEV;UACV,CAAC,CAAC;QACN;MACJ;IACJ;IACAM,OAAO,CAACiC,aAAa,GAAG;MAAEN;IAAM,CAAC;EACrC,CAAC;EAAA,OAAAL,gBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}