{"ast":null,"code":"import { __awaiter as e } from \"../../../../node_modules/.pnpm/@rollup_plugin-typescript@11.1.6_rollup@4.24.4_tslib@2.6.3_typescript@4.9.5/node_modules/tslib/tslib.es6.js\";\nimport { isSdkError as n, ErrorCode as t } from \"../public/interfaces.js\";\nimport { latestRuntimeApiVersion as o } from \"../public/runtime.js\";\nimport { isSerializable as r } from \"../public/serializable.interface.js\";\nimport { UUID as i } from \"../public/uuidObject.js\";\nimport { version as s } from \"../public/version.js\";\nimport { uninitializeChildCommunication as a, shouldProcessChildMessage as c, handleIncomingMessageFromChild as d } from \"./childCommunication.js\";\nimport { getMessageIdsAsLogString as u, flushMessageQueue as l } from \"./communicationUtils.js\";\nimport { GlobalVars as g } from \"./globalVars.js\";\nimport { callHandler as p } from \"./handlers.js\";\nimport f from \"./hostToAppTelemetry.js\";\nimport { serializeMessageRequest as m, deserializeMessageResponse as w } from \"./messageObjects.js\";\nimport { tryPolyfillWithNestedAppAuthBridge as h } from \"./nestedAppAuthUtils.js\";\nimport { getLogger as v, isFollowingApiVersionTagFormat as b } from \"./telemetry.js\";\nimport { getCurrentTimestamp as W, ssrSafeWindow as M } from \"./utils.js\";\nimport { validateOrigin as y } from \"./validOrigins.js\";\nconst k = v(\"communication\");\nclass I {}\nclass T {}\nfunction E(n, t) {\n  if (T.messageListener = n => function (n) {\n    return e(this, void 0, void 0, function* () {\n      if (!n || !n.data || \"object\" != typeof n.data) return void J(\"Unrecognized message format received by app, message being ignored. Message: %o\", n);\n      const e = n.source || n.originalEvent && n.originalEvent.source,\n        t = n.origin || n.originalEvent && n.originalEvent.origin;\n      return B(e, t).then(o => {\n        o ? (!function (e, n) {\n          g.isFramelessWindow || I.parentWindow && !I.parentWindow.closed && e !== I.parentWindow || (I.parentWindow = e, I.parentOrigin = n);\n          I.parentWindow && I.parentWindow.closed && (I.parentWindow = null, I.parentOrigin = null);\n          l(I.parentWindow, I.parentOrigin, T.parentMessageQueue, \"parent\");\n        }(e, t), e !== I.parentWindow ? c(e, t) && d(n, e, V, (e, n) => T.callbacks.set(e, n)) : Y(n)) : J(\"Message being ignored by app because it is either coming from the current window or a different window with an invalid origin, message: %o, source: %o, origin: %o\", n, e, t);\n      });\n    });\n  }(n), I.currentWindow = I.currentWindow || M(), I.parentWindow = I.currentWindow.parent !== I.currentWindow.self ? I.currentWindow.parent : I.currentWindow.opener, I.topWindow = I.currentWindow.top, (I.parentWindow || n) && I.currentWindow.addEventListener(\"message\", T.messageListener, !1), !I.parentWindow) {\n    const e = I.currentWindow;\n    if (!e.nativeInterface) return Promise.reject(new Error(\"Initialization Failed. No Parent window found.\"));\n    g.isFramelessWindow = !0, e.onNativeMessage = Y;\n  }\n  try {\n    return I.parentOrigin = \"*\", S(t, \"initialize\", [s, o, n]).then(([e, n, t, o]) => (h(o, I.currentWindow, {\n      onMessage: D,\n      sendPostMessage: L\n    }), {\n      context: e,\n      clientType: n,\n      runtimeConfig: t,\n      clientSupportedSDKVersion: o\n    }));\n  } finally {\n    I.parentOrigin = null;\n  }\n}\nfunction j() {\n  I.currentWindow && I.currentWindow.removeEventListener(\"message\", T.messageListener, !1), I.currentWindow = null, I.parentWindow = null, I.parentOrigin = null, T.parentMessageQueue = [], T.nextMessageId = 0, T.callbacks.clear(), T.promiseCallbacks.clear(), T.portCallbacks.clear(), T.legacyMessageIdsToUuidMap = {}, f.clearMessages(), a();\n}\nfunction O(e, n, ...t) {\n  return S(e, n, t).then(([e]) => e);\n}\nfunction R(e, n, ...t) {\n  return S(e, n, t).then(([e, n]) => {\n    if (!e) throw new Error(n);\n  });\n}\nfunction C(e, n, t, ...o) {\n  return S(e, n, o).then(([e, n]) => {\n    if (!e) throw new Error(n || t);\n  });\n}\nfunction P(e, n, ...t) {\n  return S(e, n, t).then(([e, n]) => {\n    if (e) throw e;\n    return n;\n  });\n}\nfunction S(e, n, t = void 0) {\n  if (!b(e)) throw Error(`apiVersionTag: ${e} passed in doesn't follow the pattern starting with 'v' followed by digits, then underscore with words, please check.`);\n  return new Promise(o => {\n    const r = V(e, n, t);\n    var i;\n    o((i = r.uuid, new Promise(e => {\n      T.promiseCallbacks.set(i, e);\n    })));\n  });\n}\nfunction x(e) {\n  return e.map(e => r(e) ? e.serialize() : e);\n}\nfunction N(o, r, i, s, a) {\n  var c;\n  return e(this, void 0, void 0, function* () {\n    const e = x(r),\n      [d] = yield S(s, o, e);\n    if (a && a(d) || !a && n(d)) throw new Error(`${d.errorCode}, message: ${null !== (c = d.message) && void 0 !== c ? c : \"None\"}`);\n    if (i.validate(d)) return i.deserialize(d);\n    throw new Error(`${t.INTERNAL_ERROR}, message: Invalid response from host - ${JSON.stringify(d)}`);\n  });\n}\nfunction A(o, r, i, s) {\n  var a;\n  return e(this, void 0, void 0, function* () {\n    const e = x(r),\n      [c] = yield S(i, o, e);\n    if (s && s(c) || !s && n(c)) throw new Error(`${c.errorCode}, message: ${null !== (a = c.message) && void 0 !== a ? a : \"None\"}`);\n    if (void 0 !== c) throw new Error(`${t.INTERNAL_ERROR}, message: Invalid response from host`);\n  });\n}\nfunction U(e, n, t = void 0) {\n  if (!b(e)) throw Error(`apiVersionTag: ${e} passed in doesn't follow the pattern starting with 'v' followed by digits, then underscore with words, please check.`);\n  const o = V(e, n, t);\n  return r = o.uuid, new Promise((e, n) => {\n    T.portCallbacks.set(r, (t, o) => {\n      t instanceof MessagePort ? e(t) : n(o && o.length > 0 ? o[0] : new Error(\"Host responded without port or error details.\"));\n    });\n  });\n  var r;\n}\nfunction $(e, n, t, o) {\n  let r;\n  if (t instanceof Function ? o = t : t instanceof Array && (r = t), !b(e)) throw Error(`apiVersionTag: ${e} passed in doesn't follow the pattern starting with 'v' followed by digits, then underscore with words, please check.`);\n  const i = V(e, n, r);\n  o && T.callbacks.set(i.uuid, o);\n}\nT.parentMessageQueue = [], T.topMessageQueue = [], T.nextMessageId = 0, T.callbacks = new Map(), T.promiseCallbacks = new Map(), T.portCallbacks = new Map(), T.legacyMessageIdsToUuidMap = {};\nconst z = k.extend(\"sendNestedAuthRequestToTopWindow\");\nfunction L(e, n) {\n  const t = z,\n    o = I.topWindow,\n    r = function (e, n) {\n      const t = T.nextMessageId++,\n        o = new i();\n      return T.legacyMessageIdsToUuidMap[t] = o, {\n        id: t,\n        uuid: o,\n        func: \"nestedAppAuth.execute\",\n        timestamp: Date.now(),\n        monotonicTimestamp: W(),\n        apiVersionTag: n,\n        args: [],\n        data: e\n      };\n    }(e, n);\n  return t(\"Message %s information: %o\", u(r), {\n    actionName: r.func\n  }), F(o, r);\n}\nconst _ = k.extend(\"sendRequestToTargetWindowHelper\");\nfunction F(e, n) {\n  const t = _,\n    o = function (e) {\n      return e === I.topWindow && Z() ? \"top\" : e === I.parentWindow ? \"parent\" : null;\n    }(e),\n    r = m(n);\n  if (g.isFramelessWindow) I.currentWindow && I.currentWindow.nativeInterface && (t(\"Sending message %s to %s via framelessPostMessage interface\", u(r), o), I.currentWindow.nativeInterface.framelessPostMessage(JSON.stringify(r)));else {\n    const i = function (e) {\n      return e === I.topWindow && Z() ? I.topOrigin : e === I.parentWindow ? I.parentOrigin : null;\n    }(e);\n    e && i ? (t(\"Sending message %s to %s via postMessage\", u(r), o), e.postMessage(r, i)) : (t(\"Adding message %s to %s message queue\", u(r), o), ee(e).push(n));\n  }\n  return n;\n}\nconst Q = k.extend(\"sendMessageToParentHelper\");\nfunction V(e, n, t, o, r) {\n  const s = Q,\n    a = I.parentWindow,\n    c = function (e, n, t, o, r) {\n      const s = T.nextMessageId++,\n        a = new i();\n      T.legacyMessageIdsToUuidMap[s] = a;\n      const c = !0 === o ? r : g.teamsJsInstanceId;\n      return {\n        id: s,\n        uuid: a,\n        func: n,\n        timestamp: Date.now(),\n        monotonicTimestamp: W(),\n        args: t || [],\n        apiVersionTag: e,\n        isProxiedFromChild: null != o && o,\n        teamsJsInstanceId: c\n      };\n    }(e, n, t, o, r);\n  return f.storeCallbackInformation(c.uuid, {\n    name: n,\n    calledAt: c.timestamp\n  }), s(\"Message %s information: %o\", u(c), {\n    actionName: n,\n    args: t\n  }), F(a, c);\n}\nconst J = k.extend(\"processIncomingMessage\");\nconst q = k.extend(\"processAuthBridgeMessage\");\nfunction D(e, n) {\n  var t, o;\n  const r = q;\n  if (!e || !e.data || \"object\" != typeof e.data) return void r(\"Unrecognized message format received by app, message being ignored. Message: %o\", e);\n  const {\n      args: i\n    } = e.data,\n    [, s] = null != i ? i : [],\n    a = (() => {\n      try {\n        return JSON.parse(s);\n      } catch (e) {\n        return null;\n      }\n    })();\n  if (!a || \"object\" != typeof a || \"NestedAppAuthResponse\" !== a.messageType) return void r(\"Unrecognized data format received by app, message being ignored. Message: %o\", e);\n  const c = e.source || (null === (t = null == e ? void 0 : e.originalEvent) || void 0 === t ? void 0 : t.source),\n    d = e.origin || (null === (o = null == e ? void 0 : e.originalEvent) || void 0 === o ? void 0 : o.origin);\n  c ? B(c, d) ? (I.topWindow && !I.topWindow.closed && c !== I.topWindow || (I.topWindow = c, I.topOrigin = d), I.topWindow && I.topWindow.closed && (I.topWindow = null, I.topOrigin = null), l(I.topWindow, I.topOrigin, T.topMessageQueue, \"top\"), n(s)) : r(\"Message being ignored by app because it is either coming from the current window or a different window with an invalid origin\") : r(\"Message being ignored by app because it is coming for a target that is null\");\n}\nconst H = k.extend(\"shouldProcessIncomingMessage\");\nfunction B(n, t) {\n  return e(this, void 0, void 0, function* () {\n    if (I.currentWindow && n === I.currentWindow) return H(\"Should not process message because it is coming from the current window\"), !1;\n    if (I.currentWindow && I.currentWindow.location && t && t === I.currentWindow.location.origin) return !0;\n    {\n      let e;\n      try {\n        e = new URL(t);\n      } catch (e) {\n        return H(\"Message has an invalid origin of %s\", t), !1;\n      }\n      const n = yield y(e);\n      return n || H(\"Message has an invalid origin of %s\", t), n;\n    }\n  });\n}\nconst K = k.extend(\"handleIncomingMessageFromParent\");\nfunction G(e, n) {\n  if (n) {\n    const t = [...e].find(([e, t]) => e.toString() === n.toString());\n    if (t) return t[0];\n  }\n}\nfunction X(e, n) {\n  const t = G(n, e.uuid);\n  t && n.delete(t), e.uuid ? T.legacyMessageIdsToUuidMap = {} : delete T.legacyMessageIdsToUuidMap[e.id];\n}\nfunction Y(e) {\n  const n = K,\n    t = W();\n  if (\"id\" in e.data && \"number\" == typeof e.data.id) {\n    const o = e.data,\n      r = w(o),\n      i = function (e) {\n        const n = K;\n        if (!e.uuid) return T.legacyMessageIdsToUuidMap[e.id];\n        {\n          const n = e.uuid,\n            t = G(T.callbacks, n);\n          if (t) return t;\n          const o = G(T.promiseCallbacks, n);\n          if (o) return o;\n          const r = G(T.portCallbacks, n);\n          if (r) return r;\n        }\n        n(\"Received message %s that failed to produce a callbackId\", u(e));\n      }(r);\n    if (i) {\n      const o = T.callbacks.get(i);\n      n(\"Received a response from parent for message %s\", i.toString()), f.handlePerformanceMetrics(i, r, n, t), o && (n(\"Invoking the registered callback for message %s with arguments %o\", i.toString(), r.args), o.apply(null, [...r.args, r.isPartialResponse]), function (e) {\n        return !0 === e.data.isPartialResponse;\n      }(e) || (n(\"Removing registered callback for message %s\", i.toString()), X(r, T.callbacks)));\n      const s = T.promiseCallbacks.get(i);\n      s && (n(\"Invoking the registered promise callback for message %s with arguments %o\", i.toString(), r.args), s(r.args), n(\"Removing registered promise callback for message %s\", i.toString()), X(r, T.promiseCallbacks));\n      const a = T.portCallbacks.get(i);\n      if (a) {\n        let t;\n        n(\"Invoking the registered port callback for message %s with arguments %o\", i.toString(), r.args), e.ports && e.ports[0] instanceof MessagePort && (t = e.ports[0]), a(t, r.args), n(\"Removing registered port callback for message %s\", i.toString()), X(r, T.portCallbacks);\n      }\n      r.uuid && (T.legacyMessageIdsToUuidMap = {});\n    }\n  } else if (\"func\" in e.data && \"string\" == typeof e.data.func) {\n    const o = e.data;\n    f.handleOneWayPerformanceMetrics(o, n, t), n('Received a message from parent %s, action: \"%s\"', u(o), o.func), p(o.func, o.args);\n  } else n(\"Received an unknown message: %O\", e);\n}\nfunction Z() {\n  return I.topWindow !== I.parentWindow;\n}\nfunction ee(e) {\n  return e === I.topWindow && Z() ? T.topMessageQueue : e === I.parentWindow ? T.parentMessageQueue : [];\n}\nfunction ne(e, n) {\n  let t;\n  t = I.currentWindow.setInterval(() => {\n    0 === ee(e).length && (clearInterval(t), n());\n  }, 100);\n}\nexport { I as Communication, A as callFunctionInHost, N as callFunctionInHostAndHandleResponse, E as initializeCommunication, U as requestPortFromParentWithVersion, P as sendAndHandleSdkError, R as sendAndHandleStatusAndReason, C as sendAndHandleStatusAndReasonWithDefaultError, O as sendAndUnwrap, $ as sendMessageToParent, S as sendMessageToParentAsync, L as sendNestedAuthRequestToTopWindow, j as uninitializeCommunication, ne as waitForMessageQueue };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}