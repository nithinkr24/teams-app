{"ast":null,"code":"'use strict';\n\nvar uuid = require('uuid');\nvar coreUtil = require('@azure/core-util');\nvar coreClient = require('@azure/core-client');\nvar coreRestPipeline = require('@azure/core-rest-pipeline');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar uuid__default = /*#__PURE__*/_interopDefaultLegacy(uuid);\nvar coreUtil__default = /*#__PURE__*/_interopDefaultLegacy(coreUtil);\nvar coreClient__default = /*#__PURE__*/_interopDefaultLegacy(coreClient);\nvar coreRestPipeline__default = /*#__PURE__*/_interopDefaultLegacy(coreRestPipeline);\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\nvar tsregistrar = createCommonjsModule(function (module, exports) {\n  !function (t, e) {\n    module.exports = e();\n  }(commonjsGlobal, function () {\n    return function (t) {\n      function e(n) {\n        if (r[n]) return r[n].exports;\n        var o = r[n] = {\n          i: n,\n          l: !1,\n          exports: {}\n        };\n        return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n      }\n      var r = {};\n      return e.m = t, e.c = r, e.i = function (t) {\n        return t;\n      }, e.d = function (t, r, n) {\n        e.o(t, r) || Object.defineProperty(t, r, {\n          configurable: !1,\n          enumerable: !0,\n          get: n\n        });\n      }, e.n = function (t) {\n        var r = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return e.d(r, \"a\", r), r;\n      }, e.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, e.p = \"\", e(e.s = 1);\n    }([function (t, e, r) {\n      function n(t, e) {\n        var r,\n          n = new Promise(function (e, n) {\n            fetch(t).then(function (t) {\n              void 0 !== r && clearTimeout(r), e(t);\n            }).catch(function (t) {\n              void 0 !== r && clearTimeout(r), n(t);\n            });\n          });\n        if (0 !== e) {\n          var o = new Promise(function (n, o) {\n            r = setTimeout(o, e, new Error(\"Fetch for '\".concat(t.url, \"' timed out\")));\n          });\n          return Promise.race([n, o]);\n        }\n        return n;\n      }\n      function o(t) {\n        try {\n          return JSON.stringify(t);\n        } catch (e) {\n          return \"Unable to serialize object of type \".concat(typeof t);\n        }\n      }\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.Timespan = e.toJson = e.fetchWithTimeout = void 0, e.fetchWithTimeout = n, e.toJson = o;\n      var i = function () {\n        function t() {\n          this.start = Date.now();\n        }\n        return Object.defineProperty(t.prototype, \"duration\", {\n          get: function () {\n            return Date.now() - this.start;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"startTime\", {\n          get: function () {\n            return this.start;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), t.prototype.reset = function () {\n          this.start = Date.now();\n        }, t;\n      }();\n      e.Timespan = i;\n    }, function (t, e, r) {\n      function n(t, e, r) {\n        return new h(t, e, r);\n      }\n      var o = this && this.__extends || function () {\n          var t = function (e, r) {\n            return (t = Object.setPrototypeOf || {\n              __proto__: []\n            } instanceof Array && function (t, e) {\n              t.__proto__ = e;\n            } || function (t, e) {\n              for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n            })(e, r);\n          };\n          return function (e, r) {\n            function n() {\n              this.constructor = e;\n            }\n            if (\"function\" != typeof r && null !== r) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n            t(e, r), e.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n());\n          };\n        }(),\n        i = this && this.__assign || function () {\n          return i = Object.assign || function (t) {\n            for (var e, r = 1, n = arguments.length; r < n; r++) {\n              e = arguments[r];\n              for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);\n            }\n            return t;\n          }, i.apply(this, arguments);\n        },\n        s = this && this.__awaiter || function (t, e, r, n) {\n          function o(t) {\n            return t instanceof r ? t : new r(function (e) {\n              e(t);\n            });\n          }\n          return new (r || (r = Promise))(function (r, i) {\n            function s(t) {\n              try {\n                c(n.next(t));\n              } catch (t) {\n                i(t);\n              }\n            }\n            function a(t) {\n              try {\n                c(n.throw(t));\n              } catch (t) {\n                i(t);\n              }\n            }\n            function c(t) {\n              t.done ? r(t.value) : o(t.value).then(s, a);\n            }\n            c((n = n.apply(t, e || [])).next());\n          });\n        },\n        a = this && this.__generator || function (t, e) {\n          function r(t) {\n            return function (e) {\n              return n([t, e]);\n            };\n          }\n          function n(r) {\n            if (o) throw new TypeError(\"Generator is already executing.\");\n            for (; a && (a = 0, r[0] && (c = 0)), c;) try {\n              if (o = 1, i && (s = 2 & r[0] ? i.return : r[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, r[1])).done) return s;\n              switch (i = 0, s && (r = [2 & r[0], s.value]), r[0]) {\n                case 0:\n                case 1:\n                  s = r;\n                  break;\n                case 4:\n                  return c.label++, {\n                    value: r[1],\n                    done: !1\n                  };\n                case 5:\n                  c.label++, i = r[1], r = [0];\n                  continue;\n                case 7:\n                  r = c.ops.pop(), c.trys.pop();\n                  continue;\n                default:\n                  if (s = c.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === r[0] || 2 === r[0])) {\n                    c = 0;\n                    continue;\n                  }\n                  if (3 === r[0] && (!s || r[1] > s[0] && r[1] < s[3])) {\n                    c.label = r[1];\n                    break;\n                  }\n                  if (6 === r[0] && c.label < s[1]) {\n                    c.label = s[1], s = r;\n                    break;\n                  }\n                  if (s && c.label < s[2]) {\n                    c.label = s[2], c.ops.push(r);\n                    break;\n                  }\n                  s[2] && c.ops.pop(), c.trys.pop();\n                  continue;\n              }\n              r = e.call(t, c);\n            } catch (t) {\n              r = [6, t], i = 0;\n            } finally {\n              o = s = 0;\n            }\n            if (5 & r[0]) throw r[1];\n            return {\n              value: r[0] ? r[1] : void 0,\n              done: !0\n            };\n          }\n          var o,\n            i,\n            s,\n            a,\n            c = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return a = {\n            next: r(0),\n            throw: r(1),\n            return: r(2)\n          }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n            return this;\n          }), a;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.createRegistrarClient = e.RegistrarClient = void 0;\n      var c = r(0),\n        u = [\"skype\", \"aad\", \"cae\"],\n        l = function (t) {\n          function e(e) {\n            var r = t.call(this, e) || this;\n            return r.name = \"CancelationError\", r;\n          }\n          return o(e, t), e;\n        }(Error),\n        f = function () {\n          function t(e, r, n) {\n            this.logger = e, this.maxBackoffInMs = r, this.initialDelay = n, this.backoffCount = 0, this.id = ++t.idCounter;\n          }\n          return t.prototype.delay = function (t) {\n            var e = this;\n            if (void 0 !== this.timerHandle) throw new Error(\"Retry sequence logical failure\");\n            if (-1 === this.backoffCount) return new Promise(function (t, e) {\n              e(new l(\"Cancelled\"));\n            });\n            var r = this.calculateNextBackoffMs();\n            return this.backoffCount++, this.logger.info(\"[RegistrarClient] Backing off \".concat(t, \" for \").concat(r, \" milliseconds with ID \").concat(this.id)), new Promise(function (n, o) {\n              e.cancelFunc = o, e.timerHandle = setTimeout(function () {\n                e.logger.info(\"[RegistrarClient] Back off for \".concat(t, \" with ID \").concat(e.id, \" complete\")), e.timerHandle = void 0, n();\n              }, r);\n            });\n          }, t.prototype.cancel = function () {\n            void 0 !== this.timerHandle && (this.logger.debug(\"Resetting back off\"), clearTimeout(this.timerHandle), void 0 !== this.cancelFunc && this.cancelFunc(new l(\"Cancelled\"))), this.backoffCount = -1;\n          }, t.prototype.calculateNextBackoffMs = function () {\n            var t = 1 + .4 * (Math.random() - .5),\n              e = this.initialDelay * Math.pow(2, this.backoffCount) * t;\n            return e = Math.round(e), Math.min(this.maxBackoffInMs, e);\n          }, t.idCounter = 0, t;\n        }(),\n        h = function () {\n          function t(t, e, r) {\n            var n;\n            this.logger = t, this.tokenProvider = e, this.options = r, this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN = 15, this.DEFAULT_MAX_BACKOFF_TIME_IN_MS = 3e5, this.backoffs = {}, this.maxBackOffTime = this.options.maxRetryDelayMs > 0 ? this.options.maxRetryDelayMs : this.DEFAULT_MAX_BACKOFF_TIME_IN_MS, this.maxRetriesForGetToken = void 0 === r.maxRetriesForGetToken || null === r.maxRetriesForGetToken ? this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN : r.maxRetriesForGetToken, this.proxyUrlRewrite = null !== (n = r.proxyUrlRewrite) && void 0 !== n ? n : function (t) {\n              return t;\n            };\n          }\n          return t.prototype.setTelemetryLogger = function (t) {\n            this.eventLogger = t;\n          }, t.prototype.register = function (t, e) {\n            return s(this, void 0, void 0, function () {\n              return a(this, function (r) {\n                switch (r.label) {\n                  case 0:\n                    return [4, this.performRegistration(t, e, \"pr_set_registration\")];\n                  case 1:\n                    return r.sent(), this.cachedRegistrationParams = [t, e], [2];\n                }\n              });\n            });\n          }, t.prototype.unregister = function () {\n            return s(this, void 0, void 0, function () {\n              var t;\n              return a(this, function (e) {\n                switch (e.label) {\n                  case 0:\n                    return this.logger.info(\"[RegistrarClient] sending unregister request\"), t = new Request(this.proxyUrlRewrite(\"\".concat(this.options.registrarUrl, \"/\").concat(this.options.registrationId)), {\n                      method: \"DELETE\",\n                      mode: \"cors\",\n                      headers: new Headers(i(i({}, this.options.extraRegistrationHeaders), {\n                        accept: \"application/json, text/javascript\"\n                      }))\n                    }), [4, this.callRegistrar(t, \"pr_delete_registration\")];\n                  case 1:\n                    return e.sent(), [2];\n                }\n              });\n            });\n          }, t.prototype.cancelPendingRequests = function () {\n            var t = this;\n            Object.keys(this.backoffs).forEach(function (e) {\n              t.backoffs[e].cancel();\n            }), this.backoffs = {};\n          }, t.prototype.resendRegistration = function () {\n            return s(this, void 0, void 0, function () {\n              return a(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    if (!this.cachedRegistrationParams) throw new Error(\"Re-registration failed because there is no registration parameters cached\");\n                    return [4, this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], \"pr_resend_registration\")];\n                  case 1:\n                    return t.sent(), [2];\n                }\n              });\n            });\n          }, t.prototype.performRegistration = function (t, e, r) {\n            return s(this, void 0, void 0, function () {\n              var n, o;\n              return a(this, function (s) {\n                switch (s.label) {\n                  case 0:\n                    return this.logger.info(\"[RegistrarClient] Sending register request\"), n = {\n                      clientDescription: t,\n                      registrationId: this.options.registrationId,\n                      nodeId: \"\",\n                      transports: e\n                    }, o = new Request(this.proxyUrlRewrite(this.options.registrarUrl), {\n                      method: \"POST\",\n                      mode: \"cors\",\n                      headers: new Headers(i(i({}, this.options.extraRegistrationHeaders), {\n                        \"content-type\": \"application/json\",\n                        accept: \"application/json, text/javascript\"\n                      })),\n                      body: (0, c.toJson)(n)\n                    }), [4, this.callRegistrar(o, r)];\n                  case 1:\n                    return s.sent(), [2];\n                }\n              });\n            });\n          }, t.prototype.startBackoff = function () {\n            var t = new f(this.logger, this.maxBackOffTime, this.options.initialRetryDelayMs);\n            return this.backoffs[t.id] = t, t;\n          }, t.prototype.stopBackoff = function (t) {\n            t.cancel(), delete this.backoffs[t.id];\n          }, t.prototype.getToken = function (t) {\n            return s(this, void 0, void 0, function () {\n              var e, r, n, o, i, s, c;\n              return a(this, function (a) {\n                switch (a.label) {\n                  case 0:\n                    e = this.startBackoff(), r = 0, a.label = 1;\n                  case 1:\n                    return a.trys.push([1, 3,, 8]), this.logger.info(\"[RegistrarClient] Asking for a new token\"), [4, this.tokenProvider({\n                      needFresh: !0,\n                      supportedTokenTypes: u,\n                      wwwAuthenticateHeader: t,\n                      purpose: \"registrar\"\n                    })];\n                  case 2:\n                    return n = a.sent(), this.stopBackoff(e), [2, n];\n                  case 3:\n                    o = a.sent(), a.label = 4;\n                  case 4:\n                    return a.trys.push([4, 6,, 7]), (r++, i = JSON.stringify(o), r > this.maxRetriesForGetToken) ? (s = \"[RegistrarClient] getToken retry limit hit. Will not retry now. Error: \".concat(i), this.logger.error(s), this.stopBackoff(e), [2, Promise.reject(s)]) : (this.logger.warn(\"[RegistrarClient] Retrying for a new token. Retry Count: \".concat(r, \" Error: \").concat(i)), [4, e.delay(\"Fetching a new token\")]);\n                  case 5:\n                    return a.sent(), [3, 8];\n                  case 6:\n                    throw c = a.sent(), this.stopBackoff(e), c;\n                  case 7:\n                    return [3, 8];\n                  case 8:\n                    return [3, 1];\n                  case 9:\n                    return [2];\n                }\n              });\n            });\n          }, t.prototype.callRegistrar = function (t, e) {\n            var r, n, o;\n            return s(this, void 0, void 0, function () {\n              var i, s, l, f, h, p, d, g, y, v, w, k, m, b, R, _;\n              return a(this, function (a) {\n                switch (a.label) {\n                  case 0:\n                    return i = this.startBackoff(), [4, this.tokenProvider({\n                      needFresh: !1,\n                      supportedTokenTypes: u,\n                      wwwAuthenticateHeader: void 0,\n                      purpose: \"registrar\"\n                    })];\n                  case 1:\n                    s = a.sent(), this.setTokenHeader(t, s), l = new c.Timespan(), f = 0, a.label = 2;\n                  case 2:\n                    h = void 0, a.label = 3;\n                  case 3:\n                    return a.trys.push([3, 10, 15, 16]), p = t.clone(), [4, (0, c.fetchWithTimeout)(p, this.options.requestTimeoutMs)];\n                  case 4:\n                    return h = a.sent(), 401 !== h.status ? [3, 8] : ++f > this.maxRetriesForGetToken ? (d = \"[RegistrarClient] getSkypeToken retry limit hit. Will not retry now. Request '\".concat(t.url, \"' failed with \").concat(h.status, \" \").concat(h.statusText), this.logger.error(d), this.stopBackoff(i), [2, Promise.reject(d)]) : (this.logger.warn(\"[RegistrarClient] Retry Count \".concat(f, \". Request '\").concat(t.url, \"' failed with \").concat(h.status, \" \").concat(h.statusText)), g = null !== (n = null === (r = h.headers) || void 0 === r ? void 0 : r.get(\"www-authenticate\")) && void 0 !== n ? n : void 0, y = this.setTokenHeader, v = [t], [4, this.getToken(g)]);\n                  case 5:\n                    return y.apply(this, v.concat([a.sent()])), f > 1 ? [4, i.delay(\"Registrar call retry after 401\")] : [3, 7];\n                  case 6:\n                    a.sent(), a.label = 7;\n                  case 7:\n                    return [3, 22];\n                  case 8:\n                    if (h.status >= 500 && h.status < 600) throw new Error(\"Fetch for '\".concat(t.url, \"' failed with \").concat(h.status, \" \").concat(h.statusText));\n                    a.label = 9;\n                  case 9:\n                    return [3, 16];\n                  case 10:\n                    w = a.sent(), this.logger.error(\"[RegistrarClient] Request failed with \".concat(w)), a.label = 11;\n                  case 11:\n                    return a.trys.push([11, 13,, 14]), [4, i.delay(\"Registrar call retry\")];\n                  case 12:\n                    return a.sent(), [3, 22];\n                  case 13:\n                    throw k = a.sent(), this.logger.error(\"[RegistrarClient] Request cancelled\"), this.stopBackoff(i), k;\n                  case 14:\n                    return [3, 16];\n                  case 15:\n                    return this.sendTelemetryEvent(e, t, h, l), [7];\n                  case 16:\n                    return this.stopBackoff(i), h.ok ? [2, h] : [3, 17];\n                  case 17:\n                    m = void 0, a.label = 18;\n                  case 18:\n                    return a.trys.push([18, 20,, 21]), R = (b = JSON).stringify, [4, h.json()];\n                  case 19:\n                    return m = R.apply(b, [a.sent()]), [3, 21];\n                  case 20:\n                    return a.sent(), m = \"no details\", [3, 21];\n                  case 21:\n                    throw _ = \"Fetch for '\".concat(t.url, \"' failed with \").concat(h.status, \" \").concat(h.statusText, \" (\").concat(m, \", MS-CV: \").concat(null === (o = h.headers) || void 0 === o ? void 0 : o.get(\"MS-CV\"), \")\"), this.logger.error(\"[RegistrarClient] \".concat(_)), new Error(_);\n                  case 22:\n                    return [3, 2];\n                  case 23:\n                    return [2];\n                }\n              });\n            });\n          }, t.prototype.setTokenHeader = function (t, e) {\n            switch (t.headers.delete(\"X-Skypetoken\"), t.headers.delete(\"Authorization\"), t.headers.delete(\"X-MS-Migration\"), e.tokenType.toLowerCase()) {\n              case \"skype\":\n                t.headers.set(\"X-Skypetoken\", e.token);\n                break;\n              case \"aad\":\n              case \"cae\":\n                t.headers.set(\"Authorization\", \"Bearer \".concat(e.token));\n                break;\n              default:\n                throw new Error(\"unsupported token type: \".concat(e.tokenType));\n            }\n            !1 === this.options.usingLegacyTokenApi && t.headers.set(\"X-MS-Migration\", \"True\");\n          }, t.prototype.sendTelemetryEvent = function (t, e, r, n) {\n            if (void 0 !== this.eventLogger) {\n              var o = {\n                name: t,\n                properties: {\n                  url: {\n                    value: e.url\n                  },\n                  result_code: {\n                    value: void 0 !== r ? r.status : 0\n                  },\n                  begin_timestamp: {\n                    value: n.startTime\n                  },\n                  elapsed: {\n                    value: n.duration\n                  }\n                }\n              };\n              this.eventLogger.logEvent(o);\n            }\n          }, t;\n        }();\n      e.RegistrarClient = h, e.createRegistrarClient = n;\n    }]);\n  });\n});\nunwrapExports(tsregistrar);\nvar tstrouter = createCommonjsModule(function (module, exports) {\n  !function (t, e) {\n    module.exports = e(tsregistrar);\n  }(commonjsGlobal, function (t) {\n    return function (t) {\n      function e(o) {\n        if (n[o]) return n[o].exports;\n        var i = n[o] = {\n          i: o,\n          l: !1,\n          exports: {}\n        };\n        return t[o].call(i.exports, i, i.exports, e), i.l = !0, i.exports;\n      }\n      var n = {};\n      return e.m = t, e.c = n, e.i = function (t) {\n        return t;\n      }, e.d = function (t, n, o) {\n        e.o(t, n) || Object.defineProperty(t, n, {\n          configurable: !1,\n          enumerable: !0,\n          get: o\n        });\n      }, e.n = function (t) {\n        var n = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return e.d(n, \"a\", n), n;\n      }, e.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, e.p = \"\", e(e.s = 20);\n    }([function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.Logger = void 0;\n      var o = function () {\n        function t(t, e) {\n          this.name = t, this.logger = e;\n        }\n        return t.prototype.debug = function (t) {\n          this.logger.debug(\"[\".concat(this.name, \"] \").concat(t));\n        }, t.prototype.info = function (t) {\n          this.logger.info(\"[\".concat(this.name, \"] \").concat(t));\n        }, t.prototype.warn = function (t) {\n          this.logger.warn(\"[\".concat(this.name, \"] \").concat(t));\n        }, t.prototype.error = function (t) {\n          this.logger.error(\"[\".concat(this.name, \"] \").concat(t));\n        }, t;\n      }();\n      e.Logger = o;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.USER_AUTHENTICATE_EVENT_NAME = e.SUPPORTED_TOKEN_TYPES = e.FAILED_MESSAGE_ACK = e.UNHANDLED_MESSAGE_ACK = e.HANDLED_MESSAGE_ACK = e.CLIENT_VERSION = e.constants = void 0, e.constants = {\n        TROUTER_INIT: \"trouterinit\",\n        TROUTER_READY_EVENT: \"trouterReadyEvent\",\n        TROUTER_READY_TIMEOUT: \"trouterReadyTimeout\",\n        TROUTER_TOKEN_REQUEST: \"trouterTokenRequest\",\n        TROUTER_TOKEN_GET_SUCCEEDED: \"trouterTokenGetSucceeded\",\n        TROUTER_TOKEN_GET_FAILED: \"trouterTokenGetFailed\",\n        TROUTER_RECONNECTING: \"trouterReconnecting\",\n        RENEWAL: \"renewal\",\n        NEW_CONNECTION: \"newConnection\",\n        ENDPOINT_REGISTRATION_FAILED: \"endpointRegistrationFailed\"\n      }, e.CLIENT_VERSION = \"2024.14.01.55\", e.HANDLED_MESSAGE_ACK = 200, e.UNHANDLED_MESSAGE_ACK = 404, e.FAILED_MESSAGE_ACK = 500, e.SUPPORTED_TOKEN_TYPES = [\"skype\", \"aad\", \"cae\"], e.USER_AUTHENTICATE_EVENT_NAME = \"user.authenticate\";\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterState = e.UserActivityState = void 0;\n      var o;\n      !function (t) {\n        t[t.Unknown = 0] = \"Unknown\", t[t.Active = 1] = \"Active\", t[t.Inactive = 2] = \"Inactive\";\n      }(o || (e.UserActivityState = o = {}));\n      var i;\n      !function (t) {\n        t[t.Unknown = 0] = \"Unknown\", t[t.Connected = 2] = \"Connected\", t[t.Disconnected = 3] = \"Disconnected\", t[t.Switching = 9] = \"Switching\";\n      }(i || (e.TrouterState = i = {}));\n    }, function (t, e, n) {\n      function o(t) {\n        try {\n          return JSON.stringify(t);\n        } catch (e) {\n          return \"Unable to serialize object of type \".concat(typeof t);\n        }\n      }\n      function i(t) {\n        var e = Math.round(new Date().getTime() / 1e3);\n        return void 0 !== t && t > e ? t - e : 0;\n      }\n      function r(t) {\n        return Math.round(new Date().getTime() / 1e3) + t;\n      }\n      function s(t, e) {\n        return c(this, void 0, void 0, function () {\n          var n, o, i;\n          return a(this, function (r) {\n            return o = new Promise(function (e, o) {\n              fetch(t).then(function (t) {\n                clearTimeout(n), e(t);\n              }).catch(function (t) {\n                clearTimeout(n), o(t);\n              });\n            }), 0 !== e ? (i = new Promise(function (o, i) {\n              var r = new URL(t.url),\n                s = new Error(\"\".concat(t.method, \" \").concat(r.origin).concat(r.pathname, \" timed out\"));\n              n = setTimeout(i, e, s);\n            }), [2, Promise.race([o, i])]) : [2, o];\n          });\n        });\n      }\n      var c = this && this.__awaiter || function (t, e, n, o) {\n          function i(t) {\n            return t instanceof n ? t : new n(function (e) {\n              e(t);\n            });\n          }\n          return new (n || (n = Promise))(function (n, r) {\n            function s(t) {\n              try {\n                a(o.next(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function c(t) {\n              try {\n                a(o.throw(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function a(t) {\n              t.done ? n(t.value) : i(t.value).then(s, c);\n            }\n            a((o = o.apply(t, e || [])).next());\n          });\n        },\n        a = this && this.__generator || function (t, e) {\n          function n(t) {\n            return function (e) {\n              return o([t, e]);\n            };\n          }\n          function o(n) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; c && (c = 0, n[0] && (a = 0)), a;) try {\n              if (i = 1, r && (s = 2 & n[0] ? r.return : n[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, n[1])).done) return s;\n              switch (r = 0, s && (n = [2 & n[0], s.value]), n[0]) {\n                case 0:\n                case 1:\n                  s = n;\n                  break;\n                case 4:\n                  return a.label++, {\n                    value: n[1],\n                    done: !1\n                  };\n                case 5:\n                  a.label++, r = n[1], n = [0];\n                  continue;\n                case 7:\n                  n = a.ops.pop(), a.trys.pop();\n                  continue;\n                default:\n                  if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {\n                    a = 0;\n                    continue;\n                  }\n                  if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {\n                    a.label = n[1];\n                    break;\n                  }\n                  if (6 === n[0] && a.label < s[1]) {\n                    a.label = s[1], s = n;\n                    break;\n                  }\n                  if (s && a.label < s[2]) {\n                    a.label = s[2], a.ops.push(n);\n                    break;\n                  }\n                  s[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n              n = e.call(t, a);\n            } catch (t) {\n              n = [6, t], r = 0;\n            } finally {\n              i = s = 0;\n            }\n            if (5 & n[0]) throw n[1];\n            return {\n              value: n[0] ? n[1] : void 0,\n              done: !0\n            };\n          }\n          var i,\n            r,\n            s,\n            c,\n            a = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return c = {\n            next: n(0),\n            throw: n(1),\n            return: n(2)\n          }, \"function\" == typeof Symbol && (c[Symbol.iterator] = function () {\n            return this;\n          }), c;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.Timespan = e.CorrelationVector = e.fetchWithTimeout = e.calculateExpireTsInSec = e.calculateTtlInSec = e.toJson = void 0, e.toJson = o, e.calculateTtlInSec = i, e.calculateExpireTsInSec = r, e.fetchWithTimeout = s;\n      var u = function () {\n        function t(t) {\n          this.base = void 0 !== t ? t : this.createCorrelationVectorBase(), this.extension = 0;\n        }\n        return t.extend = function (e) {\n          return new t(e);\n        }, t.prototype.increase = function () {\n          this.extension++;\n        }, t.prototype.value = function () {\n          return \"\".concat(this.base, \".\").concat(this.extension);\n        }, t.prototype.createCorrelationVectorBase = function () {\n          for (var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+\", e = \"AQgw\", n = \"\", o = 0; o < 21; o++) n += t.charAt(Math.floor(Math.random() * t.length));\n          return n += e.charAt(Math.floor(Math.random() * e.length));\n        }, t;\n      }();\n      e.CorrelationVector = u;\n      var h = function () {\n        function t() {\n          this.start = Date.now();\n        }\n        return Object.defineProperty(t.prototype, \"duration\", {\n          get: function () {\n            return Date.now() - this.start;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"startTime\", {\n          get: function () {\n            return this.start;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), t.prototype.reset = function () {\n          this.start = Date.now();\n        }, t;\n      }();\n      e.Timespan = h;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterManagerState = e.UserActivityEventReason = e.ServerState = void 0;\n      var o = n(3),\n        i = function () {\n          function t(t, e, n, o, i, r, s) {\n            this.connectionId = t, this.connectedClientId = e, this.domId = n, this.unsecureUrl = o, this.url = i, this.c2cUrlBase = r, this.expirationTsSec = s;\n          }\n          return t.prototype.getRemainingTtlInSec = function () {\n            return (0, o.calculateTtlInSec)(this.expirationTsSec);\n          }, t;\n        }();\n      e.ServerState = i;\n      var r;\n      !function (t) {\n        t[t.Unknown = 0] = \"Unknown\", t[t.Modified = 1] = \"Modified\", t[t.Snapshot = 2] = \"Snapshot\", t[t.Connected = 3] = \"Connected\";\n      }(r || (e.UserActivityEventReason = r = {}));\n      var s;\n      !function (t) {\n        t[t.Unknown = 0] = \"Unknown\", t[t.Connected = 2] = \"Connected\", t[t.Disconnected = 3] = \"Disconnected\", t[t.Switching = 9] = \"Switching\", t[t.TerminalError = 10] = \"TerminalError\";\n      }(s || (e.TrouterManagerState = s = {}));\n    }, function (t, e, n) {\n      function o(t, e) {\n        return \"skype\" === t && \"1\" !== i(null === e || void 0 === e ? void 0 : e.scae) ? \"v4a\" : \"v4c\";\n      }\n      function i(t) {\n        return \"string\" == typeof t ? t : \"number\" == typeof t ? t.toString() : void 0;\n      }\n      function r(t, e) {\n        return \"v4c-websocket-failure\" === (null === e || void 0 === e ? void 0 : e.kind) ? \"v4a\" : t;\n      }\n      function s(t) {\n        return Object.prototype.hasOwnProperty.call(t, \"connectparams\");\n      }\n      function c(t, e) {\n        return \"v4a\" === e ? t.replace(/\\/v4\\/c\\b/, \"/v4/a\").replace(\"wss://\", \"https://\").replace(\"ws://\", \"http://\") : t.replace(/\\/v4\\/a\\b/, \"/v4/c\").replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n      }\n      function a(t) {\n        if (void 0 !== t) return d(d({}, t), {\n          reconnectUrl: void 0,\n          serviceUrl: void 0\n        });\n      }\n      function u(t) {\n        return \"string\" == typeof t ? parseInt(t, 10) : t;\n      }\n      function h(t) {\n        if (\"redirect\" === (null === t || void 0 === t ? void 0 : t.kind) && void 0 !== t.host) {\n          var e = t.host;\n          return e.endsWith(\"/\") && (e = e.substring(0, e.length - 1)), e.endsWith(\"/v4/c\") || e.endsWith(\"/v4/a\") || (e += \"/v4/c\"), e;\n        }\n      }\n      var d = this && this.__assign || function () {\n        return d = Object.assign || function (t) {\n          for (var e, n = 1, o = arguments.length; n < o; n++) {\n            e = arguments[n];\n            for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);\n          }\n          return t;\n        }, d.apply(this, arguments);\n      };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.redirectUrlIfPresent = e.ensureNumber = e.reconnectParamsWithoutUrls = e.adaptUrl = e.isV4ConnectEvent = e.usedProtocolAfterFallback = e.usedProtocol = void 0, e.usedProtocol = o, e.usedProtocolAfterFallback = r, e.isV4ConnectEvent = s, e.adaptUrl = c, e.reconnectParamsWithoutUrls = a, e.ensureNumber = u, e.redirectUrlIfPresent = h;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterFsm = e.State = void 0;\n      var o,\n        i = n(4),\n        r = n(0),\n        s = n(5);\n      !function (t) {\n        t[t.Initial = 0] = \"Initial\", t[t.RetrievingToken = 1] = \"RetrievingToken\", t[t.Allocating = 2] = \"Allocating\", t[t.Handshaking = 3] = \"Handshaking\", t[t.Connecting = 4] = \"Connecting\", t[t.AnonymousConnecting = 5] = \"AnonymousConnecting\", t[t.WebsocketAuthenticating = 6] = \"WebsocketAuthenticating\", t[t.Connected = 7] = \"Connected\", t[t.Unregistering = 8] = \"Unregistering\", t[t.TerminalError = 9] = \"TerminalError\";\n      }(o || (e.State = o = {}));\n      var c;\n      !function (t) {\n        t[t.Initial = 0] = \"Initial\", t[t.Registering = 1] = \"Registering\", t[t.RegisteringButResendPending = 2] = \"RegisteringButResendPending\", t[t.Retrying = 3] = \"Retrying\", t[t.Registered = 4] = \"Registered\", t[t.RegistrationDisabled = 5] = \"RegistrationDisabled\";\n      }(c || (c = {}));\n      var a = function () {\n        function t(t, e, n, i) {\n          this.worker = e, this.incallModeEnabled = n, this.protocolSelector = i, this.state = o.Initial, this.autoReconnect = !0, this.logger = new r.Logger(\"ConnectionFsm\", t), this.registrationState = c.Initial;\n        }\n        return t.prototype.getState = function () {\n          return this.state;\n        }, t.prototype.isActive = function () {\n          return this.state === o.Allocating || this.state === o.Connected || this.state === o.Handshaking || this.state === o.Connecting || this.state === o.RetrievingToken || this.state === o.AnonymousConnecting || this.state === o.WebsocketAuthenticating;\n        }, t.prototype.isConnecting = function () {\n          return this.state === o.Allocating || this.state === o.Handshaking || this.state === o.Connecting || this.state === o.AnonymousConnecting;\n        }, t.prototype.start = function () {\n          return this.state === o.Initial ? (this.setState(o.RetrievingToken), this.worker.getToken(!0, !1, void 0), !0) : (this.showIgnored(\"start\"), !1);\n        }, t.prototype.stop = function (t, e) {\n          t && (this.registrationState = c.Initial), this.worker.isIncallMode() && this.worker.exitIncallMode(), this.worker.resetTokenBackoff(), this.worker.cancelPendingRegistrationRequests(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearSentEventTimers(), this.worker.stopRegistrationTimer(), this.worker.stopSocketIo(), this.state === o.Connected && this.worker.sendDisconnectTelemetryEvent(\"connection stopped\"), this.registrationState !== c.Registered && this.registrationState !== c.Registering && this.registrationState !== c.RegisteringButResendPending || this.state === o.Unregistering ? e ? (this.setState(o.TerminalError), this.worker.dispatchTerminalError()) : (this.setState(o.Initial), this.worker.dispatchDisconnected()) : (this.registrationState = c.Initial, this.setState(o.Unregistering), this.worker.sendUnregisterRequest());\n        }, t.prototype.onTokenReceived = function (t, e, n) {\n          this.state === o.RetrievingToken ? \"v4c\" === (0, s.usedProtocolAfterFallback)(this.protocolSelector(t.tokenType, n), e) ? (this.setState(o.AnonymousConnecting), this.worker.startConnectionTimer(), this.worker.connectV4c(t, e)) : (this.setState(o.Allocating), this.worker.startConnectionTimer(), this.worker.sendAllocateRequest(t)) : this.showIgnored(\"onTokenReceived\");\n        }, t.prototype.checkConnection = function (t) {\n          t && this.onPingInterval();\n        }, t.prototype.onAllocationSucceed = function (t) {\n          return this.state === o.Allocating && this.registrationState === c.Registered && this.worker.dispatchUnregistered(), this.state === o.Allocating ? (this.setState(o.Handshaking), this.registrationState = c.Initial, this.worker.startSocketIo(t), !0) : (this.showIgnored(\"onAllocationSucceed\"), !1);\n        }, t.prototype.onAllocationFailed = function (t, e) {\n          this.state === o.Allocating ? this.cleanUpAndInitiateReconnect({\n            backoff: !0,\n            allowCachedToken: !t,\n            claimsChallenge: e\n          }) : this.showIgnored(\"onAllocationFailed\");\n        }, t.prototype.onV4cException = function () {\n          this.state !== o.AnonymousConnecting && this.state !== o.WebsocketAuthenticating || (this.logger.error(\"v4c exception, falling back to longpoll\"), this.cleanUpAndInitiateReconnect({\n            backoff: !0,\n            allowCachedToken: !0,\n            fallbackReason: {\n              kind: \"v4c-websocket-failure\"\n            }\n          }));\n        }, t.prototype.onConnectingTimeout = function () {\n          this.state === o.Allocating || this.state === o.Connecting || this.state === o.Handshaking || this.state === o.AnonymousConnecting || this.state === o.WebsocketAuthenticating ? this.cleanUpAndInitiateReconnect({\n            backoff: !1,\n            allowCachedToken: !0\n          }) : this.showIgnored(\"onConnectingTimeout\");\n        }, t.prototype.onConnecting = function () {\n          this.state === o.Handshaking ? this.setState(o.Connecting) : this.showIgnored(\"onConnecting\");\n        }, t.prototype.onSocketConnect = function (t) {\n          this.state === o.AnonymousConnecting ? (this.setState(o.WebsocketAuthenticating), this.worker.sendV4cAuthenticationEvent(t)) : this.showIgnored(\"onSocketConnect\");\n        }, t.prototype.onConnectingFailed = function () {\n          this.state === o.Connecting ? this.onConnectingTimeout() : this.state === o.Handshaking ? (this.logger.error(\"Unexpected error in Socket.io - no valid transports\"), this.onConnectingTimeout()) : this.state === o.AnonymousConnecting || this.state === o.WebsocketAuthenticating ? (this.logger.info(\"/v4/c falling back to longpoll\"), this.cleanUpAndInitiateReconnect({\n            backoff: !0,\n            allowCachedToken: !0,\n            fallbackReason: {\n              kind: \"v4c-websocket-failure\"\n            }\n          })) : this.showIgnored(\"onConnectingFailed\");\n        }, t.prototype.onSocketDisconnect = function (t) {\n          this.state === o.Handshaking || this.state === o.Connected || this.state === o.WebsocketAuthenticating ? (this.state === o.Connected && this.worker.sendDisconnectTelemetryEvent(null === t || void 0 === t ? void 0 : t.toTelemetryString()), this.state === o.WebsocketAuthenticating && this.worker.countDisconnectBeforeConnectionEstablishment(), \"skypetoken-deprecated\" === (null === t || void 0 === t ? void 0 : t.reason) ? (this.logger.error(\"Skypetoken deprecated response, not retrying any further\"), this.onTerminalError()) : this.cleanUpAndInitiateReconnect({\n            backoff: this.state !== o.Connected && \"dup\" !== (null === t || void 0 === t ? void 0 : t.reason),\n            allowCachedToken: \"unauthorized\" !== (null === t || void 0 === t ? void 0 : t.reason),\n            claimsChallenge: null === t || void 0 === t ? void 0 : t.claims\n          })) : this.showIgnored(\"onSocketDisconnect\");\n        }, t.prototype.onTrouterConnected = function () {\n          this.state === o.Connecting || this.state === o.WebsocketAuthenticating ? (this.setState(o.Connected), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.sendUserActivityState(i.UserActivityEventReason.Connected, !0), this.worker.startPingTimer(), this.worker.dispatchConnected(), this.worker.shouldSkipRegistration() ? (this.registrationState = c.RegistrationDisabled, this.worker.dispatchRegistered()) : (this.registrationState = c.Registering, this.worker.sendRegisterRequest())) : this.showIgnored(\"onTrouterConnected\");\n        }, t.prototype.onReconnectRequired = function (t, e, n) {\n          this.state === o.AnonymousConnecting || this.state === o.WebsocketAuthenticating ? void 0 === n || \"host\" !== n.target || void 0 === n.url || \"\" === n.url ? (this.logger.error(\"unexpected reconnect arguments: \".concat(null === n || void 0 === n ? void 0 : n.target, \" \").concat(null === n || void 0 === n ? void 0 : n.url, \", reconnecting without cache\")), this.cleanUpAndInitiateReconnect({\n            backoff: !0,\n            allowCachedToken: !0,\n            fallbackReason: {\n              kind: \"redirect-no-host\"\n            }\n          })) : this.cleanUpAndInitiateReconnect({\n            backoff: !0,\n            allowCachedToken: !0,\n            fallbackReason: {\n              kind: \"redirect\",\n              host: n.url\n            }\n          }) : this.worker.dispatchReconnectIsRequired(t, e);\n        }, t.prototype.disableAutoReconnect = function () {\n          this.autoReconnect = !1;\n        }, t.prototype.onDownstreamRequest = function (t) {\n          this.state === o.Connected ? (this.switchToIncallModeIfEnabled(), this.worker.dispatchDownstreamRequest(t)) : this.showIgnored(\"onDownstreamRequest\");\n        }, t.prototype.onTrouterMessageLost = function (t) {\n          this.state === o.Connected ? this.worker.dispatchTrouterMessageLost(t) : this.showIgnored(\"onTrouterMessageLost\");\n        }, t.prototype.onPingInterval = function () {\n          this.state === o.Connected ? this.worker.sendPingRequest() : this.showIgnored(\"onPingInterval\");\n        }, t.prototype.onPingResponseTimeout = function () {\n          this.onMissedResponse(\"onPingResponseTimeout\");\n        }, t.prototype.onPingResponse = function () {\n          this.state === o.Connected || this.showIgnored(\"onPingResponse\");\n        }, t.prototype.onRegistrationFailed = function () {\n          this.state === o.Connected && this.registrationState === c.Registering ? (this.worker.dispatchUnregistered(), this.registrationState = c.Retrying, this.worker.startRegistrationRetryTimer()) : this.state === o.Connected && this.registrationState === c.RegisteringButResendPending ? (this.registrationState = c.Registering, this.worker.sendRegisterRequest()) : this.showIgnored(\"onRegistrationFailed\");\n        }, t.prototype.onRetryRegistration = function () {\n          this.state === o.Connected && this.registrationState === c.Retrying ? (this.registrationState = c.Registering, this.worker.sendRegisterRequest()) : this.showIgnored(\"onRetryRegistration\");\n        }, t.prototype.onRegistrationSucceeded = function () {\n          this.state === o.Connected && this.registrationState === c.Registering ? (this.registrationState = c.Registered, this.worker.dispatchRegistered(), this.worker.startRegistrationTimer()) : this.state === o.Connected && this.registrationState === c.RegisteringButResendPending ? (this.registrationState = c.Registering, this.worker.sendRegisterRequest()) : this.showIgnored(\"onRegistrationSucceeded\");\n        }, t.prototype.onRegistrationNearExpiry = function () {\n          this.state === o.Connected && this.registrationState === c.Registered ? (this.registrationState = c.Registering, this.worker.sendRegisterRequest()) : this.showIgnored(\"onRegistrationNearExpiry\");\n        }, t.prototype.onUnregistrationDone = function () {\n          this.state === o.Unregistering ? (this.setState(o.Initial), this.worker.dispatchUnregistered(), this.worker.dispatchDisconnected()) : this.showIgnored(\"onUnregistrationDone\");\n        }, t.prototype.onResendRegistration = function () {\n          this.worker.dispatchUnregistered(), this.state === o.Connected && this.registrationState === c.Registered ? (this.registrationState = c.Registering, this.worker.stopRegistrationTimer(), this.worker.sendRegisterRequest()) : this.state === o.Connected && this.registrationState === c.Registering && (this.registrationState = c.RegisteringButResendPending);\n        }, t.prototype.onIncallModeTimer = function () {\n          this.worker.exitIncallMode(), this.state === o.Connected ? (this.worker.stopPingTimer(), this.worker.startPingTimer()) : this.showIgnored(\"onIncallModeTimer\");\n        }, t.prototype.onSetNewUserActivityState = function () {\n          this.worker.sendUserActivityState(i.UserActivityEventReason.Modified, this.state === o.Connected);\n        }, t.prototype.onActivityStateResponseTimeout = function () {\n          this.onMissedResponse(\"onActivityStateResponseTimeout\");\n        }, t.prototype.forceReconnect = function (t) {\n          this.state === o.Connected && this.worker.sendDisconnectTelemetryEvent(t), this.worker.resetTokenBackoff(), this.cleanUpAndInitiateReconnect({\n            backoff: !1,\n            allowCachedToken: !0\n          });\n        }, t.prototype.onTerminalError = function () {\n          this.logger.error(\"Cannot proceed, reached terminal state. Switching from state '\".concat(o[this.state], \"' to \").concat(o[o.TerminalError])), this.stop(!0, !0), this.setState(o.TerminalError);\n        }, t.prototype.onMissedResponse = function (t) {\n          this.state === o.Connected ? (this.worker.sendDisconnectTelemetryEvent(t), this.cleanUpAndInitiateReconnect({\n            backoff: !1,\n            allowCachedToken: !0\n          })) : this.showIgnored(t);\n        }, t.prototype.showIgnored = function (t) {\n          this.logger.debug(\"Ignoring event '\".concat(t, \"' in state '\").concat(o[this.state], \"'\"));\n        }, t.prototype.setState = function (t) {\n          if (this.logger.info(\"Switching from state '\".concat(o[this.state], \"' to state '\").concat(o[t], \"'\")), this.state === t) return void this.logger.error(\"Attempt to switch to the current state '\".concat(o[t], \"'\"));\n          this.state = t;\n        }, t.prototype.switchToIncallModeIfEnabled = function () {\n          this.incallModeEnabled && (this.worker.isIncallMode() || (this.worker.enterIncallMode(), this.worker.stopPingTimer(), this.worker.startPingTimer()), this.worker.restartIncallModeTimer());\n        }, t.prototype.cleanUpAndInitiateReconnect = function (t) {\n          if (!this.autoReconnect) return this.logger.info(\"Automatic reconnect is disabled, stopping this connection\"), void this.stop(!0);\n          this.worker.cancelPendingRegistrationRequests(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearSentEventTimers(), this.worker.stopRegistrationTimer(), this.worker.stopSocketIo(), this.setState(o.RetrievingToken), this.worker.dispatchReconnecting(), this.worker.getToken(t.allowCachedToken, t.backoff, t.claimsChallenge, t.fallbackReason);\n        }, t;\n      }();\n      e.TrouterFsm = a;\n    }, function (t, e, n) {\n      function o(t, e) {\n        var n = e ? void 0 : {\n          \"X-MS-Migration\": \"True\"\n        };\n        switch (t.tokenType.toLowerCase()) {\n          case \"skype\":\n            return c({\n              \"X-Skypetoken\": t.token\n            }, n);\n          case \"aad\":\n          case \"cae\":\n            return c({\n              Authorization: \"Bearer \".concat(t.token)\n            }, n);\n          default:\n            throw new Error(\"unsupported token type: \".concat(t.tokenType));\n        }\n      }\n      function i(t) {\n        return void 0 !== t && null !== t && \"function\" == typeof t.toString ? t.toString() : \"[\".concat(typeof t, \"]\");\n      }\n      function r(t) {\n        return \"object\" == typeof t && null !== t && void 0 !== t.stack ? (0, l.toJson)(t.stack) : '\"(no error.stack)\"';\n      }\n      function s(t) {\n        return \"object\" == typeof t && null !== t && \"string\" == typeof t.message ? t.message : \"(no error.message)\";\n      }\n      var c = this && this.__assign || function () {\n          return c = Object.assign || function (t) {\n            for (var e, n = 1, o = arguments.length; n < o; n++) {\n              e = arguments[n];\n              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);\n            }\n            return t;\n          }, c.apply(this, arguments);\n        },\n        a = this && this.__awaiter || function (t, e, n, o) {\n          function i(t) {\n            return t instanceof n ? t : new n(function (e) {\n              e(t);\n            });\n          }\n          return new (n || (n = Promise))(function (n, r) {\n            function s(t) {\n              try {\n                a(o.next(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function c(t) {\n              try {\n                a(o.throw(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function a(t) {\n              t.done ? n(t.value) : i(t.value).then(s, c);\n            }\n            a((o = o.apply(t, e || [])).next());\n          });\n        },\n        u = this && this.__generator || function (t, e) {\n          function n(t) {\n            return function (e) {\n              return o([t, e]);\n            };\n          }\n          function o(n) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; c && (c = 0, n[0] && (a = 0)), a;) try {\n              if (i = 1, r && (s = 2 & n[0] ? r.return : n[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, n[1])).done) return s;\n              switch (r = 0, s && (n = [2 & n[0], s.value]), n[0]) {\n                case 0:\n                case 1:\n                  s = n;\n                  break;\n                case 4:\n                  return a.label++, {\n                    value: n[1],\n                    done: !1\n                  };\n                case 5:\n                  a.label++, r = n[1], n = [0];\n                  continue;\n                case 7:\n                  n = a.ops.pop(), a.trys.pop();\n                  continue;\n                default:\n                  if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {\n                    a = 0;\n                    continue;\n                  }\n                  if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {\n                    a.label = n[1];\n                    break;\n                  }\n                  if (6 === n[0] && a.label < s[1]) {\n                    a.label = s[1], s = n;\n                    break;\n                  }\n                  if (s && a.label < s[2]) {\n                    a.label = s[2], a.ops.push(n);\n                    break;\n                  }\n                  s[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n              n = e.call(t, a);\n            } catch (t) {\n              n = [6, t], r = 0;\n            } finally {\n              i = s = 0;\n            }\n            if (5 & n[0]) throw n[1];\n            return {\n              value: n[0] ? n[1] : void 0,\n              done: !0\n            };\n          }\n          var i,\n            r,\n            s,\n            c,\n            a = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return c = {\n            next: n(0),\n            throw: n(1),\n            return: n(2)\n          }, \"function\" == typeof Symbol && (c[Symbol.iterator] = function () {\n            return this;\n          }), c;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterConnection = e.ReconnectReason = void 0;\n      var h,\n        d = n(21),\n        l = n(3),\n        p = n(15),\n        g = n(1),\n        f = n(16),\n        v = n(17),\n        m = n(2),\n        y = n(4),\n        T = n(0),\n        S = n(5),\n        k = n(6),\n        w = n(12),\n        b = function () {\n          function t() {\n            this.cv = g.CLIENT_VERSION, this.ua = \"\", this.hr = \"\", this.v = \"\";\n          }\n          return t;\n        }(),\n        R = function () {\n          function t() {\n            this[\"force new connection\"] = !0, this.reconnect = !1, this.query = \"\", this.ackTimeoutMs = 5e3;\n          }\n          return t.prototype.rewriteUrlForProxy = function (t) {\n            return t;\n          }, t;\n        }(),\n        C = \"MS-CV\",\n        E = function () {\n          function t(t, e) {\n            this.logger = e, this.cvCounter = 0;\n            var n = JSON.parse(t);\n            this.startTS = this.safeJsonNumber(n, \"startTS\", 0), this.url = this.safeJsonString(n, \"url\", \"\"), this.shortUrl = this.safeJsonString(n, \"shortUrl\", \"\"), this.body = this.safeJsonString(n, \"body\", \"\"), this.headers = this.safeJsonRecord(n, \"headers\", {}), this.id = this.safeJsonNumber(n, \"id\", -1), this.method = this.safeJsonString(n, \"method\", \"\"), this.replied = !1, this.timedout = !1, this.receivedCv = this.headers[C], this.updateCvHeader();\n          }\n          return Object.defineProperty(t.prototype, \"correlationVector\", {\n            get: function () {\n              return this.receivedCv ? \"\".concat(this.receivedCv, \".\").concat(this.cvCounter) : \"\";\n            },\n            enumerable: !1,\n            configurable: !0\n          }), t.prototype.on = function (t, e) {\n            \"data\" === t ? this.dataCallback = e : \"end\" === t && (\"function\" == typeof this.dataCallback && this.dataCallback(this.body), e());\n          }, t.prototype.incrementCorrelationVector = function () {\n            ++this.cvCounter, this.updateCvHeader();\n          }, t.prototype.updateCvHeader = function () {\n            var t = this.correlationVector;\n            t && (this.headers[C] = t);\n          }, t.prototype.safeJsonNumber = function (t, e, n) {\n            var o;\n            if (null !== t && void 0 !== t && Object.prototype.hasOwnProperty.call(t, e)) {\n              var i = t;\n              if (\"number\" == typeof i[e]) return i[e];\n              if (\"string\" == typeof i[e]) return parseFloat(i[e]);\n              null === (o = this.logger) || void 0 === o || o.warn(\"unexpected type of '\".concat(e, \"': \").concat(typeof i[e]));\n            }\n            return n;\n          }, t.prototype.safeJsonString = function (t, e, n) {\n            var o;\n            if (null !== t && void 0 !== t && Object.prototype.hasOwnProperty.call(t, e)) {\n              var i = t;\n              if (\"string\" == typeof i[e]) return i[e];\n              null === (o = this.logger) || void 0 === o || o.warn(\"unexpected type of '\".concat(e, \"': \").concat(typeof i[e]));\n            }\n            return n;\n          }, t.prototype.safeJsonRecord = function (t, e, n) {\n            var o;\n            if (null !== t && void 0 !== t && Object.prototype.hasOwnProperty.call(t, e)) {\n              var i = t;\n              if (\"object\" == typeof i[e]) return i[e];\n              null === (o = this.logger) || void 0 === o || o.warn(\"unexpected type of '\".concat(e, \"': \").concat(typeof i[e]));\n            }\n            return n;\n          }, t;\n        }(),\n        I = function () {\n          function t(t, e, n) {\n            this.request = t, this.responseData = e, this.sendResponse = n;\n          }\n          return t.prototype.writeHead = function (t, e) {\n            this.responseData.status = t, this.responseData.headers = e;\n          }, t.prototype.write = function (t) {\n            this.responseData.body += t;\n          }, t.prototype.end = function (t) {\n            return t && (this.responseData.body += t), this.sendResponse(this.request, this.responseData);\n          }, t;\n        }(),\n        A = function () {\n          function t(t) {\n            this.name = t, this.args = {}, this.timeoutTimerId = 0;\n          }\n          return t;\n        }();\n      !function (t) {\n        t[t.Configuration = 0] = \"Configuration\", t[t.ServerInitiated = 1] = \"ServerInitiated\";\n      }(h || (e.ReconnectReason = h = {}));\n      var U = function () {\n        function t(t, e, n, o, i, r, s, c) {\n          var a,\n            u = this;\n          this.options = e, this.manager = n, this.tokenProvider = o, this.usingLegacyTokenApi = i, this.protocolSelector = s, this.audienceSubscriptionState = c, this.WEBSOCKET_TRANSPORT_NAME = \"websocket\", this.XHR_POLLING_TRANSPORT_NAME = \"xhr-polling\", this.AUDIENCE_SUBSCRIPTION_RESULT_ERROR = \"Error\", this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED = \"Unsubscribed\", this.AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT = \"Timeout\", this.AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST = \"BadRequest\", this.AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX = /&audienceSubscriptionState=[^&]*|^audienceSubscriptionState=[^&]*&?/, this.connectionId = \"\", this.inIncallMode = !1, this.connectionAttempt = 0, this.connectedClientId = \"\", this.isNavigatorOnline = !0, this.onNavigatorOnlineStatusUpdateBound = this.onNavigatorOnlineStatusUpdate.bind(this), this.c2cUrlBase = \"\", this.connectingErrorsInRow = 0, this.unauthorizedErrorCount = 0, this.pendingSentEventTimers = {}, this.lastDisconnectReason = \"\", this.UNKNOWN_TRANSPORT = \"unknown_transport\", this.connectingErrorsThreshold = 3, this.pendingAudienceSubscription = void 0, this.logger = new T.Logger(\"Connection\", t), this.timeoutOptions = this.options.timeoutOptions, this.tokenBackoff = new v.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.clientID = Date.now(), \"undefined\" != typeof window && window.location && (this.domId = window.location.hostname);\n          var h = new b();\n          h.cv = g.CLIENT_VERSION, h.ua = \"\", (null === (a = this.options) || void 0 === a ? void 0 : a.clientInfo) && (h.ua = this.safeString(this.options.clientInfo.ua), h.v = this.safeString(this.options.clientInfo.v)), this.clientInfo = h, this.connectionTracker = new p.ConnectionTracker(t, this.clientID, this.clientInfo, function () {\n            return u.getServerState();\n          }, this.options.endpointId, this.options.clientCorrelationID, this.options.environment), this.applyConnectionTrackerOptions(e);\n          var l = this.options.incallModeTimeoutMs > 0;\n          if (this.fsm = new k.TrouterFsm(t, this, l, this.protocolSelector), e.registration) {\n            var f = {\n              registrarUrl: e.registration.registrarUrl,\n              proxyUrlRewrite: e.rewriteUrlForProxy,\n              registrationId: e.registration.registrationId,\n              requestTimeoutMs: e.timeoutOptions.fetchTimeoutMs,\n              initialRetryDelayMs: 1e3,\n              maxRetryDelayMs: e.timeoutOptions.maxBackoffMs,\n              usingLegacyTokenApi: this.usingLegacyTokenApi,\n              maxRetriesForGetToken: e.retryLimitOnTokenFetch,\n              extraRegistrationHeaders: e.extraConnectionHeaders\n            };\n            this.registrarClient = (0, d.createRegistrarClient)(t, this.tokenProvider, f);\n          }\n          this.userActivityState = r;\n        }\n        return t.prototype.start = function (t) {\n          this.logger.info(\"Starting\"), this.reconnectParams = t, \"undefined\" != typeof window && window.navigator && window.addEventListener ? (this.isNavigatorOnline = window.navigator.onLine, window.addEventListener(\"online\", this.onNavigatorOnlineStatusUpdateBound), window.addEventListener(\"offline\", this.onNavigatorOnlineStatusUpdateBound), this.logger.debug(\"Registered for browser online notifications - current state: \".concat(this.isNavigatorOnline))) : this.isNavigatorOnline = !0, this.fsm.start();\n        }, t.prototype.stop = function (t) {\n          this.logger.info(\"Stopping\"), \"undefined\" != typeof window && window.navigator && (window.removeEventListener(\"online\", this.onNavigatorOnlineStatusUpdateBound), window.removeEventListener(\"offline\", this.onNavigatorOnlineStatusUpdateBound)), this.fsm.stop(t), this.connectionTracker.close();\n        }, t.prototype.configure = function (t) {\n          var e = this.options.trouterUrl !== t.trouterUrl;\n          this.options = t, this.applyConnectionTrackerOptions(t), e && (this.logger.info(\"Configuration changed. Reconnection required.\"), this.fsm.onReconnectRequired(!1, h.Configuration));\n        }, t.prototype.checkConnection = function (t) {\n          this.logger.info(\"checkConnection called with \".concat(t)), this.fsm.checkConnection(t), t && this.connectionTracker.sendTelemetry(p.ClientEventName.CheckConnection, {\n            disconnectDetected: t\n          }, []);\n        }, t.prototype.disableRegistrationsAndAutoReconnect = function () {\n          this.stopRegistrationTimer(), this.cancelPendingRegistrationRequests(), this.fsm.disableAutoReconnect();\n        }, t.prototype.getServerState = function () {\n          return new y.ServerState(this.connectionId, this.connectedClientId, this.domId ? this.domId : \"\", this.allocateResult ? this.allocateResult.url : \"\", this.allocateResult ? this.allocateResult.surl : \"\", this.c2cUrlBase, this.connectionExpireTimestampInSecs);\n        }, t.prototype.getState = function () {\n          return this.fsm.getState();\n        }, t.prototype.getToken = function (t, e, n, o, i) {\n          var r = this;\n          void 0 === i && (i = 0), this.logger.info(\"Getting token \".concat(e ? \"with backoff\" : \"without backoff\"));\n          var s = function () {\n            r.connectionTracker.trackStart(\"token\");\n            var e = {\n              needFresh: !t,\n              wwwAuthenticateHeader: n,\n              supportedTokenTypes: g.SUPPORTED_TOKEN_TYPES,\n              purpose: \"trouter\"\n            };\n            r.logger.info(\"Requesting token: needFresh=\".concat(e.needFresh, \" \") + \"types=[\".concat(g.SUPPORTED_TOKEN_TYPES, \"], \") + \"wwwAuthenticateHeader is \".concat(e.wwwAuthenticateHeader ? \"non empty\" : \"empty\")), r.tokenProvider(e).then(function (t) {\n              r.logger.debug(\"\".concat(t.tokenType, \" token is received\")), r.connectionTracker.trackEnd(\"token\"), r.fsm.onTokenReceived(t, o, r.reconnectParams);\n            }).catch(function (e) {\n              var s = (0, l.toJson)(e.stack);\n              if (r.logger.error(\"Getting token failed, will retry after timeout. Error: \".concat(s)), r.connectionTracker.trackError(\"token\", s), !r.canRetryTokenFetchRequest(i + r.unauthorizedErrorCount)) {\n                return r.connectionTracker.trackError(\"token\", \"getToken retry limit hit, reached terminal error state\"), r.resetTokenBackoff(), void r.fsm.onTerminalError();\n              }\n              r.getToken(t, !0, n, o, i + 1);\n            });\n          };\n          e ? this.tokenBackoff.backoff(\"getting token\", s) : (this.resetTokenBackoff(), s());\n        }, t.prototype.startConnectionTimer = function () {\n          var t = this;\n          this.stopConnectionTimer(), this.logger.debug(\"Starting connection timeout for \".concat(this.timeoutOptions.connectionTimeoutMs, \" ms\")), this.connectionTimeoutId = setTimeout(function () {\n            t.logger.info(\"Connection timeout is fired\"), t.fsm.onConnectingTimeout();\n          }, this.timeoutOptions.connectionTimeoutMs);\n        }, t.prototype.stopConnectionTimer = function () {\n          this.connectionTimeoutId && (this.logger.debug(\"Stopping connection timeout\"), clearTimeout(this.connectionTimeoutId), this.connectionTimeoutId = void 0);\n        }, t.prototype.startPingTimer = function () {\n          var t = this;\n          \"websocket\" === this.transportTypeName ? (this.logger.debug(\"Starting ping timeout for \".concat(this.timeoutOptions.pingTimeoutMs, \" ms\")), this.pingTimerId = setInterval(function () {\n            t.logger.info(\"Ping interval fired\"), t.fsm.onPingInterval();\n          }, this.timeoutOptions.pingTimeoutMs)) : this.logger.debug(\"Not starting ping for transport \".concat(this.transportTypeName));\n        }, t.prototype.stopPingTimer = function () {\n          this.pingTimerId && (this.logger.debug(\"Stopping ping timeout\"), this.clearPingResponseTimer(), clearInterval(this.pingTimerId), this.pingTimerId = void 0);\n        }, t.prototype.shouldSkipRegistration = function () {\n          return void 0 === this.options.registration;\n        }, t.prototype.hasCustomRegistrationTtl = function () {\n          var t, e;\n          return void 0 !== (null === (t = this.options.registration) || void 0 === t ? void 0 : t.registrarTtlSec) && 0 !== (null === (e = this.options.registration) || void 0 === e ? void 0 : e.registrarTtlSec);\n        }, t.prototype.startRegistrationTimer = function () {\n          var t = this;\n          this.stopRegistrationTimer();\n          var e = this.getRegistrationTtl(),\n            n = e[0],\n            o = e[1];\n          if (n <= 30 || !o) return this.logger.debug(\"Starting registration expiration timer (TTL \".concat(n, \" sec)\")), void (this.registrationTimerId = setTimeout(function () {\n            t.registrationTimerId = void 0, t.logger.warn(\"Registration expired but the connection is still alive. Should never happen\"), t.dispatchUnregistered();\n          }, 1e3 * n));\n          var i = n - 30;\n          this.logger.debug(\"Starting registration extension timer for \".concat(i, \" sec\")), this.registrationTimerId = setTimeout(function () {\n            t.logger.info(\"Registration extension timer fired\"), t.registrationTimerId = setTimeout(function () {\n              t.registrationTimerId = void 0, t.logger.debug(\"Registration extension did not happen in time\"), t.dispatchUnregistered();\n            }, 3e4), t.fsm.onRegistrationNearExpiry();\n          }, 1e3 * i);\n        }, t.prototype.startRegistrationRetryTimer = function () {\n          var t = this;\n          this.stopRegistrationTimer();\n          this.registrationTimerId = setTimeout(function () {\n            t.registrationTimerId = void 0, t.fsm.onRetryRegistration();\n          }, 123e3);\n        }, t.prototype.stopRegistrationTimer = function () {\n          this.registrationTimerId && (this.logger.debug(\"Stopping registration timeout\"), clearTimeout(this.registrationTimerId), this.registrationTimerId = void 0);\n        }, t.prototype.resendRegistration = function () {\n          if (!this.registrarClient) throw new Error(\"Trouter Client not configured to handle registrations\");\n          return this.fsm.onResendRegistration(), Promise.resolve();\n        }, t.prototype.buildSocketIoUrlParams = function (t, e) {\n          if (!this.allocateResult) throw new Error(\"Allocate result is undefined in buildSocketIoUrlParams()\");\n          for (var n = {}, o = this.allocateResult.connectparams, i = 0, r = Object.keys(o); i < r.length; i++) {\n            var s = r[i];\n            if (void 0 !== o[s]) {\n              var c = o[s];\n              \"string\" == typeof c || \"number\" == typeof c ? n[s] = c : this.logger.error(\"signatureData[\".concat(s, \"] has unsupported type \").concat(typeof c));\n            }\n          }\n          return n.v = \"v4\", n.tc = encodeURI((0, l.toJson)(this.clientInfo)), n.timeout = this.timeoutOptions.pingTimeoutMs / 1e3, n.auth = \"true\", this.options.endpointId && (n.epid = this.options.endpointId), t && (n.userActivity = encodeURI((0, l.toJson)(t))), e && (n.audienceSubscriptionState = encodeURIComponent((0, l.toJson)(e))), this.appendConnectedClientIds(this.buildQuery(n), !0);\n        }, t.prototype.startSocketIo = function (t) {\n          var e, n;\n          if (this.logger.debug(\"Starting socket io\"), this.connectionTracker.trackStart(\"connectSocket\"), !this.allocateResult) throw new Error(\"Allocate result is undefined in startSocketIo()\");\n          var i = this.options.ioOptions ? c({}, this.options.ioOptions) : new R(),\n            r = this.userActivityState.state !== m.UserActivityState.Unknown ? this.userActivityState.increaseCvAndGetEventObject() : void 0,\n            s = null === (e = this.audienceSubscriptionState) || void 0 === e ? void 0 : e.increaseCvAndGetEventObject();\n          if (i[\"force new connection\"] = !0, i.reconnect = !1, i.rewriteUrlForProxy = this.options.rewriteUrlForProxy, i.requestHeaders = c(c({}, this.options.extraConnectionHeaders), o(t, this.usingLegacyTokenApi)), i.query = this.buildSocketIoUrlParams(r, s), this.logger.info(\"connecting to \".concat(this.allocateResult.socketio, \"?\").concat(i.query)), this.stopSocketIo(), this.socket = (null !== (n = this.options.io) && void 0 !== n ? n : w).connect(this.allocateResult.socketio, i), void 0 === this.socket) throw new Error(\"Can't create Socket.io object\");\n          this.attachSocketIoHandlers(this.socket, t, r, s);\n        }, t.prototype.stopSocketIo = function () {\n          if (this.socket) {\n            this.logger.debug(\"clearing socket.io\");\n            try {\n              for (var t = 0, e = [\"connecting\", \"connect\", \"connect_failed\", \"close_during_connecting\", \"disconnect\", \"reconnect\", \"reconnect_failed\", \"reconnecting\", \"error\", \"message\", \"trouter.connected\", \"trouter.reconnect\", \"trouter.message_loss\"]; t < e.length; t++) {\n                var n = e[t];\n                this.socket.removeAllListeners(n);\n              }\n              this.socket.disconnect(), this.logger.debug(\"cleared socket\"), this.socket = void 0;\n            } catch (t) {\n              this.logger.error(\"exception in disconnecting previous socket. Error: \".concat(r(t)));\n            }\n          }\n        }, t.prototype.dispatchConnected = function () {\n          this.logger.info(\"dispatching connected\"), this.manager.onConnected(this);\n        }, t.prototype.dispatchRegistered = function () {\n          this.logger.info(\"dispatching registered\"), this.manager.onRegistered(this);\n        }, t.prototype.dispatchUnregistered = function () {\n          this.logger.info(\"dispatching unregistered\"), this.manager.onUnregistered(this);\n        }, t.prototype.dispatchDownstreamRequest = function (t) {\n          var e = this;\n          this.logger.debug(\"dispatching downstream request\");\n          try {\n            var n = new I(t, new p.ResponseData(t.id), function (t, n) {\n              return e.logger.debug(\"sending response to downstream\"), e.sendResponse(t, n);\n            });\n            this.manager.onDownstreamRequest(this, t, n);\n          } catch (t) {\n            this.logger.error(\"exception in socket.on message. Error : \".concat(r(t)));\n          }\n        }, t.prototype.dispatchReconnecting = function () {\n          this.logger.info(\"dispatching reconnecting\"), this.manager.onReconnecting(this);\n        }, t.prototype.dispatchReconnectIsRequired = function (t, e) {\n          this.logger.info(\"dispatching reconnect is required by server\"), this.manager.onReconnectIsRequired(this, t, e);\n        }, t.prototype.dispatchDisconnected = function () {\n          this.logger.info(\"dispatching disconnected\"), this.manager.onDisconnected(this);\n        }, t.prototype.dispatchTerminalError = function () {\n          this.logger.info(\"dispatching terminal error\"), this.manager.onTerminalError(this);\n        }, t.prototype.dispatchTrouterMessageLost = function (t) {\n          this.logger.info(\"dispatching trouter message lost\"), this.manager.onTrouterMessageLost(t);\n        }, t.prototype.countDisconnectBeforeConnectionEstablishment = function () {\n          this.logger.warn(\"counting disconnect before connection was fully established as a connection failure\"), ++this.connectingErrorsInRow >= this.connectingErrorsThreshold && this.resetReconnectParamsOnErrorThreshold();\n        }, t.prototype.sendProcessedDroppedIndicators = function (t) {\n          var e = this;\n          try {\n            this.logger.debug(\"emitting processed flow tags to the server\");\n            var n = new A(\"trouter.processed_message_loss\");\n            n.args = {\n              droppedIndicators: t\n            }, this.sendDownstreamEvent(n, function () {\n              e.logger.info(\"emitted processed flow tags to the server\");\n            });\n          } catch (t) {\n            var o = r(t);\n            this.logger.error(\"unable to send processed message loss event. Error: \".concat(o)), this.connectionTracker.trackError(\"trouter.processed_message_loss\", o, !1);\n          }\n        }, t.prototype.sendAllocateRequest = function (t) {\n          var e = this;\n          this.connectionAttempt++, this.connectionTracker.trackNewConnection();\n          var n,\n            i = this.options.trouterUrl,\n            r = this.reconnectParams,\n            s = \"string\" == typeof (null === r || void 0 === r ? void 0 : r.se) ? parseInt(r.se, 10) : \"number\" == typeof (null === r || void 0 === r ? void 0 : r.se) ? r.se : void 0;\n          s && s <= Date.now() + 36e5 && (this.logger.warn(\"Dropping expired cached connection parameters: \".concat(new Date(s))), this.reconnectParams = r = void 0), r && r.serviceUrl !== i && (this.logger.warn(\"Dropping cached connection parameters for a different environment (\".concat(r.serviceUrl, \", now \").concat(i, \")\")), this.reconnectParams = r = void 0), (null === r || void 0 === r ? void 0 : r.reconnectUrl) && (i = r.reconnectUrl), n = r ? c(c({}, r), {\n            serviceUrl: void 0,\n            reconnectUrl: void 0\n          }) : null, i = (0, S.adaptUrl)(i, \"v4a\"), i = this.appendCorrelationIds(i, !1), i = this.appendEndpointId(i, !1), n && (i += \"&\".concat(this.buildQuery(n)), n.v || (i += \"&v=\".concat(\"v4\"))), i = this.options.rewriteUrlForProxy(i);\n          var a = new Request(i, {\n            method: \"POST\",\n            mode: \"cors\",\n            headers: new Headers(c(c({\n              \"Content-Type\": \"text/plain\"\n            }, this.options.extraConnectionHeaders), o(t, this.usingLegacyTokenApi)))\n          });\n          this.logger.info(\"sendAllocateRequest: POST \".concat(i)), this.connectionTracker.trackStart(\"allocation\");\n          var u,\n            h = Date.now(),\n            d = -1,\n            p = !1;\n          (0, l.fetchWithTimeout)(a, this.timeoutOptions.fetchTimeoutMs).then(function (t) {\n            var n;\n            if (d = t.status, !t.ok) throw u = null !== (n = t.headers.get(\"www-authenticate\")) && void 0 !== n ? n : void 0, p = \"1\" === t.headers.get(\"x-trouter-skypetoken-deprecated\"), e.logger.warn(\"Allocation request got response status \".concat(t.status, \", www-authenticate header was \").concat(u ? \"not empty\" : \"empty\")), new Error(t.statusText);\n            var o = t.headers.get(\"content-type\");\n            if (!o || \"application/json\" !== o && !o.startsWith(\"application/json;\")) throw new Error(\"Content-type '\".concat(o, \"' is unexpected\"));\n            return e.connectionTracker.trackEnd(\"allocation\"), t.json();\n          }).then(function (n) {\n            e.unauthorizedErrorCount = 0, e.onAllocationResponse(n, t);\n          }).catch(function (t) {\n            e.connectingErrorsInRow++;\n            var n = \"\".concat(t).concat(d >= 0 ? \", status code \".concat(d) : \"\");\n            if (e.logger.error(\"\".concat(e.connectingErrorsInRow, \" failed connecting attempt(s) in a row. \").concat(n)), e.connectionTracker.trackError(\"allocation\", n), p) {\n              var o = \"Skypetoken deprecated response, not retrying any further\";\n              return e.logger.error(o), e.connectionTracker.trackError(\"allocation\", o), void e.fsm.onTerminalError();\n            }\n            if (401 === d && e.unauthorizedErrorCount++, !e.canRetryTokenFetchRequest(e.unauthorizedErrorCount)) {\n              var o = \"getToken retry limit hit, reached terminal error state\";\n              return e.connectionTracker.trackError(\"allocation\", o), void e.fsm.onTerminalError();\n            }\n            if (-1 !== d || e.isNavigatorOnline) {\n              if (e.reconnectParams && e.connectingErrorsInRow >= e.connectingErrorsThreshold) if (d >= 400 && d <= 599) e.resetReconnectParamsOnErrorThreshold();else if (e.reconnectParams.reconnectUrl && e.connectingErrorsInRow % 3 == 0) {\n                e.logger.warn(\"\".concat(e.connectingErrorsInRow, \" connection attempts, testing nominal service URL\"));\n                var i = Math.min(e.timeoutOptions.connectionTimeoutMs - (Date.now() - h) - 500, e.timeoutOptions.fetchTimeoutMs);\n                return void e.testNominalUrlConnectivity(i).then(function (t) {\n                  e.connectionTracker.trackProgress(\"nomcheck\", t ? \"ok\" : \"failed\"), t ? (e.logger.warn(\"Nominal service URL is reachable, erasing cached reconnect URL\"), e.reconnectParams && delete e.reconnectParams.reconnectUrl) : e.logger.warn(\"Nominal service URL is not reachable either, keeping cached reconnect URL\"), e.fsm.onAllocationFailed(!1, void 0);\n                }, function () {\n                  e.fsm.onAllocationFailed(!1, void 0);\n                });\n              }\n            } else e.logger.info(\"Expected failure, the browser says it is not online at the moment\");\n            e.fsm.onAllocationFailed(401 === d, u);\n          });\n        }, t.prototype.testNominalUrlConnectivity = function (t) {\n          var e = this;\n          if (t < 1e3) return this.logger.warn(\"There is no time left to reasonably perform the nominal service URL connectivity check (\".concat(t, \" ms), falling back to assuming that the connectivity is fine\")), Promise.resolve(!0);\n          var n;\n          try {\n            var o = new URL(this.options.trouterUrl);\n            o.pathname = \"/\", o.search = \"?\" + this.buildQuery({\n              check: Date.now(),\n              cor_id: encodeURIComponent(this.options.clientCorrelationID),\n              epid: encodeURIComponent(this.options.endpointId ? this.options.endpointId : \"\"),\n              tc: encodeURIComponent((0, l.toJson)(this.clientInfo))\n            }), n = new Request(this.options.rewriteUrlForProxy(o.toString()), {\n              method: \"GET\",\n              headers: {\n                Accept: \"text/plain\"\n              }\n            });\n          } catch (t) {\n            return this.logger.warn(\"Nominal service URL connectivity test request could not be created (\".concat(t, \"), falling back to assuming that the connectivity is fine\")), Promise.resolve(!0);\n          }\n          return (0, l.fetchWithTimeout)(n, t).then(function (t) {\n            if (200 !== t.status) throw new Error(\"Not 200 OK: \".concat(t.status, \" \").concat(t.statusText));\n            return t.text();\n          }).then(function (t) {\n            if (\"Trouter\" !== t) throw new Error('Not \"Trouter\": '.concat(t.substring(0, 16)).concat(t.length > 16 ? \"...\" : \"\"));\n            return !0;\n          }).catch(function (t) {\n            return e.logger.error(\"Nominal service URL connectivity test failed: \".concat(t)), !1;\n          });\n        }, t.prototype.sendPingRequest = function () {\n          var t = this;\n          if (this.socket && void 0 === this.pingResponseTimerId) try {\n            this.logger.debug(\"emitting ping event\");\n            var e = !1;\n            this.socket.emit(\"ping\", function () {\n              !0 !== e && t.onPingResponse();\n            }), this.pingResponseTimerId = setTimeout(function () {\n              t.logger.error(\"Ping response timeout is fired\"), e = !0, t.clearPingResponseTimer(), t.fsm.onPingResponseTimeout();\n            }, this.timeoutOptions.pongTimeoutMs);\n          } catch (t) {\n            var n = r(t);\n            this.logger.error(\"unable to send ping. Error: \".concat(n)), this.connectionTracker.trackError(\"ping\", n, !1);\n          }\n        }, t.prototype.connectV4c = function (t, e) {\n          var n,\n            o,\n            i,\n            r,\n            s,\n            a,\n            u = this.options.ioOptions ? c({}, this.options.ioOptions) : new R();\n          u[\"force new connection\"] = !0, u.reconnect = !1, (null === (n = this.reconnectParams) || void 0 === n ? void 0 : n.serviceUrl) && (0, S.adaptUrl)(this.reconnectParams.serviceUrl, \"v4c\") !== (0, S.adaptUrl)(this.options.trouterUrl, \"v4c\") && (this.logger.warn(\"Dropping cached connection parameters for a different environment (\".concat(this.reconnectParams.serviceUrl, \", now \").concat(this.options.trouterUrl, \")\")), this.reconnectParams = void 0);\n          var h = null !== (r = null !== (o = (0, S.redirectUrlIfPresent)(e)) && void 0 !== o ? o : \"redirect-no-host\" !== (null === e || void 0 === e ? void 0 : e.kind) ? null === (i = this.reconnectParams) || void 0 === i ? void 0 : i.reconnectUrl : void 0) && void 0 !== r ? r : this.options.trouterUrl,\n            d = (0, S.adaptUrl)(h, \"v4c\");\n          u[\"skipped handshake data\"] = {\n            timeout: 70,\n            websocketUrl: d\n          }, u.query = this.buildV4cUrlParams(), u.rewriteUrlForProxy = this.options.rewriteUrlForProxy;\n          try {\n            if (this.stopSocketIo(), this.transportTypeName = \"websocket\", this.socket = (null !== (s = this.options.io) && void 0 !== s ? s : w).connect(this.options.trouterUrl, u), void 0 === this.socket) throw new Error(\"failed to create Socket.io object\");\n            var l = null === (a = this.audienceSubscriptionState) || void 0 === a ? void 0 : a.increaseCvAndGetEventObject();\n            this.attachSocketIoHandlers(this.socket, t, void 0, l);\n          } catch (t) {\n            this.logger.error(\"\".concat(t)), this.connectionTracker.trackError(\"v4c\", \"\".concat(t)), this.fsm.onV4cException();\n          }\n        }, t.prototype.sendV4cAuthenticationEvent = function (t) {\n          var e,\n            n = {\n              headers: c(c({}, this.options.extraConnectionHeaders), o(t, this.usingLegacyTokenApi)),\n              connectparams: (0, S.reconnectParamsWithoutUrls)(this.reconnectParams)\n            };\n          null === (e = this.socket) || void 0 === e || e.emit(g.USER_AUTHENTICATE_EVENT_NAME, n);\n        }, t.prototype.setUserActivityState = function (t) {\n          var e = t.state !== this.userActivityState.state;\n          this.userActivityState = t, e ? (this.logger.info(\"Changing user activity state to '\".concat(t.toEventJSON(), \"'\")), this.fsm.onSetNewUserActivityState()) : (this.logger.debug(\"Not changing the same user activity state '\".concat(t.toEventJSON(), \"'\")), this.manager.onUserActivityStateAccepted(t.correlationVector.value()));\n        }, t.prototype.sendUserActivityState = function (t, e) {\n          this.userActivityState.state !== m.UserActivityState.Unknown && (\"websocket\" === this.transportTypeName && e ? t === y.UserActivityEventReason.Connected ? this.sendUserActivityStateMultiple(2) : this.sendUserActivityStateMultiple(1) : \"xhr-polling\" === this.transportTypeName && t === y.UserActivityEventReason.Modified && this.fsm.forceReconnect(\"user activity/force reconnect\"));\n        }, t.prototype.setAudienceSubscriptionsAsync = function (t, e) {\n          var n = this.audienceSubscriptionState;\n          if (this.audienceSubscriptionState = t, this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) return this.setAudienceSubscriptionsInternalAsync(t.increaseCvAndGetEventObject(), e);\n          if (this.transportTypeName === this.XHR_POLLING_TRANSPORT_NAME) {\n            var o = this.setAudienceSubscriptionsLongpollInternalAsync(t.increaseCvAndGetEventObject(), e, n);\n            return this.fsm.forceReconnect(\"set audience subscription force reconnect\"), o;\n          }\n          throw new Error(\"set audience subscription executed on an unknown transport\");\n        }, t.prototype.setAudienceSubscriptionsUnsafeAsync = function (t) {\n          if (t) return this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME ? this.setAudienceSubscriptionsInternalAsync(t, 15e3) : void 0;\n        }, t.prototype.setAudienceSubscriptionsInternalAsync = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            var n,\n              o,\n              i = this;\n            return u(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return this.logger.info(\"[WebSocket] Audience subscription set requested.\"), n = new A(\"audience.subscribe\"), n.args = t, [4, new Promise(function (o) {\n                    var r = !1,\n                      s = setTimeout(function () {\n                        return r = !0, o(i.buildAudienceSubscriptionsTimeoutResponse(t));\n                      }, e);\n                    i.sendDownstreamEvent(n, function (t, e) {\n                      r || (clearTimeout(s), i.logger.debug(\"[Websocket] Audience subscription response: \".concat(e)), i.pendingAudienceSubscription && i.onAudienceSubscriptionResult(e), o(e));\n                    });\n                  })];\n                case 1:\n                  return o = r.sent(), this.manager.onAudiencesSetResolved(o, t.cv), [2, o];\n              }\n            });\n          });\n        }, t.prototype.setAudienceSubscriptionsLongpollInternalAsync = function (t, e, n) {\n          var o;\n          return a(this, void 0, void 0, function () {\n            var i,\n              r,\n              s,\n              c,\n              a,\n              h,\n              d = this;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return this.logger.info(\"[XHR Polling] Audience subscription set requested.\"), this.pendingAudienceSubscription && (this.logger.error(\"Racing audience subscriptions occured. This situation resolves into undefined scenario and/or nasal demons.\"), clearTimeout(this.pendingAudienceSubscription.timeoutId)), 0 === t.audiences.length ? [2, this.handleAudienceUnsubscribeLongpoll(t.cv, n)] : [4, new Promise(function (n) {\n                    var o = setTimeout(function () {\n                      return d.pendingAudienceSubscription = void 0, n(d.buildAudienceSubscriptionsTimeoutResponse(t));\n                    }, e);\n                    d.pendingAudienceSubscription = {\n                      audienceSetResolve: n,\n                      timeoutId: o\n                    };\n                  })];\n                case 1:\n                  return i = u.sent(), this.manager.getState() === m.TrouterState.Unknown || this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME ? [2, i] : (r = i.responses[0], (null === r || void 0 === r ? void 0 : r.result.audienceSubscriptionState) === this.AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST ? (this.clearAudienceSubscriptionStateQueryParam(), this.manager.onAudiencesSetResolved(i, t.cv), [2, i]) : (s = i.responses.find(function (e) {\n                    return e.audienceId === t.audiences[0].id;\n                  }), (null === s || void 0 === s ? void 0 : s.result.audienceSubscriptionState) === this.AUDIENCE_SUBSCRIPTION_RESULT_ERROR ? (this.clearAudienceSubscriptionStateQueryParam(), this.manager.onAudiencesSetResolved(i, t.cv), [2, i]) : (c = (null === (o = null === n || void 0 === n ? void 0 : n.audienceSubscriptionModel.audienceSubscriptions[0]) || void 0 === o ? void 0 : o.id) !== (null === r || void 0 === r ? void 0 : r.audienceId), n && c && (a = this.mapToSyntheticAudienceSubscriptionResponses(n.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200), (h = i.responses).push.apply(h, a)), this.manager.onAudiencesSetResolved(i, t.cv), [2, i])));\n              }\n            });\n          });\n        }, t.prototype.clearAudienceSubscriptionStateQueryParam = function () {\n          var t, e, n;\n          (null === (n = null === (e = null === (t = this.socket) || void 0 === t ? void 0 : t.socket) || void 0 === e ? void 0 : e.options) || void 0 === n ? void 0 : n.query) && (this.socket.socket.options.query = this.socket.socket.options.query.replace(this.AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX, \"\"));\n        }, t.prototype.handleAudienceUnsubscribeLongpoll = function (t, e) {\n          var n;\n          this.audienceSubscriptionState = void 0;\n          var o = {\n            responses: []\n          };\n          if (e) {\n            var i = this.mapToSyntheticAudienceSubscriptionResponses(e.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200);\n            (n = o.responses).push.apply(n, i);\n          }\n          return this.manager.onAudiencesSetResolved(o, t), o;\n        }, t.prototype.buildAudienceSubscriptionsTimeoutResponse = function (t) {\n          return this.logger.error(\"Audience subscription attempt has timed out.\"), {\n            responses: this.mapToSyntheticAudienceSubscriptionResponses(t.audiences, this.AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT)\n          };\n        }, t.prototype.mapToSyntheticAudienceSubscriptionResponses = function (t, e, n) {\n          return t.map(function (t) {\n            return {\n              audienceId: t.id,\n              result: {\n                audienceSubscriptionState: e,\n                responseStatus: n\n              }\n            };\n          });\n        }, t.prototype.expediteBackoff = function () {\n          this.tokenBackoff.expediteIfPending();\n        }, t.prototype.sendRegisterRequest = function () {\n          var t = this;\n          if (!this.options.registration || !this.registrarClient) throw new Error(\"Internal error - options.registration is undefined\");\n          if (!this.allocateResult) throw new Error(\"Allocate result is undefined in sendRegisterRequest()\");\n          this.logger.info(\"sending register request\");\n          var e = new l.Timespan();\n          this.connectionTracker.trackStart(\"registration\");\n          var n = this.getRegistrationTtl()[0];\n          this.registrarClient.register({\n            appId: this.options.registration.pnhAppId,\n            aesKey: \"\",\n            languageId: \"en-US\",\n            platform: this.options.registration.platform,\n            templateKey: this.options.registration.pnhTemplateKey,\n            platformUIVersion: this.options.registration.platformUIVersion,\n            productContext: this.options.registration.productContext\n          }, {\n            TROUTER: [{\n              context: this.options.registration.context,\n              path: this.allocateResult.surl,\n              ttl: n\n            }]\n          }).then(function () {\n            t.logger.info(\"Register request successful\"), t.connectionTracker.trackEnd(\"registration\"), t.fsm.onRegistrationSucceeded(), t.connectionTracker.sendTelemetry(p.ClientEventName.Registration, {\n              duration: e.duration\n            }, []);\n          }).catch(function (n) {\n            t.logger.error(\"Register request failed. Error: \".concat(n)), t.connectionTracker.trackError(\"registration\", s(n)), t.fsm.onRegistrationFailed(), t.connectionTracker.sendTelemetry(p.ClientEventName.Registration, {\n              duration: e.duration\n            }, []);\n          });\n        }, t.prototype.sendUnregisterRequest = function () {\n          var t = this;\n          this.logger.info(\"sending unregister request\");\n          var e = new l.Timespan();\n          if (!this.options.registration || !this.registrarClient) throw new Error(\"Internal error - options.registration is undefined\");\n          this.connectionTracker.trackStart(\"unregistration\"), this.registrarClient.unregister().then(function () {\n            t.logger.info(\"Unregister request successful\"), t.connectionTracker.trackEnd(\"unregistration\"), t.fsm.onUnregistrationDone(), t.connectionTracker.sendTelemetry(p.ClientEventName.Unregistration, {\n              duration: e.duration\n            }, []);\n          }).catch(function (n) {\n            t.logger.error(\"Unregister request failed. Error: \".concat(n)), t.connectionTracker.trackError(\"unregistration\", s(n)), t.fsm.onUnregistrationDone(), t.connectionTracker.sendTelemetry(p.ClientEventName.Unregistration, {\n              duration: e.duration\n            }, []);\n          });\n        }, t.prototype.resetTokenBackoff = function () {\n          this.tokenBackoff.reset();\n        }, t.prototype.cancelPendingRegistrationRequests = function () {\n          this.registrarClient && this.registrarClient.cancelPendingRequests();\n        }, t.prototype.clearSentEventTimers = function () {\n          var t = Object.keys(this.pendingSentEventTimers);\n          if (t.length > 0) {\n            this.logger.debug(\"Clearing all pending downstream events related timers\");\n            for (var e = 0, n = t; e < n.length; e++) {\n              var o = n[e];\n              this.clearSentEventTimer(Number(o));\n            }\n          }\n        }, t.prototype.restartIncallModeTimer = function () {\n          var t = this;\n          this.clearIncallModeTimerId(), this.logger.debug(\"Restarting incall mode timer\"), this.incallModeTimerId = setTimeout(function () {\n            t.logger.info(\"Call mode timer fired\"), t.fsm.onIncallModeTimer();\n          }, this.options.incallModeTimeoutMs);\n        }, t.prototype.enterIncallMode = function () {\n          this.logger.info(\"Entering incall mode\"), this.timeoutOptions = this.options.incallTimeoutOptions, this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = !0;\n        }, t.prototype.exitIncallMode = function () {\n          this.logger.info(\"Exiting incall mode\"), this.clearIncallModeTimerId(), this.timeoutOptions = this.options.timeoutOptions, this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = !1;\n        }, t.prototype.isIncallMode = function () {\n          return this.inIncallMode;\n        }, t.prototype.sendDisconnectTelemetryEvent = function (t) {\n          var e = {\n            reason: t,\n            serverClosed: !this.fsm.isActive()\n          };\n          this.connectionTracker.trackDisconnected(e), this.connectionTracker.clearConnectedInfo();\n        }, t.prototype.forceReconnectDueToNoRegistration = function () {\n          this.fsm.forceReconnect(\"force reconnect due to no registration\");\n        }, t.prototype.resetReconnectParamsOnErrorThreshold = function () {\n          this.logger.warn(\"\".concat(this.connectingErrorsInRow, \" connection attempts, server-side failure: erasing cached connection parameters\")), this.reconnectParams = void 0;\n        }, t.prototype.onSocketConnecting = function (t) {\n          this.logger.info(\"onSocketConnecting(\".concat(t, \")\")), this.transportTypeName = t, this.connectionTracker.trackProgress(\"connecting\", this.transportTypeName), this.fsm.onConnecting();\n        }, t.prototype.onSocketConnect = function (t) {\n          this.logger.info(\"onSocketConnect\"), this.fsm.onSocketConnect(t);\n        }, t.prototype.onSocketConnectFailed = function (t) {\n          this.logger.error(\"onSocketConnectFailed\"), this.connectionTracker.trackError(\"connect_failed\", t, !0, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onConnectingFailed();\n        }, t.prototype.onSocketDisconnect = function (t) {\n          var e = this.connectionTracker.getSessionLength() || 0,\n            n = f.DisconnectReason.fromRawReason(t);\n          this.logger.error(\"onSocketDisconnect, reason: \".concat(n.reason)), \"dup\" === n.reason && \"dup\" === this.lastDisconnectReason && e < this.options.duplicateDisconnectThresholdMs && (this.logger.warn(\"Socket was closed by server as Duplicate for the second time in a row \" + \"after \".concat(e, \" ms which is below the threshold of \") + \"\".concat(this.options.duplicateDisconnectThresholdMs, \" ms. Resetting cached \") + \"connection parameters and making a new allocation.\"), this.reconnectParams = void 0), this.lastDisconnectReason = n.reason, this.fsm.onSocketDisconnect(n), this.connectionExpireTimestampInSecs = void 0;\n        }, t.prototype.onSocketReconnect = function () {\n          this.logger.error(\"onSocketReconnect\"), this.fsm.onTrouterConnected();\n        }, t.prototype.onSocketReconnectFailed = function (t) {\n          this.logger.error(\"onSocketReconnectFailed with '\".concat(t, \"'\")), this.fsm.onSocketDisconnect(f.DisconnectReason.fromSocketIoEventData(\"reconnecterror\", t));\n        }, t.prototype.onSocketReconnecting = function () {\n          this.logger.error(\"onSocketReconnecting\");\n        }, t.prototype.onSocketError = function (t) {\n          this.logger.error(\"onSocketError with '\".concat((0, l.toJson)(t), \"'\")), this.fsm.isConnecting() && ++this.connectingErrorsInRow >= this.connectingErrorsThreshold && this.resetReconnectParamsOnErrorThreshold(), this.connectionTracker.trackError(\"connectSocket\", i(t)), this.fsm.onSocketDisconnect(f.DisconnectReason.fromSocketIoEventData(\"socketerror\", t));\n        }, t.prototype.onSocketMessage = function (t) {\n          var e,\n            n = this;\n          this.logger.debug(\"onSocketMessage\");\n          var o;\n          try {\n            o = new E(t, this.logger);\n            var i = null === (e = o.headers) || void 0 === e ? void 0 : e[\"X-Microsoft-Skype-Chain-ID\"],\n              c = i ? \" Chain-Id \".concat(i) : \"\";\n            this.logger.info(\"Received request N \".concat(o.id).concat(c, \" CV \").concat(o.correlationVector, \" to '\").concat(o.url, \"'\")), o.startTS = Date.now(), o.url && this.urlPath && o.url.startsWith(this.urlPath) && (o.shortUrl = o.url.substring(this.urlPath.length));\n          } catch (t) {\n            var a = r(t);\n            return this.logger.error(\"unable to parse request. Error: \".concat(a)), this.connectionTracker.trackRequest(void 0, a), void this.connectionTracker.sendResponseError(\"unable to parse request, error: \".concat(t));\n          }\n          o.timeoutTimerId = setTimeout(function () {\n            if (!o.replied) {\n              n.logger.error(\"Request \".concat(o.id, \" timed out\"));\n              var t = new p.ResponseData(o.id);\n              t.status = 504, t.headers = {\n                \"Trouter-Responder\": \"ClientLib\"\n              }, n.sendResponse(o, t), o.timedout = !0;\n            }\n          }, this.timeoutOptions.requestTimeoutMs);\n          try {\n            this.connectionTracker.trackRequest(o), this.fsm.onDownstreamRequest(o);\n          } catch (t) {\n            this.logger.error(\"exception in socket.on message. Error: \".concat(r(t))), this.connectionTracker.sendResponseError(s(t), o, void 0);\n          }\n        }, t.prototype.onTrouterConnected = function (t, e, n) {\n          var o,\n            i,\n            r,\n            s,\n            a = this;\n          if ((0, S.isV4ConnectEvent)(t)) {\n            var u = t;\n            this.allocateResult = c(c({}, u), {\n              ttl: t.ttl.toString()\n            }), this.populateAndCacheReconnectParams(u, u.reconnectUrl), this.populateConnectionStateFields(u);\n          } else if (!this.allocateResult) return void this.logger.error(\"Invalid internal state - received onTrouterConnected while allocateResult is not set\");\n          this.connectingErrorsInRow = 0, this.logger.info(\"onTrouterConnected: \".concat(this.allocateResult.url)), \"xhr-polling\" === this.transportTypeName && e && this.manager.onUserActivityStateAccepted(e.cv), (null === (r = null === (i = null === (o = this.socket) || void 0 === o ? void 0 : o.socket) || void 0 === i ? void 0 : i.options) || void 0 === r ? void 0 : r.query) && (this.socket.socket.options.query += \"&connected=true\"), this.urlPath = this.allocateResult.url.replace(/https?:\\/\\/([A-z0-9\\:\\$\\-\\_\\.\\+\\!\\*\\\"\\(\\)\\,]*)\\//, \"/\");\n          var h = this.connectedUrl !== this.allocateResult.url;\n          this.connectedUrl = this.allocateResult.url, this.connectionExpireTimestampInSecs = (0, l.calculateExpireTsInSec)((0, S.ensureNumber)(t.ttl)), this.connectionTracker.trackEnd(\"connectSocket\"), this.connectionTracker.trackConnected(h, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), null === (s = this.setAudienceSubscriptionsUnsafeAsync(n)) || void 0 === s || s.catch(function (t) {\n            return a.logger.error(\"Re-subscribe to audiences has failed with \".concat(t));\n          }), this.fsm.onTrouterConnected();\n        }, t.prototype.onTrouterReconnect = function (t) {\n          var e = t.target;\n          this.logger.info(\"onTrouterReconnect target: \".concat(e)), \"self\" === e ? this.fsm.onReconnectRequired(!0, h.ServerInitiated) : this.fsm.onReconnectRequired(!1, h.ServerInitiated, t);\n        }, t.prototype.onTrouterMessageLoss = function (t) {\n          this.logger.debug(\"onTrouterMessageLoss\"), this.fsm.onTrouterMessageLost(t.droppedIndicators);\n        }, t.prototype.onAudienceSubscriptionResult = function (t) {\n          this.logger.info(\"onAudienceSubscriptionResult\"), this.pendingAudienceSubscription && (clearTimeout(this.pendingAudienceSubscription.timeoutId), this.pendingAudienceSubscription.audienceSetResolve(t), this.pendingAudienceSubscription = void 0);\n        }, t.prototype.buildV4cUrlParams = function () {\n          var t = {};\n          return t.tc = encodeURI((0, l.toJson)(this.clientInfo)), t.timeout = Math.floor(this.timeoutOptions.pingTimeoutMs / 1e3), this.options.endpointId && (t.epid = this.options.endpointId), this.appendConnectedClientIds(this.buildQuery(t), !0);\n        }, t.prototype.attachSocketIoHandlers = function (t, e, n, o) {\n          var i = this;\n          t.on(\"connecting\", function (t) {\n            i.onSocketConnecting(t);\n          }), t.on(\"connect\", function () {\n            i.onSocketConnect(e);\n          }), t.on(\"connect_failed\", function (t) {\n            i.onSocketConnectFailed(t);\n          }), t.on(\"close_during_connecting\", function (t) {\n            i.onSocketConnectFailed(t);\n          }), t.on(\"disconnect\", function (t) {\n            i.onSocketDisconnect(t);\n          }), t.on(\"reconnect\", function () {\n            i.onSocketReconnect();\n          }), t.on(\"reconnect_failed\", function (t) {\n            i.onSocketReconnectFailed(t);\n          }), t.on(\"reconnecting\", function () {\n            i.onSocketReconnecting();\n          }), t.on(\"error\", function (t) {\n            i.onSocketError(t);\n          }), t.on(\"message\", function (t) {\n            i.onSocketMessage(t);\n          }), t.on(\"trouter.connected\", function (t) {\n            i.onTrouterConnected(t, n, o);\n          }), t.on(\"trouter.reconnect\", function (t) {\n            i.onTrouterReconnect(t);\n          }), t.on(\"trouter.message_loss\", function (t) {\n            i.onTrouterMessageLoss(t);\n          }), t.on(\"audience.subscriptionresult\", function (t, e) {\n            i.onAudienceSubscriptionResult(e);\n          });\n        }, t.prototype.onNavigatorOnlineStatusUpdate = function () {\n          var t = window.navigator.onLine;\n          this.logger.debug(\"Browser online status update - new state: \".concat(t, \", previously: \").concat(this.isNavigatorOnline)), t && !this.isNavigatorOnline ? (this.isNavigatorOnline = !0, this.tokenBackoff.expediteIfPending(), this.connectionTracker.trackProgress(\"browserNet\", \"online\")) : !t && this.isNavigatorOnline && (this.isNavigatorOnline = !1, this.connectionTracker.trackProgress(\"browserNet\", \"offline\"));\n        }, t.prototype.onAllocationResponse = function (t, e) {\n          this.logger.info(\"Received allocation response \".concat(JSON.stringify(t))), this.allocateResult = t, this.populateAndCacheReconnectParams(this.allocateResult, \"\".concat(this.allocateResult.socketio, \"v4/a\")), this.populateConnectionStateFields(this.allocateResult), this.fsm.onAllocationSucceed(e);\n        }, t.prototype.populateAndCacheReconnectParams = function (t, e) {\n          this.reconnectParams = c({\n            serviceUrl: this.options.trouterUrl,\n            reconnectUrl: e\n          }, t.connectparams), this.manager.onConnectionParametersUpdated(this.reconnectParams);\n        }, t.prototype.populateConnectionStateFields = function (t) {\n          var e,\n            n,\n            o = \"string\" == typeof t.ttl ? parseInt(t.ttl, 10) : t.ttl;\n          if (this.connectionExpireTimestampInSecs = (0, l.calculateExpireTsInSec)(o), this.connectionId = null !== (e = t.id) && void 0 !== e ? e : \"\", this.connectedClientId = t.ccid, this.logger.debug(\"connected client id set {connectedClientId:\".concat(this.connectedClientId, \"}\")), this.c2cUrlBase = null !== (n = t.curlb) && void 0 !== n ? n : \"\", \"\" === this.c2cUrlBase) {\n            var i = t.surl.indexOf(\"://\");\n            i >= 0 && (i = t.surl.indexOf(\"/\", i + 3)) >= 5 && \":3443\" === t.surl.substr(i - 5, 5) && (this.c2cUrlBase = t.surl.substr(0, i - 5));\n          }\n        }, t.prototype.onPingResponse = function () {\n          this.logger.debug(\"onPingResponse\"), this.connectionTracker.increasePingResponseCount(), this.clearPingResponseTimer(), this.fsm.onPingResponse();\n        }, t.prototype.clearPingResponseTimer = function () {\n          void 0 !== this.pingResponseTimerId && (clearTimeout(this.pingResponseTimerId), this.pingResponseTimerId = void 0);\n        }, t.prototype.buildQuery = function (t) {\n          for (var e = [], n = 0, o = Object.keys(t); n < o.length; n++) {\n            var i = o[n];\n            void 0 !== t[i] && e.push(\"\".concat(i, \"=\").concat(t[i]));\n          }\n          return e.join(\"&\");\n        }, t.prototype.appendConnectedClientIds = function (t, e) {\n          var n = \"\";\n          t.includes(\"ccid=\") || (n = \"ccid=\".concat(this.connectedClientId, \"&\")), this.domId && (n += \"dom=\".concat(this.domId, \"&\")), n.length > 0 && (n = n.slice(0, -1));\n          var o = e || t.includes(\"?\") ? \"&\" : \"?\";\n          return this.appendCorrelationIds(t + o + n, e);\n        }, t.prototype.appendEndpointId = function (t, e) {\n          var n = e || t.includes(\"?\") ? \"&\" : \"?\";\n          return !t.includes(\"epid\") && this.options.endpointId ? \"\".concat(t).concat(n, \"epid=\").concat(this.options.endpointId) : t;\n        }, t.prototype.appendCorrelationIds = function (t, e) {\n          var n = e || t.includes(\"?\") ? \"&\" : \"?\";\n          return t.includes(\"cor_id\") ? t : \"\".concat(t).concat(n, \"cor_id=\").concat(this.options.clientCorrelationID) + \"&con_num=\".concat(this.clientID, \"_\").concat(this.connectionAttempt);\n        }, t.prototype.safeString = function (t) {\n          return \"string\" == typeof t ? t : \"\";\n        }, t.prototype.sendResponse = function (t, e) {\n          var n, o, i;\n          if (t.timedout) return this.logger.error(\"Request \".concat(t.id, \" already timed out\")), 1;\n          if (t.replied) return this.logger.error(\"Response for request \".concat(t.id, \" already sent\")), 2;\n          clearTimeout(t.timeoutTimerId), t.timeoutTimerId = void 0, t.replied = !0, e.headers = null !== (n = e.headers) && void 0 !== n ? n : {};\n          var s = t.correlationVector;\n          this.logger.info(\"Sending response N \".concat(t.id, \" CV \").concat(s, \" with status \").concat(e.status)), s && (e.headers[C] = s), (null === (o = t.headers) || void 0 === o ? void 0 : o[\"trouter-request\"]) && (e.headers[\"trouter-request\"] = t.headers[\"trouter-request\"]);\n          var c = Date.now() - t.startTS;\n          if (e.headers[\"trouter-client\"] = (0, l.toJson)({\n            cd: c\n          }), (null === (i = t.headers) || void 0 === i ? void 0 : i[\"trouter-is-broadcast\"]) && (e.headers[\"trouter-is-broadcast\"] = t.headers[\"trouter-is-broadcast\"]), this.logger.debug(\"response: \".concat((0, l.toJson)(e))), !this.socket) return this.connectionTracker.sendResponseError(\"no socket\", t, e), 4;\n          try {\n            return this.socket.send((0, l.toJson)(e)), e.sentTS = Date.now(), t.incrementCorrelationVector(), this.connectionTracker.trackResponse(t, c, e), \"websocket\" === this.transportTypeName && this.sendPingRequest(), 0;\n          } catch (n) {\n            var a = \"unable to send data on response.end. Error: \".concat(r(n));\n            return this.logger.error(a), this.connectionTracker.sendResponseError(a, t, e), 4;\n          }\n        }, t.prototype.sendUserActivityStateMultiple = function (t) {\n          var e = this,\n            n = new A(\"user.activity\"),\n            o = this.userActivityState.increaseCvAndGetEventObject();\n          n.args = o, this.logger.debug(\"Sending user activity '\".concat(this.userActivityState.toEventJSON(), \"', remaining \").concat(t - 1));\n          var i = !1;\n          this.sendDownstreamEvent(n, function () {\n            if (!0 !== i && (e.logger.info(\"User activity state: \".concat(o.state, \", cv: \").concat(o.cv, \" accepted\")), e.manager.onUserActivityStateAccepted(o.cv), e.clearSentEventTimer(n.timeoutTimerId), t > 1)) {\n              var r = setTimeout(function () {\n                e.clearSentEventTimer(r), e.sendUserActivityStateMultiple(t - 1);\n              }, e.options.userActivitySecondResendDelayMs);\n              e.registerSentEventTimer(r, \"user.activity/resend\");\n            }\n          }), n.timeoutTimerId = setTimeout(function () {\n            e.logger.error(\"Activity state response timeout is fired\"), i = !0, e.fsm.onActivityStateResponseTimeout(), e.clearSentEventTimer(n.timeoutTimerId);\n          }, this.timeoutOptions.userActivityResponseTimeoutMs), this.registerSentEventTimer(n.timeoutTimerId, \"user.activity/response\");\n        }, t.prototype.sendDownstreamEvent = function (t, e) {\n          this.logger.debug(\"Sending downstream event \".concat(t.name)), this.socket && this.socket.emit(t.name, t.args, e);\n        }, t.prototype.registerSentEventTimer = function (t, e) {\n          this.logger.debug(\"registering timer \".concat(t, \" -> \").concat(e)), this.pendingSentEventTimers[t] = e;\n        }, t.prototype.clearSentEventTimer = function (t) {\n          var e = this.pendingSentEventTimers[t];\n          this.logger.debug(\"clearing timer \".concat(t, \" -> \").concat(e)), delete this.pendingSentEventTimers[t], clearTimeout(t);\n        }, t.prototype.getRegistrationTtl = function () {\n          var t,\n            e,\n            n = (0, l.calculateTtlInSec)(this.connectionExpireTimestampInSecs);\n          if (this.logger.debug(\"Current connectionID will expire in \".concat(n, \" seconds\")), (null === (t = this.options.registration) || void 0 === t ? void 0 : t.registrarTtlSec) && n > 0) {\n            var o = this.options.registration.registrarTtlSec < n;\n            return [Math.min(this.options.registration.registrarTtlSec, n), o];\n          }\n          return (null === (e = this.options.registration) || void 0 === e ? void 0 : e.registrarTtlSec) ? [this.options.registration.registrarTtlSec, !1] : n > 0 ? [n, !1] : [3600, !1];\n        }, t.prototype.clearIncallModeTimerId = function () {\n          void 0 !== this.incallModeTimerId && (this.logger.debug(\"Clearing in-call mode timer\"), clearTimeout(this.incallModeTimerId), this.incallModeTimerId = void 0);\n        }, t.prototype.applyConnectionTrackerOptions = function (t) {\n          try {\n            t.eventLogger && \"function\" == typeof t.eventLogger.logEvent ? (this.connectionTracker.mergeSettings(t.telemetrySettings), this.connectionTracker.enable(t.eventLogger)) : this.logger.warn(\"Trouter client event logging disabled due to invalid configuration.\");\n          } catch (t) {\n            this.logger.warn(\"Trouter client event logging disabled. Error: \".concat(r(t))), this.connectionTracker.disable();\n          }\n        }, t.prototype.canRetryTokenFetchRequest = function (t) {\n          var e = this.options.retryLimitOnTokenFetch;\n          return null === e || void 0 === e || t < e || (this.logger.warn(\"Reached limit on maximum number of token fetch request. Current count: \".concat(t, \", retry limit: \").concat(e)), !1);\n        }, t;\n      }();\n      e.TrouterConnection = U;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.MessageHandlerRegistry = void 0;\n      var o = n(1),\n        i = n(0),\n        r = function () {\n          function t(t) {\n            this.messageHandlers = [], this.logger = new i.Logger(\"MessageHandlers\", t);\n          }\n          return t.prototype.register = function (t) {\n            if (this.messageHandlers.some(function (e) {\n              return e === t;\n            })) throw new Error(\"Registering the same handler twice is not allowed\");\n            this.messageHandlers.push(t);\n          }, t.prototype.clear = function () {\n            this.logger.debug(\"Clearing message handlers\"), this.messageHandlers = [];\n          }, t.prototype.active = function () {\n            return this.messageHandlers.length > 0;\n          }, t.prototype.handleMessage = function (t) {\n            for (var e = {\n                resultCode: o.UNHANDLED_MESSAGE_ACK,\n                isHandled: !1\n              }, n = 0, i = this.messageHandlers; n < i.length; n++) {\n              var r = i[n],\n                s = this.safeExecuteHandle(r, t);\n              if (void 0 !== s && (void 0 === s.isHandled || s.isHandled)) return void 0 === s.resultCode && (s.resultCode = o.HANDLED_MESSAGE_ACK), s;\n            }\n            return e;\n          }, t.prototype.safeExecuteHandle = function (t, e) {\n            try {\n              return t.handleMessage(e);\n            } catch (t) {\n              return void this.logger.warn(\"Trouter message handler threw an exception: \".concat(t));\n            }\n          }, t;\n        }();\n      e.MessageHandlerRegistry = r;\n    }, function (t, e, n) {\n      function o(t) {\n        var e,\n          n = this;\n        return function (o) {\n          return i(n, void 0, void 0, function () {\n            return r(this, function (n) {\n              return o && (e = void 0), [2, new Promise(function (n, i) {\n                t(o).then(function (t) {\n                  e = t, n(t);\n                }).catch(function (t) {\n                  void 0 !== e && e.length > 0 && n(e), i(t);\n                });\n              })];\n            });\n          });\n        };\n      }\n      var i = this && this.__awaiter || function (t, e, n, o) {\n          function i(t) {\n            return t instanceof n ? t : new n(function (e) {\n              e(t);\n            });\n          }\n          return new (n || (n = Promise))(function (n, r) {\n            function s(t) {\n              try {\n                a(o.next(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function c(t) {\n              try {\n                a(o.throw(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function a(t) {\n              t.done ? n(t.value) : i(t.value).then(s, c);\n            }\n            a((o = o.apply(t, e || [])).next());\n          });\n        },\n        r = this && this.__generator || function (t, e) {\n          function n(t) {\n            return function (e) {\n              return o([t, e]);\n            };\n          }\n          function o(n) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; c && (c = 0, n[0] && (a = 0)), a;) try {\n              if (i = 1, r && (s = 2 & n[0] ? r.return : n[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, n[1])).done) return s;\n              switch (r = 0, s && (n = [2 & n[0], s.value]), n[0]) {\n                case 0:\n                case 1:\n                  s = n;\n                  break;\n                case 4:\n                  return a.label++, {\n                    value: n[1],\n                    done: !1\n                  };\n                case 5:\n                  a.label++, r = n[1], n = [0];\n                  continue;\n                case 7:\n                  n = a.ops.pop(), a.trys.pop();\n                  continue;\n                default:\n                  if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {\n                    a = 0;\n                    continue;\n                  }\n                  if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {\n                    a.label = n[1];\n                    break;\n                  }\n                  if (6 === n[0] && a.label < s[1]) {\n                    a.label = s[1], s = n;\n                    break;\n                  }\n                  if (s && a.label < s[2]) {\n                    a.label = s[2], a.ops.push(n);\n                    break;\n                  }\n                  s[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n              n = e.call(t, a);\n            } catch (t) {\n              n = [6, t], r = 0;\n            } finally {\n              i = s = 0;\n            }\n            if (5 & n[0]) throw n[1];\n            return {\n              value: n[0] ? n[1] : void 0,\n              done: !0\n            };\n          }\n          var i,\n            r,\n            s,\n            c,\n            a = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return c = {\n            next: n(0),\n            throw: n(1),\n            return: n(2)\n          }, \"function\" == typeof Symbol && (c[Symbol.iterator] = function () {\n            return this;\n          }), c;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.addCacheAsBackupTo = void 0, e.addCacheAsBackupTo = o;\n    }, function (t, e, n) {\n      var o = this && this.__awaiter || function (t, e, n, o) {\n          function i(t) {\n            return t instanceof n ? t : new n(function (e) {\n              e(t);\n            });\n          }\n          return new (n || (n = Promise))(function (n, r) {\n            function s(t) {\n              try {\n                a(o.next(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function c(t) {\n              try {\n                a(o.throw(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function a(t) {\n              t.done ? n(t.value) : i(t.value).then(s, c);\n            }\n            a((o = o.apply(t, e || [])).next());\n          });\n        },\n        i = this && this.__generator || function (t, e) {\n          function n(t) {\n            return function (e) {\n              return o([t, e]);\n            };\n          }\n          function o(n) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; c && (c = 0, n[0] && (a = 0)), a;) try {\n              if (i = 1, r && (s = 2 & n[0] ? r.return : n[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, n[1])).done) return s;\n              switch (r = 0, s && (n = [2 & n[0], s.value]), n[0]) {\n                case 0:\n                case 1:\n                  s = n;\n                  break;\n                case 4:\n                  return a.label++, {\n                    value: n[1],\n                    done: !1\n                  };\n                case 5:\n                  a.label++, r = n[1], n = [0];\n                  continue;\n                case 7:\n                  n = a.ops.pop(), a.trys.pop();\n                  continue;\n                default:\n                  if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {\n                    a = 0;\n                    continue;\n                  }\n                  if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {\n                    a.label = n[1];\n                    break;\n                  }\n                  if (6 === n[0] && a.label < s[1]) {\n                    a.label = s[1], s = n;\n                    break;\n                  }\n                  if (s && a.label < s[2]) {\n                    a.label = s[2], a.ops.push(n);\n                    break;\n                  }\n                  s[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n              n = e.call(t, a);\n            } catch (t) {\n              n = [6, t], r = 0;\n            } finally {\n              i = s = 0;\n            }\n            if (5 & n[0]) throw n[1];\n            return {\n              value: n[0] ? n[1] : void 0,\n              done: !0\n            };\n          }\n          var i,\n            r,\n            s,\n            c,\n            a = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return c = {\n            next: n(0),\n            throw: n(1),\n            return: n(2)\n          }, \"function\" == typeof Symbol && (c[Symbol.iterator] = function () {\n            return this;\n          }), c;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterManager = e.AudienceSubscriptionState = e.UserActivityObject = void 0;\n      var r = n(3),\n        s = n(2),\n        c = n(4),\n        a = n(0),\n        u = n(5),\n        h = n(18),\n        d = n(7),\n        l = n(6),\n        p = n(19),\n        g = function () {\n          function t(t, e) {\n            this.state = t, this.correlationVector = void 0 !== e ? e : r.CorrelationVector.extend();\n          }\n          return t.prototype.getStateString = function () {\n            switch (this.state) {\n              case s.UserActivityState.Active:\n                return \"active\";\n              case s.UserActivityState.Inactive:\n                return \"inactive\";\n              case s.UserActivityState.Unknown:\n                return \"unknown\";\n              default:\n                return \"undefined\";\n            }\n          }, t.prototype.increaseCvAndGetEventObject = function () {\n            return this.correlationVector.increase(), this.toEventObject();\n          }, t.prototype.toEventObject = function () {\n            return {\n              state: this.getStateString(),\n              cv: this.correlationVector.value()\n            };\n          }, t.prototype.toEventJSON = function () {\n            return (0, r.toJson)(this.toEventObject());\n          }, t;\n        }();\n      e.UserActivityObject = g;\n      var f = function () {\n        function t(t, e) {\n          void 0 === e && (e = r.CorrelationVector.extend()), this.audienceSubscriptionModel = t, this.correlationVector = e;\n        }\n        return t.prototype.increaseCvAndGetEventObject = function () {\n          return this.correlationVector.increase(), this.toEventObject();\n        }, t.prototype.toEventObject = function () {\n          return {\n            audiences: this.audienceSubscriptionModel.audienceSubscriptions,\n            cv: this.correlationVector.value()\n          };\n        }, t.prototype.toEventJSON = function () {\n          return (0, r.toJson)(this.toEventObject());\n        }, t;\n      }();\n      e.AudienceSubscriptionState = f;\n      var v = function () {\n        function t(t, e, n, o, i, c) {\n          var h = this;\n          this.logFunc = t, this.options = e, this.tokenProvider = n, this.usingLegacyTokenApi = o, this.listener = i, this.tokenTypeProtocolSelector = function (t, e) {\n            return h.options.forceV4aProtocol ? \"v4a\" : (0, u.usedProtocol)(t, e);\n          }, this.logger = new a.Logger(\"Manager\", t), this.logger.info(\"Created TrouterManager with options \".concat((0, r.toJson)(this.options))), this.fsm = new p.TrouterManagerFsm(t, this), this.baseEndpointUrl = \"\", this.processedMessageLoss = {}, this.userActivityObject = new g(s.UserActivityState.Unknown), this.protocolSelector = null !== c && void 0 !== c ? c : this.tokenTypeProtocolSelector.bind(this);\n        }\n        return t.prototype.start = function () {\n          this.fsm.start();\n        }, t.prototype.stop = function (t) {\n          this.fsm.stop(t);\n        }, t.prototype.configure = function (t) {\n          this.options = t, void 0 !== this.firstConnection && this.firstConnection.configure(t), void 0 !== this.secondConnection && this.secondConnection.configure(t), this.logger.info(\"Reconfigured TrouterManager with options \".concat((0, r.toJson)(this.options)));\n        }, t.prototype.checkConnection = function (t) {\n          void 0 !== this.firstConnection && this.firstConnection.checkConnection(t), void 0 !== this.secondConnection && this.secondConnection.checkConnection(t);\n        }, t.prototype.resendRegistration = function () {\n          return o(this, void 0, void 0, function () {\n            return i(this, function (t) {\n              return void 0 !== this.secondConnection ? (this.logger.info(\"Resending registration on the second/new connection\"), [2, this.secondConnection.resendRegistration()]) : void 0 !== this.firstConnection ? (this.logger.info(\"Resending registration on the first/current connection\"), [2, this.firstConnection.resendRegistration()]) : (this.logger.info(\"No connection to resend registration on, will be done upon (re)connect\"), [2]);\n            });\n          });\n        }, t.prototype.getServerState = function () {\n          if (void 0 !== this.firstConnection) return this.firstConnection.getServerState();\n        }, t.prototype.getState = function () {\n          return this.fsm.getState();\n        }, t.prototype.isInTerminalState = function () {\n          return this.fsm.getInternalState() === c.TrouterManagerState.TerminalError;\n        }, t.prototype.reportStateInfo = function () {\n          var t = this.firstConnection ? l.State[this.firstConnection.getState()] : \"Unknown\",\n            e = c.TrouterManagerState[this.fsm.getInternalState()];\n          if (this.secondConnection) {\n            var n = l.State[this.secondConnection.getState()];\n            return \"Manager \".concat(e, \"; 1st \").concat(t, \"; 2nd \").concat(n);\n          }\n          return \"Manager \".concat(e, \"; Connection \").concat(t);\n        }, t.prototype.startFirstConnection = function () {\n          var t = new d.TrouterConnection(this.logFunc, this.options, this.configuredTrouterManager(), this.tokenProvider, this.usingLegacyTokenApi, this.userActivityObject, this.protocolSelector, this.audienceSubscriptionState);\n          this.firstConnection = t, this.getConnectionCache().then(function (e) {\n            t.start(e);\n          }).catch(function () {});\n        }, t.prototype.startSecondConnection = function (t) {\n          var e = new d.TrouterConnection(this.logFunc, this.options, this.configuredTrouterManager(), this.tokenProvider, this.usingLegacyTokenApi, this.userActivityObject, this.protocolSelector, this.audienceSubscriptionState);\n          this.secondConnection = e, void 0 !== this.firstConnection && this.firstConnection.disableRegistrationsAndAutoReconnect(), t ? this.getConnectionCache().then(function (t) {\n            e.start(t);\n          }).catch(function () {}) : e.start();\n        }, t.prototype.stopFirstConnection = function (t) {\n          void 0 !== this.firstConnection && (this.storedFirstConnection = this.firstConnection, this.firstConnection.stop(t), this.firstConnection = void 0);\n        }, t.prototype.stopSecondConnection = function (t) {\n          void 0 !== this.secondConnection && (this.secondConnection.stop(t), this.secondConnection = void 0);\n        }, t.prototype.stopSecondConnectionDelayed = function () {\n          if (void 0 !== this.secondConnection) {\n            var t = this.secondConnection;\n            this.secondConnection = void 0, this.logger.info(\"Closing an inactive connection in \".concat(Math.round(this.options.lingeringConnectionDelayMs / 1e3), \"s\")), setTimeout(function () {\n              t.stop(!0);\n            }, this.options.lingeringConnectionDelayMs);\n          }\n        }, t.prototype.forceStopLingeringConnection = function () {\n          this.storedFirstConnection && (this.storedFirstConnection.stop(!1), this.storedFirstConnection = void 0);\n        }, t.prototype.switchConnections = function () {\n          var t = this.firstConnection;\n          this.firstConnection = this.secondConnection, this.secondConnection = t;\n        }, t.prototype.doesSecondConnectionExist = function () {\n          return void 0 !== this.secondConnection;\n        }, t.prototype.dispatchConnected = function () {\n          if (void 0 !== this.firstConnection) {\n            var t = this.firstConnection.getServerState(),\n              e = t.url.endsWith(\"/\") ? t.url.slice(0, -1) : t.url,\n              n = {\n                baseEndpointUrl: e,\n                newEndpointUrl: e !== this.baseEndpointUrl,\n                c2cUrlBase: t.c2cUrlBase,\n                clientId: t.connectedClientId,\n                connectionId: t.connectionId,\n                connectionTtlSec: t.getRemainingTtlInSec()\n              };\n            this.baseEndpointUrl = e, this.listener.onTrouterConnected(t.url, n);\n          }\n        }, t.prototype.dispatchDisconnected = function () {\n          this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();\n        }, t.prototype.dispatchTerminalError = function () {\n          this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();\n        }, t.prototype.dispatchRegistrationState = function (t) {\n          this.options.registrationStateCallback && this.options.registrationStateCallback(t);\n        }, t.prototype.expediteBackoffOnConnections = function () {\n          var t;\n          if (void 0 !== this.lastExpediteBackoffCallAt && Date.now() - this.lastExpediteBackoffCallAt < (null !== (t = this.options.expediteBackoffOnStartMinimumDelayMs) && void 0 !== t ? t : 1e4)) return void this.logger.info(\"Expedite backoff due to start() too frequent, skipping\");\n          this.lastExpediteBackoffCallAt = Date.now(), void 0 !== this.firstConnection && this.firstConnection.expediteBackoff(), void 0 !== this.secondConnection && this.secondConnection.expediteBackoff();\n        }, t.prototype.onDownstreamRequest = function (t, e, n) {\n          var o = {\n              id: e.id,\n              method: e.method,\n              path: \"/\".concat(e.shortUrl),\n              body: e.body,\n              headers: e.headers\n            },\n            i = {\n              id: e.id,\n              status: 0,\n              headers: {},\n              body: \"\",\n              send: function () {\n                return i.status <= 100 || i.status >= 999 ? 3 : (n.writeHead(i.status, i.headers), n.end(i.body));\n              }\n            };\n          this.listener.onTrouterRequest(o, i);\n        }, t.prototype.onConnected = function (t) {\n          this.fsm.onConnected(t === this.firstConnection);\n        }, t.prototype.onRegistered = function (t) {\n          this.fsm.onRegistered(t === this.firstConnection);\n        }, t.prototype.onUnregistered = function (t) {\n          this.fsm.onUnregistered(t === this.firstConnection || t === this.storedFirstConnection);\n        }, t.prototype.onReconnecting = function (t) {\n          this.fsm.onReconnecting(t === this.firstConnection);\n        }, t.prototype.onReconnectIsRequired = function (t, e, n) {\n          this.fsm.onReconnectionRequired(t === this.firstConnection, e, n);\n        }, t.prototype.onDisconnected = function (t) {\n          this.fsm.onDisconnected(t === this.firstConnection || t == this.storedFirstConnection), this.storedFirstConnection = void 0;\n        }, t.prototype.onTerminalError = function () {\n          this.fsm.onTerminalError(), this.storedFirstConnection = void 0;\n        }, t.prototype.onUserActivityStateAccepted = function (t) {\n          this.listener.onTrouterUserActivityStateAccepted && this.listener.onTrouterUserActivityStateAccepted(t);\n        }, t.prototype.onAudiencesSetResolved = function (t, e) {\n          var n, o;\n          null === (o = (n = this.listener).onAudiencesSetResolved) || void 0 === o || o.call(n, t, e);\n        }, t.prototype.onConnectionParametersUpdated = function (t) {\n          this.setConnectionCache(t);\n        }, t.prototype.setUserActivityState = function (t, e) {\n          return this.userActivityObject = new g(t, r.CorrelationVector.extend(e)), void 0 !== this.secondConnection ? (this.logger.info(\"Setting user activity \".concat(this.userActivityObject.toEventJSON(), \" on the second/new connection\")), void this.secondConnection.setUserActivityState(this.userActivityObject)) : void 0 !== this.firstConnection ? (this.logger.info(\"Setting user activity \".concat(this.userActivityObject.toEventJSON(), \" on the first/current connection\")), void this.firstConnection.setUserActivityState(this.userActivityObject)) : void 0;\n        }, t.prototype.setAudienceSubscriptionsAsync = function (t, e, n) {\n          if (this.audienceSubscriptionState = new f(t, r.CorrelationVector.extend(n)), this.secondConnection) return this.logger.info(\"Setting audience subscriptions \".concat(this.audienceSubscriptionState.toEventJSON(), \" on second/new connection\")), this.secondConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, e);\n          if (this.firstConnection) return this.logger.info(\"Setting audience subscriptions \".concat(this.audienceSubscriptionState.toEventJSON(), \" on first/current connection\")), this.firstConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, e);\n          throw new Error(\"No connection found\");\n        }, t.prototype.onTrouterMessageLost = function (t) {\n          var e = this;\n          if (this.listener.onTrouterMessageLoss) if (null === t || void 0 === t ? void 0 : t.length) {\n            var n = t.filter(function (t) {\n              return void 0 !== e.processedMessageLoss[\"\".concat(t.tag, \"-\").concat(t.etag)];\n            });\n            if (n.length && (this.logger.info(\"onTrouterMessageLoss - immediately acknowledging \".concat(n.length, \" seen dropped indicators\")), this.sendProcessedDroppedIndicators(n), t = t.filter(function (t) {\n              return void 0 === e.processedMessageLoss[\"\".concat(t.tag, \"-\").concat(t.etag)];\n            }), !t.length)) return void this.logger.info(\"onTrouterMessageLoss - all declared dropped indicators have been seen before\");\n            var o = this.listener.onTrouterMessageLoss(t.map(function (t) {\n              return t.tag;\n            }));\n            if (!o) return void this.logger.warn(\"onTrouterMessageLoss - some flow tag(s) have not been processed by listeners\");\n            t.forEach(function (t) {\n              e.processedMessageLoss[\"\".concat(t.tag, \"-\").concat(t.etag)] = \"\";\n            }), this.sendProcessedDroppedIndicators(t);\n          } else this.logger.warn(\"onTrouterMessageLoss - no flow tags have been provided\");\n        }, t.prototype.getConnectionCache = function () {\n          var t = this;\n          return this.options.connectionCache ? (this.logger.debug(\"Querying host's connection cache\"), this.options.connectionCache.onGetTrouterConnectionCache().then(function (t) {\n            var e = t ? JSON.parse(t) : void 0;\n            return \"object\" == typeof e ? e : void 0;\n          }).catch(function (e) {\n            return t.logger.warn(\"Invalid connection cache content provided: \".concat(e)), t.connectionCache;\n          })) : Promise.resolve(this.connectionCache);\n        }, t.prototype.setConnectionCache = function (t) {\n          if (this.connectionCache = t, this.options.connectionCache) try {\n            this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(t));\n          } catch (t) {\n            this.logger.warn(\"Error setting external connection cache: \".concat(t));\n          }\n        }, t.prototype.sendProcessedDroppedIndicators = function (t) {\n          return void 0 !== this.firstConnection ? void this.firstConnection.sendProcessedDroppedIndicators(t) : void 0 !== this.secondConnection ? void this.secondConnection.sendProcessedDroppedIndicators(t) : void 0;\n        }, t.prototype.configuredTrouterManager = function () {\n          return new h.RegistrationEnforcer(this, this.options.connectionDependsOnRegistration, this.options.delayEventsUntilRegistered);\n        }, t;\n      }();\n      e.TrouterManager = v;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterUrlPromise = void 0;\n      var o = n(0),\n        i = function () {\n          function t(t) {\n            this.logger = new o.Logger(\"UrlPromise\", t);\n          }\n          return t.prototype.getPromise = function () {\n            var t = this;\n            return void 0 !== this.url ? (this.logger.debug(\"returning previously resolved url: \".concat(this.url)), Promise.resolve(this.url)) : (void 0 === this.pendingPromise ? (this.logger.debug(\"creating and returning promise\"), this.pendingPromise = new Promise(function (e, n) {\n              t.pendingPromiseResolveRef = e, t.pendingPromiseRejectRef = n;\n            })) : this.logger.debug(\"returning existing promise\"), this.pendingPromise);\n          }, t.prototype.resolveUrl = function (t) {\n            this.url = t, this.logger.debug(\"got url: \".concat(this.url));\n            var e = this.pendingPromiseResolveRef;\n            this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e && (this.logger.debug(\"resolving promise\"), e(t));\n          }, t.prototype.rejectUrl = function (t) {\n            this.logger.debug(\"aborting\");\n            var e = this.pendingPromiseRejectRef;\n            this.url = void 0, this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e && (this.logger.debug(\"rejecting promise\"), e(t));\n          }, t.prototype.resetUrl = function () {\n            this.logger.debug(\"resetting url\"), this.url = void 0;\n          }, t;\n        }();\n      e.TrouterUrlPromise = i;\n    }, function (t, e, n) {\n      (function (t, n) {\n        !function (t, e) {\n          var n = t;\n          n.version = \"0.9.6\", n.protocol = 1, n.transports = [], n.j = [], n.sockets = {}, n.connect = function (t, o) {\n            var i,\n              r,\n              s = n.util.parseUri(t);\n            e && e.location && (s.protocol = s.protocol || e.location.protocol.slice(0, -1), s.host = s.host || (e.document ? e.document.domain : e.location.hostname), s.port = s.port || e.location.port), i = n.util.uniqueUri(s);\n            var c = {\n              host: s.host,\n              secure: \"https\" == s.protocol,\n              port: s.port || (\"https\" == s.protocol ? 443 : 80),\n              query: s.query || \"\"\n            };\n            return n.util.merge(c, o), !c[\"force new connection\"] && n.sockets[i] || (r = new n.Socket(c)), !c[\"force new connection\"] && r && (n.sockets[i] = r), r = r || n.sockets[i], c[\"skipped handshake data\"] ? r.of(\"\") : r.of(s.path.length > 1 ? s.path : \"\");\n          };\n        }(n.exports, void 0 === t ? window : t);\n        var o = n.exports;\n        !function (t, e) {\n          var n = t.util = {},\n            o = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n            i = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n          n.parseUri = function (t) {\n            for (var e = o.exec(t || \"\"), n = {}, r = 14; r--;) n[i[r]] = e[r] || \"\";\n            return n;\n          }, n.uniqueUri = function (t) {\n            var n = t.protocol,\n              o = t.host,\n              i = t.port;\n            return \"document\" in e ? (o = o || document.domain, i = i || (\"https\" == n && \"https:\" !== document.location.protocol ? 443 : document.location.port)) : (o = o || \"localhost\", i || \"https\" != n || (i = 443)), (n || \"http\") + \"://\" + o + \":\" + (i || 80);\n          }, n.query = function (t, e) {\n            var o = n.chunkQuery(t || \"\"),\n              i = [];\n            n.merge(o, n.chunkQuery(e || \"\"));\n            for (var r in o) o.hasOwnProperty(r) && i.push(r + \"=\" + o[r]);\n            return i.length ? \"?\" + i.join(\"&\") : \"\";\n          }, n.chunkQuery = function (t) {\n            for (var e, n = {}, o = t.split(\"&\"), i = 0, r = o.length; i < r; ++i) e = o[i].split(\"=\"), e[0] && (n[e[0]] = e[1]);\n            return n;\n          };\n          var r = !1;\n          n.load = function (t) {\n            if (\"document\" in e && \"complete\" === document.readyState || r) return t();\n            n.on(e, \"load\", t, !1);\n          }, n.on = function (t, e, n, o) {\n            t.attachEvent ? t.attachEvent(\"on\" + e, n) : t.addEventListener && t.addEventListener(e, n, o);\n          }, n.request = function (t) {\n            if (t && \"undefined\" != typeof XDomainRequest) return new XDomainRequest();\n            if (\"undefined\" != typeof XMLHttpRequest && (!t || n.ua.hasCORS)) return new XMLHttpRequest();\n            if (!t) try {\n              return new window[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n            } catch (t) {}\n            return null;\n          }, \"undefined\" != typeof window && n.load(function () {\n            r = !0;\n          }), n.defer = function (t) {\n            if (!n.ua.webkit || \"undefined\" != typeof importScripts) return t();\n            n.load(function () {\n              setTimeout(t, 100);\n            });\n          }, n.merge = function (t, e, o, i) {\n            var r,\n              s = i || [],\n              c = void 0 === o ? 2 : o;\n            for (r in e) e.hasOwnProperty(r) && n.indexOf(s, r) < 0 && (\"object\" == typeof t[r] && c ? n.merge(t[r], e[r], c - 1, s) : (t[r] = e[r], s.push(e[r])));\n            return t;\n          }, n.mixin = function (t, e) {\n            n.merge(t.prototype, e.prototype);\n          }, n.inherit = function (t, e) {\n            function n() {}\n            n.prototype = e.prototype, t.prototype = new n();\n          }, n.isArray = Array.isArray || function (t) {\n            return \"[object Array]\" === Object.prototype.toString.call(t);\n          }, n.intersect = function (t, e) {\n            for (var o = [], i = t.length > e.length ? t : e, r = t.length > e.length ? e : t, s = 0, c = r.length; s < c; s++) ~n.indexOf(i, r[s]) && o.push(r[s]);\n            return o;\n          }, n.indexOf = function (t, e, n) {\n            for (var o = t.length, n = n < 0 ? n + o < 0 ? 0 : n + o : n || 0; n < o && t[n] !== e; n++);\n            return o <= n ? -1 : n;\n          }, n.toArray = function (t) {\n            for (var e = [], n = 0, o = t.length; n < o; n++) e.push(t[n]);\n            return e;\n          }, n.ua = {}, n.ua.hasCORS = \"undefined\" != typeof XMLHttpRequest && function () {\n            try {\n              var t = new XMLHttpRequest();\n            } catch (t) {\n              return !1;\n            }\n            return void 0 != t.withCredentials;\n          }(), n.ua.webkit = \"undefined\" != typeof navigator && /webkit/i.test(navigator.userAgent);\n        }(void 0 !== o ? o : n.exports, void 0 === t ? window : t), function (t, e) {\n          function n() {}\n          t.EventEmitter = n, n.prototype.on = function (t, n) {\n            return this.$events || (this.$events = {}), this.$events[t] ? e.util.isArray(this.$events[t]) ? this.$events[t].push(n) : this.$events[t] = [this.$events[t], n] : this.$events[t] = n, this;\n          }, n.prototype.addListener = n.prototype.on, n.prototype.once = function (t, e) {\n            function n() {\n              o.removeListener(t, n), e.apply(this, arguments);\n            }\n            var o = this;\n            return n.listener = e, this.on(t, n), this;\n          }, n.prototype.removeListener = function (t, n) {\n            if (this.$events && this.$events[t]) {\n              var o = this.$events[t];\n              if (e.util.isArray(o)) {\n                for (var i = -1, r = 0, s = o.length; r < s; r++) if (o[r] === n || o[r].listener && o[r].listener === n) {\n                  i = r;\n                  break;\n                }\n                if (i < 0) return this;\n                o.splice(i, 1), o.length || delete this.$events[t];\n              } else (o === n || o.listener && o.listener === n) && delete this.$events[t];\n            }\n            return this;\n          }, n.prototype.removeAllListeners = function (t) {\n            return this.$events && this.$events[t] && (this.$events[t] = null), this;\n          }, n.prototype.listeners = function (t) {\n            return this.$events || (this.$events = {}), this.$events[t] || (this.$events[t] = []), e.util.isArray(this.$events[t]) || (this.$events[t] = [this.$events[t]]), this.$events[t];\n          }, n.prototype.emit = function (t) {\n            if (!this.$events) return !1;\n            var n = this.$events[t];\n            if (!n) return !1;\n            var o = Array.prototype.slice.call(arguments, 1);\n            if (\"function\" == typeof n) n.apply(this, o);else {\n              if (!e.util.isArray(n)) return !1;\n              for (var i = n.slice(), r = 0, s = i.length; r < s; r++) i[r].apply(this, o);\n            }\n            return !0;\n          };\n        }(void 0 !== o ? o : n.exports, void 0 !== o ? o : n.parent.exports), function (t, e) {\n          if (e && e.parse) return t.JSON = {\n            parse: e.parse,\n            stringify: e.stringify\n          };\n          throw new Error(\"JSON not available\");\n        }(void 0 !== o ? o : n.exports, \"undefined\" != typeof JSON ? JSON : void 0), function (t, e) {\n          var n = t.parser = {},\n            o = n.packets = [\"disconnect\", \"connect\", \"heartbeat\", \"message\", \"json\", \"event\", \"ack\", \"error\", \"noop\"],\n            i = n.reasons = [\"transport not supported\", \"client not handshaken\", \"unauthorized\"],\n            r = n.advice = [\"reconnect\"],\n            s = e.JSON,\n            c = e.util.indexOf;\n          n.encodePacket = function (t) {\n            var e = c(o, t.type),\n              n = t.id || \"\",\n              a = t.endpoint || \"\",\n              u = t.ack,\n              h = null;\n            switch (t.type) {\n              case \"error\":\n                var d = t.reason ? c(i, t.reason) : \"\",\n                  l = t.advice ? c(r, t.advice) : \"\";\n                \"\" === d && \"\" === l || (h = d + (\"\" !== l ? \"+\" + l : \"\"));\n                break;\n              case \"message\":\n                \"\" !== t.data && (h = t.data);\n                break;\n              case \"event\":\n                var p = {\n                  name: t.name\n                };\n                t.args && t.args.length && (p.args = t.args), h = s.stringify(p);\n                break;\n              case \"json\":\n                h = s.stringify(t.data);\n                break;\n              case \"connect\":\n                t.qs && (h = t.qs);\n                break;\n              case \"ack\":\n                h = t.ackId + (t.args && t.args.length ? \"+\" + s.stringify(t.args) : \"\");\n            }\n            var g = [e, n + (\"data\" == u ? \"+\" : \"\"), a];\n            return null !== h && void 0 !== h && g.push(h), g.join(\":\");\n          }, n.encodePayload = function (t) {\n            var e = \"\";\n            if (1 == t.length) return t[0];\n            for (var n = 0, o = t.length; n < o; n++) {\n              e += \"\" + t[n].length + \"\" + t[n];\n            }\n            return e;\n          };\n          var a = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n          n.decodePacket = function (t) {\n            var e = t.match(a);\n            if (!e) return {};\n            var n = e[2] || \"\",\n              t = e[5] || \"\",\n              c = {\n                type: o[e[1]],\n                endpoint: e[4] || \"\"\n              };\n            switch (n && (c.id = n, e[3] ? c.ack = \"data\" : c.ack = !0), c.type) {\n              case \"error\":\n                var e = t.split(\"+\");\n                c.reason = i[e[0]] || \"\", c.advice = r[e[1]] || \"\";\n                break;\n              case \"message\":\n                c.data = t || \"\";\n                break;\n              case \"event\":\n                try {\n                  var u = s.parse(t);\n                  c.name = u.name, c.args = u.args;\n                } catch (t) {}\n                c.args = c.args || [];\n                break;\n              case \"json\":\n                try {\n                  c.data = s.parse(t);\n                } catch (t) {}\n                break;\n              case \"connect\":\n                c.qs = t || \"\";\n                break;\n              case \"ack\":\n                var e = t.match(/^([0-9]+)(\\+)?(.*)/);\n                if (e && (c.ackId = e[1], c.args = [], e[3])) try {\n                  c.args = e[3] ? s.parse(e[3]) : [];\n                } catch (t) {}\n                break;\n              case \"disconnect\":\n                c.reason = t;\n            }\n            return c;\n          }, n.decodePayload = function (t) {\n            if (\"\" == t.charAt(0)) {\n              for (var e = [], o = 1, i = \"\"; o < t.length; o++) \"\" == t.charAt(o) ? (e.push(n.decodePacket(t.substr(o + 1).substr(0, i))), o += Number(i) + 1, i = \"\") : i += t.charAt(o);\n              return e;\n            }\n            return [n.decodePacket(t)];\n          };\n        }(void 0 !== o ? o : n.exports, void 0 !== o ? o : n.parent.exports), function (t, e) {\n          function n(t, e) {\n            this.socket = t, this.sessid = e, this.connectErrorCallback = void 0, this.isOpened = !1;\n          }\n          t.Transport = n, e.util.mixin(n, e.EventEmitter), n.prototype.onData = function (t) {\n            if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), \"\" !== t) {\n              var n = e.parser.decodePayload(t);\n              if (n && n.length) for (var o = 0, i = n.length; o < i; o++) this.onPacket(n[o]);\n            }\n            return this;\n          }, n.prototype.onPacket = function (t) {\n            return this.socket.setHeartbeatTimeout(), \"heartbeat\" == t.type ? this.onHeartbeat() : (\"connect\" == t.type && \"\" == t.endpoint && this.onConnect(), \"error\" == t.type && \"reconnect\" == t.advice && (this.isOpened = !1), this.socket.onPacket(t), this);\n          }, n.prototype.setCloseTimeout = function () {\n            if (!this.closeTimeout) {\n              var t = this;\n              this.closeTimeout = setTimeout(function () {\n                t.onDisconnect();\n              }, this.socket.closeTimeout);\n            }\n          }, n.prototype.onDisconnect = function () {\n            return this.close && this.isOpened && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this;\n          }, n.prototype.onConnect = function () {\n            return this.socket.onConnect(), this.connectErrorCallback = void 0, this;\n          }, n.prototype.clearCloseTimeout = function () {\n            this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);\n          }, n.prototype.clearTimeouts = function () {\n            this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);\n          }, n.prototype.packet = function (t) {\n            this.send(e.parser.encodePacket(t));\n          }, n.prototype.onHeartbeat = function (t) {\n            this.packet({\n              type: \"heartbeat\"\n            });\n          }, n.prototype.onOpen = function () {\n            this.isOpened = !0, this.clearCloseTimeout(), this.socket.onOpen();\n          }, n.prototype.onClose = function () {\n            this.isOpened = !1, this.socket.onClose(), this.onDisconnect();\n          }, n.prototype.prepareUrl = function (t) {\n            var n = this.socket.options;\n            if (n[\"skipped handshake data\"]) return n.rewriteUrlForProxy(n[\"skipped handshake data\"].websocketUrl + (t || \"\"));\n            var o = this.scheme() + \"://\" + n.host + \":\" + n.port + \"/\" + n.resource + \"/\" + e.protocol + \"/\" + this.name + \"/\" + this.sessid + (t || \"\");\n            return n.rewriteUrlForProxy(o);\n          }, n.prototype.ready = function (t, e) {\n            e.call(this);\n          }, n.prototype.clearEventHandlers = function () {\n            return this;\n          };\n        }(void 0 !== o ? o : n.exports, void 0 !== o ? o : n.parent.exports), function (t, e, n) {\n          function o(t) {\n            if (this.options = {\n              port: 80,\n              secure: !1,\n              document: \"document\" in n && document,\n              resource: \"socket.io\",\n              transports: e.transports.slice(),\n              \"connect timeout\": 1e4,\n              \"try multiple transports\": !0,\n              reconnect: !0,\n              \"reconnection delay\": 500,\n              \"reconnection limit\": 1 / 0,\n              \"reopen delay\": 3e3,\n              \"max reconnection attempts\": 10,\n              \"sync disconnect on unload\": !0,\n              \"auto connect\": !0,\n              \"flash policy port\": 10843\n            }, e.util.merge(this.options, t), this.connected = !1, this.open = !1, this.connecting = !1, this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1, this.disconnected = !1, this.options[\"sync disconnect on unload\"] && (!this.isXDomain() || e.util.ua.hasCORS)) {\n              var o = this;\n              e.util.on(n, \"unload\", function () {\n                o.disconnectSync();\n              }, !1);\n            }\n            this.options[\"auto connect\"] && this.connect();\n          }\n          function i() {}\n          t.Socket = o, e.util.mixin(o, e.EventEmitter), o.prototype.of = function (t) {\n            return this.namespaces[t] || (this.namespaces[t] = new e.SocketNamespace(this, t), \"\" !== t && this.namespaces[t].packet({\n              type: \"connect\"\n            })), this.namespaces[t];\n          }, o.prototype.publish = function () {\n            this.emit.apply(this, arguments);\n            var t;\n            for (var e in this.namespaces) this.namespaces.hasOwnProperty(e) && (t = this.of(e), t.$emit.apply(t, arguments));\n          }, o.prototype.handshake = function (t) {\n            function n(e) {\n              e instanceof Error ? o.onError(e.message) : t.apply(null, e.split(\":\"));\n            }\n            var o = this,\n              r = this.options;\n            if (!o.disconnected) {\n              var s = r.rewriteUrlForProxy([\"http\" + (r.secure ? \"s\" : \"\") + \":/\", r.host + \":\" + r.port, r.resource, e.protocol, e.util.query(this.options.query, \"t=\" + +new Date())].join(\"/\"));\n              if (this.isXDomain() && !e.util.ua.hasCORS) {\n                var c = document.getElementsByTagName(\"script\")[0],\n                  a = document.createElement(\"script\");\n                a.src = s + \"&jsonp=\" + e.j.length, c.parentNode.insertBefore(a, c), e.j.push(function (t) {\n                  n(t), a.parentNode.removeChild(a);\n                });\n              } else {\n                var u = e.util.request();\n                u.open(\"GET\", s, !0);\n                var h = this.options.requestHeaders;\n                void 0 !== h && Object.keys(h).forEach(function (t) {\n                  u.setRequestHeader(t, h[t]);\n                }), u.onreadystatechange = function () {\n                  4 == u.readyState && (u.onreadystatechange = i, 200 == u.status ? n(u.responseText) : !o.reconnecting && o.onError(u.responseText));\n                }, u.send(null);\n              }\n            }\n          }, o.prototype.getTransport = function (t) {\n            for (var n, o = t || this.transports, i = 0; n = o[i]; i++) if (e.Transport[n] && e.Transport[n].check(this) && (!this.isXDomain() || e.Transport[n].xdomainCheck())) return new e.Transport[n](this, this.sessionid);\n            return null;\n          }, o.prototype.connect = function (t) {\n            if (this.connecting || this.disconnected) return this;\n            var n = this,\n              o = function (o, i, r, s) {\n                function c() {\n                  if (!n.connected && !n.disconnected) if (n.connecting = !1, clearTimeout(n.connectTimeoutTimer), n.options[\"try multiple transports\"]) {\n                    for (; n.remainingTransports.length > 0 && n.remainingTransports.splice(0, 1)[0] != n.transport.name;);\n                    n.remainingTransports.length ? a(n.remainingTransports) : n.publish(\"connect_failed\");\n                  } else n.publish(\"connect_failed\");\n                }\n                function a(t) {\n                  if (n.transport && (n.transport.clearTimeouts(), n.transport.clearEventHandlers()), n.transport = n.getTransport(t), !n.transport || n.disconnected) return n.publish(\"connect_failed\");\n                  n.transport.ready(n, function () {\n                    n.connecting = !0, n.publish(\"connecting\", n.transport.name), n.transport.open(c), n.options[\"connect timeout\"] && (n.connectTimeoutTimer = setTimeout(function () {\n                      c();\n                    }, n.options[\"connect timeout\"]));\n                  });\n                }\n                n.sessionid = o, n.closeTimeout = 1e3 * r + 2e3, n.heartbeatTimeout = 1e3 * i + 2e3, n.transports = s ? e.util.intersect(s.split(\",\"), n.options.transports) : n.options.transports, n.setHeartbeatTimeout(), n.remainingTransports = n.transports.slice(0), a(n.transports), n.once(\"connect\", function () {\n                  clearTimeout(n.connectTimeoutTimer), t && \"function\" == typeof t && t();\n                });\n              };\n            if (this.options[\"skipped handshake data\"]) {\n              var i = this.options[\"skipped handshake data\"];\n              o(\"v4c-\" + new Date().getTime(), i.timeout, i.timeout, \"websocket\");\n            } else this.handshake(o);\n            return this;\n          }, o.prototype.setHeartbeatTimeout = function () {\n            clearTimeout(this.heartbeatTimeoutTimer);\n            var t = this;\n            this.heartbeatTimeoutTimer = setTimeout(function () {\n              t.transport.onClose();\n            }, this.heartbeatTimeout);\n          }, o.prototype.packet = function (t) {\n            return this.connected && !this.doBuffer ? this.transport.packet(t) : this.buffer.push(t), this;\n          }, o.prototype.setBuffer = function (t) {\n            this.doBuffer = t, !t && this.connected && this.buffer.length && (this.transport.payload(this.buffer), this.buffer = []);\n          }, o.prototype.disconnect = function () {\n            return (this.connected || this.connecting) && (this.open && this.of(\"\").packet({\n              type: \"disconnect\"\n            }), this.onDisconnect(\"booted\")), this.disconnected = !0, this;\n          }, o.prototype.disconnectSync = function () {\n            var t = e.util.request(),\n              n = this.resource + \"/\" + e.protocol + \"/\" + this.sessionid;\n            t.open(\"GET\", n, !0), this.onDisconnect(\"booted\");\n          }, o.prototype.isXDomain = function () {\n            var t = n.location.port || (\"https:\" == n.location.protocol ? 443 : 80);\n            return this.options.host !== n.location.hostname || this.options.port != t;\n          }, o.prototype.onConnect = function () {\n            this.connected || (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), this.emit(\"connect\"));\n          }, o.prototype.onOpen = function () {\n            this.open = !0;\n          }, o.prototype.onClose = function () {\n            this.open = !1, clearTimeout(this.heartbeatTimeoutTimer);\n          }, o.prototype.onPacket = function (t) {\n            this.of(t.endpoint).onPacket(t);\n          }, o.prototype.onError = function (t) {\n            t && t.advice && \"reconnect\" === t.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish(\"error\", t && t.reason ? t.reason : t);\n          }, o.prototype.onDisconnect = function (t) {\n            var e = this.connected,\n              n = this.connecting;\n            this.connected = !1, this.connecting = !1, this.open = !1, (e || n) && (this.transport.close(), this.transport.clearTimeouts(), e ? (this.publish(\"disconnect\", t), \"booted\" != t && this.options.reconnect && !this.reconnecting && this.reconnect()) : this.publish(\"close_during_connecting\", t));\n          }, o.prototype.reconnect = function () {\n            function t() {\n              if (n.connected) {\n                for (var t in n.namespaces) n.namespaces.hasOwnProperty(t) && \"\" !== t && n.namespaces[t].packet({\n                  type: \"connect\"\n                });\n                n.publish(\"reconnect\", n.transport.name, n.reconnectionAttempts);\n              }\n              clearTimeout(n.reconnectionTimer), n.removeListener(\"connect_failed\", e), n.removeListener(\"connect\", e), n.reconnecting = !1, delete n.reconnectionAttempts, delete n.reconnectionDelay, delete n.reconnectionTimer, delete n.redoTransports, n.options[\"try multiple transports\"] = i;\n            }\n            function e() {\n              if (n.reconnecting) return n.connected ? t() : n.connecting && n.reconnecting ? n.reconnectionTimer = setTimeout(e, 1e3) : void (n.reconnectionAttempts++ >= o ? n.redoTransports ? (n.publish(\"reconnect_failed\"), t()) : (n.on(\"connect_failed\", e), n.options[\"try multiple transports\"] = !0, n.transport = n.getTransport(), n.redoTransports = !0, n.connect()) : (n.reconnectionDelay < r && (n.reconnectionDelay *= 2), n.connect(), n.publish(\"reconnecting\", n.reconnectionDelay, n.reconnectionAttempts), n.reconnectionTimer = setTimeout(e, n.reconnectionDelay)));\n            }\n            this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options[\"reconnection delay\"];\n            var n = this,\n              o = this.options[\"max reconnection attempts\"],\n              i = this.options[\"try multiple transports\"],\n              r = this.options[\"reconnection limit\"];\n            this.options[\"try multiple transports\"] = !1, this.reconnectionTimer = setTimeout(e, this.reconnectionDelay), this.on(\"connect\", e);\n          };\n        }(void 0 !== o ? o : n.exports, void 0 !== o ? o : n.parent.exports, void 0 === t ? window : t), function (t, e) {\n          function n(t, e) {\n            this.socket = t, this.name = e || \"\", this.flags = {}, this.json = new o(this, \"json\"), this.ackPackets = 0, this.acks = {};\n          }\n          function o(t, e) {\n            this.namespace = t, this.name = e;\n          }\n          t.SocketNamespace = n, e.util.mixin(n, e.EventEmitter), n.prototype.$emit = e.EventEmitter.prototype.emit, n.prototype.of = function () {\n            return this.socket.of.apply(this.socket, arguments);\n          }, n.prototype.packet = function (t) {\n            return t.endpoint = this.name, this.socket.packet(t), this.flags = {}, this;\n          }, n.prototype.send = function (t, e) {\n            var n = {\n              type: this.flags.json ? \"json\" : \"message\",\n              data: t\n            };\n            return \"function\" == typeof e && (n.id = ++this.ackPackets, n.ack = !0, this.acks[n.id] = e), this.packet(n);\n          }, n.prototype.emit = function (t) {\n            var e = Array.prototype.slice.call(arguments, 1),\n              n = e[e.length - 1],\n              o = {\n                type: \"event\",\n                name: t\n              };\n            return \"function\" == typeof n && (o.id = ++this.ackPackets, o.ack = \"data\", this.acks[o.id] = n, e = e.slice(0, e.length - 1)), o.args = e, this.packet(o);\n          }, n.prototype.disconnect = function () {\n            return \"\" === this.name ? this.socket.disconnect() : (this.packet({\n              type: \"disconnect\"\n            }), this.$emit(\"disconnect\")), this;\n          }, n.prototype.onPacket = function (t) {\n            function n() {\n              o.packet({\n                type: \"ack\",\n                args: e.util.toArray(arguments),\n                ackId: t.id\n              });\n            }\n            var o = this;\n            switch (t.type) {\n              case \"connect\":\n                this.$emit(\"connect\");\n                break;\n              case \"disconnect\":\n                \"\" === this.name ? this.socket.onDisconnect(t.reason || \"booted\") : this.$emit(\"disconnect\", t.reason || \"\");\n                break;\n              case \"message\":\n              case \"json\":\n                var i = [\"message\", t.data];\n                \"data\" == t.ack ? i.push(n) : t.ack && this.packet({\n                  type: \"ack\",\n                  ackId: t.id\n                }), this.$emit.apply(this, i);\n                break;\n              case \"event\":\n                var i = [t.name].concat(t.args);\n                \"data\" == t.ack && i.push(n), this.$emit.apply(this, i);\n                break;\n              case \"ack\":\n                this.acks[t.ackId] && (this.acks[t.ackId].apply(this, t.args), delete this.acks[t.ackId]);\n                break;\n              case \"error\":\n                t.advice ? this.socket.onError(t) : \"unauthorized\" == t.reason ? this.$emit(\"connect_failed\", t.reason) : this.$emit(\"error\", t.reason);\n            }\n          }, o.prototype.send = function () {\n            this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments);\n          }, o.prototype.emit = function () {\n            this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments);\n          };\n        }(void 0 !== o ? o : n.exports, void 0 !== o ? o : n.parent.exports), function (t, e, n) {\n          function o(t) {\n            e.Transport.apply(this, arguments);\n          }\n          function i() {}\n          t.websocket = o, e.util.inherit(o, e.Transport), o.prototype.name = \"websocket\", o.prototype.open = function (t) {\n            var o,\n              i = e.util.query(this.socket.options.query),\n              r = this;\n            return this.connectErrorCallback = t, o || (o = n.MozWebSocket || n.WebSocket), this.websocket = new o(this.prepareUrl(i)), this.websocket.onopen = function () {\n              r.onOpen(), r.socket.setBuffer(!1);\n            }, this.websocket.onmessage = function (t) {\n              r.onData(t.data);\n            }, this.websocket.onclose = function () {\n              r.onClose(), r.socket.setBuffer(!0);\n            }, this.websocket.onerror = function (t) {\n              r.onError(t);\n            }, this;\n          }, o.prototype.send = function (t) {\n            return this.websocket.send(t), this;\n          }, o.prototype.payload = function (t) {\n            for (var e = 0, n = t.length; e < n; e++) this.packet(t[e]);\n            return this;\n          }, o.prototype.close = function () {\n            return this.websocket.close(), this;\n          }, o.prototype.onError = function (t) {\n            void 0 !== this.connectErrorCallback && (this.connectErrorCallback(), this.connectErrorCallback = void 0), this.socket.onError(t);\n          }, o.prototype.scheme = function () {\n            return this.socket.options.secure ? \"wss\" : \"ws\";\n          }, o.check = function () {\n            return \"WebSocket\" in n && !(\"__addTask\" in WebSocket) || \"MozWebSocket\" in n;\n          }, o.xdomainCheck = function () {\n            return !0;\n          }, o.prototype.clearEventHandlers = function () {\n            return this.websocket && (this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = i), this;\n          }, e.transports.push(\"websocket\");\n        }(void 0 !== o ? o.Transport : n.exports, void 0 !== o ? o : n.parent.exports, void 0 === t ? window : t), function (t, e, n) {\n          function o(t) {\n            t && e.Transport.apply(this, arguments);\n          }\n          function i() {}\n          t.XHR = o, e.util.inherit(o, e.Transport), o.prototype.open = function () {\n            return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), this;\n          }, o.prototype.payload = function (t) {\n            for (var n = [], o = 0, i = t.length; o < i; o++) n.push(e.parser.encodePacket(t[o]));\n            this.send(e.parser.encodePayload(n));\n          }, o.prototype.send = function (t) {\n            return this.post(t), this;\n          }, o.prototype.post = function (t) {\n            function e() {\n              4 == this.readyState && (this.onreadystatechange = i, 200 == this.status ? (clearTimeout(this.ackTimeoutTimer), r.socket.setBuffer(!1)) : r.onClose());\n            }\n            function o() {\n              this.onload = i, r.socket.setBuffer(!1);\n            }\n            var r = this;\n            this.socket.setBuffer(!0), this.sendXHR = this.request(\"POST\"), n.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = o : this.sendXHR.onreadystatechange = e, this.sendXHR.send(t), r.sendXHR.ackTimeoutTimer = setTimeout(function () {\n              r.onClose();\n            }, r.socket.options.ackTimeoutMs);\n          }, o.prototype.close = function () {\n            return this.onClose(), this;\n          }, o.prototype.request = function (t) {\n            var n = e.util.request(this.socket.isXDomain()),\n              o = e.util.query(this.socket.options.query, \"t=\" + +new Date());\n            n.open(t || \"GET\", this.prepareUrl(o), !0);\n            var i = this.socket.options.requestHeaders;\n            if (void 0 !== i && Object.keys(i).forEach(function (t) {\n              n.setRequestHeader(t, i[t]);\n            }), \"POST\" == t) try {\n              n.setRequestHeader ? n.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\") : n.contentType = \"text/plain\";\n            } catch (t) {}\n            return n;\n          }, o.prototype.scheme = function () {\n            return this.socket.options.secure ? \"https\" : \"http\";\n          }, o.check = function (t, o) {\n            try {\n              var i = e.util.request(o),\n                r = n.XDomainRequest && i instanceof XDomainRequest,\n                s = t && t.options && t.options.secure ? \"https:\" : \"http:\",\n                c = s != n.location.protocol;\n              if (i && (!r || !c)) return !0;\n            } catch (t) {}\n            return !1;\n          }, o.xdomainCheck = function () {\n            return o.check(null, !0);\n          }, o.prototype.clearEventHandlers = function () {\n            return this.sendXHR && (this.sendXHR.onreadystatechange = this.sendXHR.onload = i), this;\n          };\n        }(void 0 !== o ? o.Transport : n.exports, void 0 !== o ? o : n.parent.exports, void 0 === t ? window : t), function (t, e, n) {\n          function o() {\n            e.Transport.XHR.apply(this, arguments);\n          }\n          function i() {}\n          t[\"xhr-polling\"] = o, e.util.inherit(o, e.Transport.XHR), e.util.merge(o, e.Transport.XHR), o.prototype.name = \"xhr-polling\", o.prototype.open = function (t) {\n            var n = this;\n            return n.connectErrorCallback = t, e.Transport.XHR.prototype.open.call(n), !1;\n          }, o.prototype.get = function () {\n            function t() {\n              4 == this.readyState && (this.onreadystatechange = i, 200 == this.status ? (r.connectErrorCallback = void 0, r.onData(this.responseText), r.get()) : (r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0)));\n            }\n            function e() {\n              r.connectErrorCallback = void 0, this.onload = i, this.onerror = i, r.onData(this.responseText), r.get();\n            }\n            function o() {\n              r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0);\n            }\n            if (this.isOpened) {\n              var r = this;\n              this.xhr = this.request(), n.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = e, this.xhr.onerror = o) : this.xhr.onreadystatechange = t, this.xhr.send(null);\n            }\n          }, o.prototype.onClose = function () {\n            if (e.Transport.XHR.prototype.onClose.call(this), this.xhr) {\n              this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i;\n              try {\n                this.xhr.abort();\n              } catch (t) {}\n              this.xhr = null;\n            }\n          }, o.prototype.ready = function (t, n) {\n            var o = this;\n            e.util.defer(function () {\n              n.call(o);\n            });\n          }, o.prototype.clearEventHandlers = function () {\n            return e.Transport.XHR.prototype.clearEventHandlers.call(this), this.xhr && (this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i), this;\n          }, e.transports.push(\"xhr-polling\");\n        }(void 0 !== o ? o.Transport : n.exports, void 0 !== o ? o : n.parent.exports, void 0 === t ? window : t), e.io = o;\n      }).call(e, n(13), n(14)(t));\n    }, function (t, e) {\n      var n;\n      n = function () {\n        return this;\n      }();\n      try {\n        n = n || Function(\"return this\")() || (0, eval)(\"this\");\n      } catch (t) {\n        \"object\" == typeof window && (n = window);\n      }\n      t.exports = n;\n    }, function (t, e) {\n      t.exports = function (t) {\n        return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, \"loaded\", {\n          enumerable: !0,\n          get: function () {\n            return t.l;\n          }\n        }), Object.defineProperty(t, \"id\", {\n          enumerable: !0,\n          get: function () {\n            return t.i;\n          }\n        }), t.webpackPolyfill = 1), t;\n      };\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.ConnectionTracker = e.Properties = e.TrackerStep = e.ClientEventName = e.ResponseData = void 0;\n      var o = n(3),\n        i = n(1),\n        r = n(0),\n        s = function () {\n          function t(t) {\n            this.id = t, this.status = 200, this.headers = {}, this.body = \"\";\n          }\n          return t;\n        }();\n      e.ResponseData = s;\n      var c;\n      !function (t) {\n        t.Connected = \"trouter_js_client_connected\", t.Disconnected = \"trouter_js_client_disconnected\", t.Error = \"trouter_js_client_error\", t.Progress = \"trouter_js_client_progress\", t.Response = \"trouter_js_client_response\", t.Request = \"trouter_js_client_request\", t.CheckConnection = \"trouter_js_client_check_connection\", t.Registration = \"trouter_js_client_registration\", t.Unregistration = \"trouter_js_client_unregistration\";\n      }(c || (e.ClientEventName = c = {}));\n      var a = function () {\n        function t(t, e, n, o, i) {\n          this.stepName = t, this.operation = e, this.delta = n, this.ts = o, this.error = i;\n        }\n        return t;\n      }();\n      e.TrackerStep = a;\n      var u = function () {\n        function t() {}\n        return t;\n      }();\n      e.Properties = u;\n      var h = function () {\n          function t() {\n            this.numberOfPingReplies = 0, this.connectedTimestamp = 0, this.isNewUrl = !1, this.transportType = \"\", this.connectionNumber = 0;\n          }\n          return t;\n        }(),\n        d = function () {\n          function t() {\n            this.enabled = !1, this.numberOfStepsToMaintain = 40, this.logHealthCheckError = !1, this.sendProgressTimeoutSecs = 55, this.logSendPingError = !1, this.maxBackoffInMs = 12e4, this.trouter_js_client_connected = !1, this.trouter_js_client_disconnected = !1, this.trouter_js_client_error = !1, this.trouter_js_client_progress = !1, this.trouter_js_client_response = !1, this.trouter_js_client_request = !1, this.trouter_js_client_registration = !1, this.trouter_js_client_unregistration = !1, this.trouter_js_client_check_connection = !0;\n          }\n          return t;\n        }(),\n        l = function () {\n          function t(t, e, n, i, s, c, a) {\n            this.clientId = e, this.clientInfo = n, this.getServerState = i, this.endpointId = s, this.clientCorrelationID = c, this.environment = a, this.logger = new r.Logger(\"ConnectionTracker\", t), this.clientCorrelationID = void 0 !== c ? c : \"\", this.steps = [], this.connectionAttempt = 0, this.totalStepCount = 0, this.beginTimestamp = new o.Timespan(), this.eventLogSettings = new d(), this.connectedInfo = new h();\n          }\n          return t.prototype.enable = function (t) {\n            this.eventLogSettings.enabled = !0, this.eventLogger = t;\n          }, t.prototype.disable = function () {\n            this.eventLogSettings.enabled = !1;\n          }, t.prototype.sendProgress = function (t) {\n            this.steps.length > 0 && this.sendTelemetry(c.Progress, t, this.steps);\n          }, t.prototype.cancelProgressTimer = function () {\n            void 0 !== this.progressTimeout && (clearTimeout(this.progressTimeout), this.progressTimeout = void 0);\n          }, t.prototype.resetProgressSendTimer = function () {\n            var t = this;\n            this.cancelProgressTimer(), void 0 !== this.eventLogSettings.sendProgressTimeoutSecs && this.eventLogSettings.sendProgressTimeoutSecs > 0 && (this.progressTimeout = setTimeout(function () {\n              t.sendProgress({\n                reason: \"timeout\",\n                timeoutSecs: t.eventLogSettings.sendProgressTimeoutSecs\n              });\n            }, 1e3 * this.eventLogSettings.sendProgressTimeoutSecs));\n          }, t.prototype.setConnectedInfo = function (t, e) {\n            this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = Date.now(), this.connectedInfo.isNewUrl = t, this.connectedInfo.transportType = e, ++this.connectedInfo.connectionNumber;\n          }, t.prototype.clearConnectedInfo = function () {\n            this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = 0, this.connectedInfo.isNewUrl = !0, this.connectedInfo.transportType = \"\";\n          }, t.prototype.copyProperties = function (t, e) {\n            for (var n = 0, o = Object.keys(e); n < o.length; n++) {\n              var i = o[n];\n              void 0 !== e[i] && (t[i.replace(/-/g, \"_\")] = {\n                value: e[i]\n              });\n            }\n          }, t.prototype.increasePingResponseCount = function () {\n            ++this.connectedInfo.numberOfPingReplies;\n          }, t.prototype.sendTelemetry = function (t, e, n) {\n            try {\n              if (!0 === this.eventLogSettings.enabled && !0 === this.eventLogSettings[t] && void 0 !== this.eventLogger) {\n                var r = this.getServerState(),\n                  s = {\n                    name: t,\n                    properties: {\n                      connectionAttempt: {\n                        value: this.connectionAttempt\n                      },\n                      epid: {\n                        value: this.endpointId\n                      },\n                      clientCorrelationID: {\n                        value: this.clientCorrelationID\n                      },\n                      steps: {\n                        value: (0, o.toJson)(n)\n                      },\n                      clientID: {\n                        value: this.clientId\n                      },\n                      eventVersion: {\n                        value: 3\n                      },\n                      environment: {\n                        value: this.environment\n                      },\n                      cv: {\n                        value: i.CLIENT_VERSION\n                      },\n                      ua: {\n                        value: this.clientInfo.ua\n                      },\n                      connectionId: {\n                        value: r.connectionId\n                      },\n                      connectedClientId: {\n                        value: r.connectedClientId\n                      },\n                      domId: {\n                        value: r.domId\n                      },\n                      url: {\n                        value: r.unsecureUrl\n                      },\n                      surl: {\n                        value: r.url\n                      },\n                      ttlInSecs: {\n                        value: r.getRemainingTtlInSec()\n                      },\n                      numberOfPingReplies: {\n                        value: this.connectedInfo.numberOfPingReplies\n                      },\n                      connectedTimestamp: {\n                        value: this.connectedInfo.connectedTimestamp\n                      },\n                      isNewUrl: {\n                        value: this.connectedInfo.isNewUrl\n                      },\n                      transportType: {\n                        value: this.connectedInfo.transportType\n                      },\n                      connectionNumber: {\n                        value: this.connectedInfo.connectionNumber\n                      }\n                    }\n                  };\n                this.copyProperties(s.properties, e), this.eventLogger.logEvent(s);\n              }\n            } catch (e) {\n              this.logger.warn(\"error in sending event \".concat(t, \": \").concat((0, o.toJson)(e)));\n            }\n          }, t.prototype.createStep = function (t, e, n) {\n            return new a(t, e, this.beginTimestamp.duration, Date.now(), n);\n          }, t.prototype.addStep = function (t, e, n) {\n            if (!1 !== this.eventLogSettings.enabled && (0 === this.steps.length && this.beginTimestamp.reset(), this.steps.push(this.createStep(t, e, n)), ++this.totalStepCount, void 0 !== this.eventLogSettings.numberOfStepsToMaintain && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain)) {\n              var o = this.steps.slice(0);\n              this.steps.length = 0, this.sendTelemetry(c.Progress, {\n                reason: \"flush\"\n              }, o);\n            }\n          }, t.prototype.trackStart = function (t) {\n            this.addStep(t, \"start\");\n          }, t.prototype.trackEnd = function (t) {\n            this.addStep(t, \"end\");\n          }, t.prototype.trackError = function (t, e, n, o) {\n            void 0 === n && (n = !0), \"health\" === t && !0 !== this.eventLogSettings.logHealthCheckError || \"ping\" === t && !1 === this.eventLogSettings.logSendPingError || (void 0 === o && (o = \"error\"), !0 === n && this.addStep(t, o, e), this.sendTelemetry(c.Error, {}, [this.createStep(t, o, e)]));\n          }, t.prototype.trackProgress = function (t, e) {\n            this.addStep(t, e);\n          }, t.prototype.trackConnected = function (t, e) {\n            this.setConnectedInfo(t, e);\n            var n = this.steps.slice(0),\n              o = this.totalStepCount,\n              i = this.beginTimestamp.duration;\n            this.steps.length = 0, this.totalStepCount = 0, this.sendTelemetry(c.Connected, {\n              stepCount: n.length,\n              totalStepCount: o,\n              connectionEstablishmentMs_Total: i\n            }, n), this.cancelProgressTimer();\n          }, t.prototype.getSessionLength = function () {\n            return Date.now() - this.connectedInfo.connectedTimestamp;\n          }, t.prototype.trackDisconnected = function (t) {\n            t.sessionLengthMS = this.getSessionLength(), this.sendTelemetry(c.Disconnected, t, []), this.resetProgressSendTimer();\n          }, t.prototype.trackNewConnection = function () {\n            ++this.connectionAttempt;\n          }, t.prototype.trackRequest = function (t, e) {\n            var n = {};\n            void 0 !== e && (n.hasError = !0, n.error = e);\n            try {\n              if (t) {\n                n.requestID = t.id, n.httpMethod = t.method, n.url = t.url, n.bodyLength = t.body.length, n.shortUrl = t.shortUrl, n.requestTimeStamp = t.startTS, n.correlationVector = t.correlationVector;\n                for (var i = t.headers, r = 0, s = Object.keys(i); r < s.length; r++) {\n                  var a = s[r];\n                  n[a] = i[a];\n                }\n              }\n            } catch (t) {\n              n.hasError = !0, n.error = \"\".concat(n.error, \" error creating request context \").concat((0, o.toJson)(t));\n            }\n            this.sendTelemetry(c.Request, n, []);\n          }, t.prototype.trackResponse = function (t, e, n, i) {\n            var r = {};\n            void 0 !== i && (r.hasError = !0, r.error = i);\n            try {\n              if (r.responseTimestamp = void 0 !== n ? n.sentTS : Date.now(), t) {\n                r.requestID = t.id, r.httpMethod = t.method, r.shortUrl = t.shortUrl, r.correlationVector = t.correlationVector;\n                for (var s = t.headers, a = 0, u = Object.keys(s); a < u.length; a++) {\n                  var h = u[a];\n                  r[h] = s[h];\n                }\n              }\n              n && (r.latencyMS = e, r.responseCode = n.status, r.responseLength = n.body.length);\n            } catch (t) {\n              r.hasError = !0, r.error = \"\".concat(r.error, \" error creating response context \").concat((0, o.toJson)(t));\n            }\n            this.sendTelemetry(c.Response, r, []);\n          }, t.prototype.sendResponseError = function (t, e, n) {\n            this.trackResponse(e, void 0, n, t);\n          }, t.prototype.close = function () {\n            this.sendProgress({\n              reason: \"closed\"\n            }), this.steps.length = 0, this.cancelProgressTimer();\n          }, t.prototype.mergeSettings = function (t) {\n            if (t) {\n              this.eventLogSettings.numberOfStepsToMaintain = Math.min(40, Math.max(10, void 0 !== t.numberOfStepsToMaintain ? t.numberOfStepsToMaintain : 0));\n              var e = Math.min(3600, Math.max(55, void 0 !== t.sendProgressTimeoutSecs ? t.sendProgressTimeoutSecs : 0));\n              this.eventLogSettings.logHealthCheckError = t.logHealthCheckError, this.eventLogSettings.logSendPingError = t.logSendPingError;\n              for (var n = 0, o = Object.keys(c).map(function (t) {\n                  return c[t];\n                }); n < o.length; n++) {\n                var i = o[n];\n                void 0 !== t[i] && (this.eventLogSettings[i] = t[i]);\n              }\n              this.eventLogSettings.sendProgressTimeoutSecs !== e && (this.eventLogSettings.sendProgressTimeoutSecs = e, this.resetProgressSendTimer());\n            }\n          }, t;\n        }();\n      e.ConnectionTracker = l;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.DisconnectReason = void 0;\n      var o = function () {\n        function t(t, e, n) {\n          this.reason = t, this.claims = e, this.details = n;\n        }\n        return t.fromRawReason = function (e, n) {\n          if (\"\" === e || \"dup\" === e) return new t(e);\n          try {\n            var o = JSON.parse(e);\n            return \"object\" != typeof o || void 0 === o.reason ? (null === n || void 0 === n || n.error(\"invalid disconnect reason format\"), new t(\"unknown\", void 0, e)) : new t(o.reason, o.claims, o.details);\n          } catch (n) {\n            return new t(\"disconnect\", void 0, e);\n          }\n        }, t.fromSocketIoEventData = function (e, n) {\n          return \"string\" == typeof n ? new t(e, void 0, n) : void 0;\n        }, t.prototype.toTelemetryString = function () {\n          return \"socketerror\" === this.reason || \"reconnecterror\" === this.reason || \"disconnect\" === this.reason ? this.details : this.reason;\n        }, t;\n      }();\n      e.DisconnectReason = o;\n    }, function (t, e, n) {\n      function o(t, e, n) {\n        if (void 0 === t || void 0 === e) return !1;\n        var o = Date.now() - t;\n        return o > e * n.tolerance && o > n.minimumWaitMs;\n      }\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.ExponentialBackoff = void 0;\n      var i = function () {\n        function t(t, e, n) {\n          void 0 === n && (n = {\n            tolerance: 2,\n            minimumWaitMs: 1e4\n          }), this.logger = t, this.maxBackoffInMs = e, this.gapDetectionSettings = n, this.backoffId = 0, this.backoffCount = 0;\n        }\n        return t.calculateNextBackoffMs = function (t, e) {\n          var n = 1 + .4 * (Math.random() - .5),\n            o = 1e3 * Math.pow(2, t) * n;\n          return o = Math.round(o), Math.min(e, o);\n        }, t.prototype.setMaxBackoffMs = function (t) {\n          this.maxBackoffInMs = t;\n        }, t.prototype.backoff = function (e, n) {\n          var i = this;\n          if (void 0 !== this.timerHandle && (this.logger.debug(\"Clearing current back off\"), clearTimeout(this.timerHandle), this.timerHandle = void 0), void 0 !== this.previousCompleteTime) {\n            var r = Date.now() - this.previousCompleteTime;\n            r > this.maxBackoffInMs * this.gapDetectionSettings.tolerance && r > this.gapDetectionSettings.minimumWaitMs && (this.logger.info(\"Back off for \".concat(e, \" with ID \").concat(this.backoffId, \" will be reset due to a lot of time having passed since the previous backoff (\").concat(r, \" ms)\")), this.backoffCount = 0, this.previousCompleteTime = void 0);\n          }\n          var s = t.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);\n          this.backoffId++, this.backoffCount++, this.logger.info(\"Backing off \".concat(e, \" for \").concat(s, \" milliseconds with ID \").concat(this.backoffId)), this.callback = function (t, r) {\n            o(t, r, i.gapDetectionSettings) && (i.logger.info(\"Back off for \".concat(e, \" with ID \").concat(i.backoffId, \" will be reset due to the wait (\").concat(Date.now() - (null !== t && void 0 !== t ? t : 0), \" ms) being longer than expected (\").concat(r, \" ms)\")), i.backoffCount = 0), i.logger.info(\"Back off for \".concat(e, \" with ID \").concat(i.backoffId, \" complete, invoking handler\")), i.timerHandle = void 0, i.callback = void 0, i.previousCompleteTime = Date.now(), n();\n          };\n          var c = Date.now();\n          this.timerHandle = setTimeout(function () {\n            var t;\n            return null === (t = i.callback) || void 0 === t ? void 0 : t.call(i, c, s);\n          }, s);\n        }, t.prototype.reset = function () {\n          void 0 !== this.timerHandle && (this.logger.debug(\"Resetting back off with ID \".concat(this.backoffId)), clearTimeout(this.timerHandle), this.timerHandle = void 0, this.callback = void 0), this.backoffCount = 0;\n        }, t.prototype.expediteIfPending = function () {\n          if (this.backoffCount = 0, void 0 !== this.timerHandle) {\n            this.logger.debug(\"Expediting back off with ID \".concat(this.backoffId)), clearTimeout(this.timerHandle), this.timerHandle = void 0;\n            var t = this.callback;\n            this.callback = void 0, t && t();\n          }\n        }, t;\n      }();\n      e.ExponentialBackoff = i;\n    }, function (t, e, n) {\n      var o = this && this.__spreadArray || function (t, e, n) {\n        if (n || 2 === arguments.length) for (var o, i = 0, r = e.length; i < r; i++) !o && i in e || (o || (o = Array.prototype.slice.call(e, 0, i)), o[i] = e[i]);\n        return t.concat(o || Array.prototype.slice.call(e));\n      };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.LoggingManagerConsumer = e.RegistrationEnforcer = void 0;\n      var i = n(6),\n        r = function () {\n          function t(t, e, n) {\n            this.wrapped = t, this.shouldConnectionDependOnRegistration = e, this.shouldHoldBackEvents = n, this.isRegistered = !1, this.heldBackEvents = [];\n          }\n          return t.prototype.onDownstreamRequest = function (t, e, n) {\n            this.passIfRegisteredOrNotNeeded(\"onDownstreamRequest\", t, e, n);\n          }, t.prototype.onConnected = function (t) {\n            this.passIfRegisteredOrNotNeeded(\"onConnected\", t);\n          }, t.prototype.onRegistered = function (t) {\n            this.isRegistered = !0, this.wrapped.onRegistered(t), this.fireHeldBackEvents();\n          }, t.prototype.onUnregistered = function (t) {\n            this.isRegistered = !1, this.wrapped.onUnregistered(t), t.getState() === i.State.Connected && this.shouldConnectionDependOnRegistration() && t.forceReconnectDueToNoRegistration();\n          }, t.prototype.onReconnecting = function (t) {\n            this.wrapped.onReconnecting(t);\n          }, t.prototype.onReconnectIsRequired = function (t, e, n) {\n            this.wrapped.onReconnectIsRequired(t, e, n);\n          }, t.prototype.onDisconnected = function (t) {\n            this.isRegistered = !1, this.dropHeldBackEvents(), this.wrapped.onDisconnected(t);\n          }, t.prototype.onTerminalError = function (t) {\n            this.wrapped.onTerminalError(t);\n          }, t.prototype.onConnectionParametersUpdated = function (t) {\n            this.wrapped.onConnectionParametersUpdated(t);\n          }, t.prototype.onTrouterMessageLost = function (t) {\n            this.passIfRegisteredOrNotNeeded(\"onTrouterMessageLost\", t);\n          }, t.prototype.onUserActivityStateAccepted = function (t) {\n            this.passIfRegisteredOrNotNeeded(\"onUserActivityStateAccepted\", t);\n          }, t.prototype.onAudiencesSetResolved = function (t, e) {\n            this.passIfRegisteredOrNotNeeded(\"onAudiencesSetResolved\", t, e);\n          }, t.prototype.getState = function () {\n            return this.wrapped.getState();\n          }, t.prototype.holdBackEvent = function (t) {\n            for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n            this.heldBackEvents.push({\n              kind: t,\n              args: e\n            });\n          }, t.prototype.passIfRegisteredOrNotNeeded = function (t) {\n            for (var e, n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];\n            var r = this.shouldConnectionDependOnRegistration(),\n              s = this.shouldHoldBackEvents();\n            r && s || this.fireHeldBackEvents(r ? function (t) {\n              return \"onConnected\" !== t.kind;\n            } : void 0), this.isRegistered || !r || !1 === s && \"onConnected\" !== t ? (e = this.wrapped)[t].apply(e, n) : this.holdBackEvent.apply(this, o([t], n, !1));\n          }, t.prototype.fireHeldBackEvents = function (t) {\n            for (var e, n = 0, o = this.heldBackEvents; n < o.length; n++) {\n              var i = o[n];\n              (void 0 === t || t(i)) && (e = this.wrapped)[i.kind].apply(e, i.args);\n            }\n            this.heldBackEvents = void 0 === t ? [] : this.heldBackEvents.filter(function (e) {\n              return !t(e);\n            });\n          }, t.prototype.dropHeldBackEvents = function () {\n            this.heldBackEvents = [];\n          }, t;\n        }();\n      e.RegistrationEnforcer = r;\n      var s = function () {\n        function t(t, e, n, o) {\n          this.wrapped = t, this.prefix = e, this.logger = n, this.onEventAction = o;\n        }\n        return t.prototype.onEvent = function (t, e) {\n          var n;\n          void 0 !== this.onEventAction ? this.onEventAction(t, e) : (null !== (n = this.logger) && void 0 !== n ? n : console).log(\"\".concat(this.prefix, \" TracingEnforcer: \").concat(t, \"(\").concat(e, \")\"));\n        }, t.prototype.onDownstreamRequest = function (t, e, n) {\n          this.onEvent(\"onDownstreamRequest\", JSON.stringify({\n            request: e,\n            response: n\n          })), this.wrapped.onDownstreamRequest(t, e, n);\n        }, t.prototype.onConnected = function (t) {\n          this.onEvent(\"onConnected\", t.getState().toString()), this.wrapped.onConnected(t);\n        }, t.prototype.onRegistered = function (t) {\n          this.onEvent(\"onRegistered\", t.getState().toString()), this.wrapped.onRegistered(t);\n        }, t.prototype.onUnregistered = function (t) {\n          this.onEvent(\"onUnregistered\", t.getState().toString()), this.wrapped.onUnregistered(t);\n        }, t.prototype.onReconnecting = function (t) {\n          this.onEvent(\"onReconnecting\", t.getState().toString()), this.wrapped.onReconnecting(t);\n        }, t.prototype.onReconnectIsRequired = function (t, e, n) {\n          this.onEvent(\"onReconnectIsRequired\", JSON.stringify({\n            connection: t.getState().toString(),\n            useConnectParamsFromCache: e,\n            reason: n\n          })), this.wrapped.onReconnectIsRequired(t, e, n);\n        }, t.prototype.onDisconnected = function (t) {\n          this.onEvent(\"onDisconnected\", t.getState().toString()), this.wrapped.onDisconnected(t);\n        }, t.prototype.onTerminalError = function (t) {\n          this.onEvent(\"onTerminalError\", JSON.stringify({\n            connection: t\n          })), this.wrapped.onTerminalError(t);\n        }, t.prototype.onConnectionParametersUpdated = function (t) {\n          this.onEvent(\"onConnectionParametersUpdated\", JSON.stringify({\n            connectParams: t\n          })), this.wrapped.onConnectionParametersUpdated(t);\n        }, t.prototype.onTrouterMessageLost = function (t) {\n          this.onEvent(\"onTrouterMessageLost\", JSON.stringify({\n            flowTags: t\n          })), this.wrapped.onTrouterMessageLost(t);\n        }, t.prototype.onUserActivityStateAccepted = function (t) {\n          this.onEvent(\"onUserActivityStateAccepted\", JSON.stringify({\n            cv: t\n          })), this.wrapped.onUserActivityStateAccepted(t);\n        }, t.prototype.onAudiencesSetResolved = function (t, e) {\n          this.onEvent(\"onAudiencesSetResolved\", JSON.stringify({\n            audienceSubscriptionsResponse: t,\n            cv: e\n          })), this.wrapped.onAudiencesSetResolved(t, e);\n        }, t.prototype.getState = function () {\n          return this.wrapped.getState();\n        }, t;\n      }();\n      e.LoggingManagerConsumer = s;\n    }, function (t, e, n) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.TrouterManagerFsm = void 0;\n      var o = n(2),\n        i = n(4),\n        r = n(0),\n        s = n(7),\n        c = function () {\n          function t(t, e) {\n            this.worker = e, this.state = i.TrouterManagerState.Unknown, this.logger = new r.Logger(\"ManagerFsm\", t);\n          }\n          return t.prototype.start = function () {\n            this.state === i.TrouterManagerState.Unknown ? (this.setState(i.TrouterManagerState.Disconnected), this.worker.forceStopLingeringConnection(), this.worker.startFirstConnection()) : (this.logger.info(\"start called in state '\".concat(i.TrouterManagerState[this.state], \"', expediting pending backoffs, if any\")), this.worker.expediteBackoffOnConnections());\n          }, t.prototype.stop = function (t) {\n            this.state !== i.TrouterManagerState.Unknown ? (this.setState(i.TrouterManagerState.Unknown), this.worker.stopFirstConnection(!0 === t), this.worker.stopSecondConnection(!0 === t)) : this.showIgnored(\"stop\");\n          }, t.prototype.getState = function () {\n            switch (this.state) {\n              case i.TrouterManagerState.Unknown:\n              case i.TrouterManagerState.Connected:\n              case i.TrouterManagerState.Disconnected:\n              case i.TrouterManagerState.Switching:\n                return this.state;\n              case i.TrouterManagerState.TerminalError:\n                return o.TrouterState.Disconnected;\n            }\n          }, t.prototype.getInternalState = function () {\n            return this.state;\n          }, t.prototype.onConnected = function (t) {\n            this.state === i.TrouterManagerState.Disconnected && t ? this.worker.doesSecondConnectionExist() ? this.setState(i.TrouterManagerState.Switching) : (this.setState(i.TrouterManagerState.Connected), this.worker.dispatchConnected()) : this.showIgnored(\"onConnected(\".concat(t, \")\"));\n          }, t.prototype.onRegistered = function (t) {\n            this.state !== i.TrouterManagerState.Disconnected || t ? this.state !== i.TrouterManagerState.Switching || t ? this.state === i.TrouterManagerState.Disconnected && t && (this.setState(i.TrouterManagerState.Connected), this.worker.dispatchConnected()) : (this.setState(i.TrouterManagerState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnectionDelayed(), this.worker.dispatchConnected()) : (this.setState(i.TrouterManagerState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnection(!0), this.worker.dispatchConnected()), this.worker.dispatchRegistrationState(!0);\n          }, t.prototype.onUnregistered = function (t) {\n            t && this.worker.dispatchRegistrationState(!1);\n          }, t.prototype.onReconnecting = function (t) {\n            this.state !== i.TrouterManagerState.Connected && this.state !== i.TrouterManagerState.Switching || !t ? this.showIgnored(\"onReconnecting(\".concat(t, \")\")) : (this.setState(i.TrouterManagerState.Disconnected), this.worker.dispatchDisconnected());\n          }, t.prototype.onReconnectionRequired = function (t, e, n) {\n            this.state === i.TrouterManagerState.Connected && t ? (this.setState(i.TrouterManagerState.Switching), this.worker.startSecondConnection(e)) : this.state === i.TrouterManagerState.Disconnected && t ? this.worker.startSecondConnection(e) : this.state === i.TrouterManagerState.Switching && t && n === s.ReconnectReason.Configuration ? (this.logger.debug(\"onReconnectionRequired: switch requested while already in Switching state\"), this.worker.stopSecondConnection(!0), this.worker.startSecondConnection(e)) : this.showIgnored(\"onReconnectionRequired(\".concat(t, \")\"));\n          }, t.prototype.onDisconnected = function (t) {\n            this.state == i.TrouterManagerState.Unknown && t ? this.worker.dispatchDisconnected() : this.state == i.TrouterManagerState.Switching && t ? (this.worker.switchConnections(), this.worker.stopSecondConnection(!1), this.setState(i.TrouterManagerState.Disconnected), this.worker.dispatchDisconnected()) : this.showIgnored(\"onDisconnected(\".concat(t, \")\"));\n          }, t.prototype.onTerminalError = function () {\n            this.setState(i.TrouterManagerState.TerminalError), this.worker.dispatchTerminalError();\n          }, t.prototype.showIgnored = function (t) {\n            this.logger.info(\"Ignoring event '\".concat(t, \"' in state '\").concat(i.TrouterManagerState[this.state], \"'\"));\n          }, t.prototype.setState = function (t) {\n            if (this.logger.info(\"Switching from state '\".concat(i.TrouterManagerState[this.state], \"' to state '\").concat(i.TrouterManagerState[t], \"'\")), this.state === t) return void this.logger.error(\"Attempt to switch to the current state '\".concat(i.TrouterManagerState[t], \"'\"));\n            this.state = t;\n          }, t;\n        }();\n      e.TrouterManagerFsm = c;\n    }, function (t, e, n) {\n      function o(t, e) {\n        if (!e) return t;\n        var n = h(h({}, t), {\n          enabled: e.TelemetryEnabled\n        });\n        return void 0 !== e.ClientTelemetryEventEnabled && (n = h(h({}, n), e.ClientTelemetryEventEnabled)), n;\n      }\n      function i(t, e, n) {\n        var i,\n          r,\n          s,\n          c,\n          a,\n          u,\n          d,\n          l,\n          p,\n          g,\n          f = function (n) {\n            return t.proxyUrlRewrite ? (e.info(\"Using rewritten URL for proxy\"), t.proxyUrlRewrite(n)) : n;\n          };\n        return {\n          clientInfo: {\n            ua: t.trouterSettings.productName,\n            v: t.trouterSettings.version\n          },\n          ioOptions: {\n            ackTimeoutMs: 5e3,\n            rewriteUrlForProxy: f\n          },\n          clientCorrelationID: t.trouterSettings.sessionId,\n          environment: t.trouterSettings.environment,\n          telemetrySettings: o(t.telemetryConfig.settings, n),\n          eventLogger: t.telemetryConfig.eventLogger,\n          endpointId: t.trouterSettings.registrationId,\n          trouterUrl: (null === n || void 0 === n ? void 0 : n.TrouterConnectionUrl) || t.trouterSettings.trouterServiceUrl,\n          registration: t.trouterSettings.registrarServiceUrl ? {\n            registrarUrl: t.trouterSettings.registrarServiceUrl,\n            registrationId: null !== (i = t.trouterSettings.registrationId) && void 0 !== i ? i : \"\",\n            pnhAppId: null !== (r = t.trouterSettings.pnhAppId) && void 0 !== r ? r : \"\",\n            platform: null !== (s = t.trouterSettings.platform) && void 0 !== s ? s : \"\",\n            pnhTemplateKey: null !== (c = t.trouterSettings.pnhTemplate) && void 0 !== c ? c : \"\",\n            platformUIVersion: null !== (a = t.trouterSettings.platformUIVersion) && void 0 !== a ? a : \"\",\n            productContext: t.trouterSettings.pnhProductContext || void 0,\n            context: null !== (u = t.trouterSettings.pnhContext) && void 0 !== u ? u : \"\",\n            registrarTtlSec: (null !== (d = t.trouterSettings.maxRegistrationTimeInMs) && void 0 !== d ? d : 0) / 1e3\n          } : void 0,\n          connectionDependsOnRegistration: void 0 === t.trouterSettings.registrarServiceUrl ? function () {\n            return !1;\n          } : null !== (l = t.trouterSettings.connectionDependsOnRegistration) && void 0 !== l ? l : function () {\n            return !1;\n          },\n          delayEventsUntilRegistered: null !== (p = t.trouterSettings.delayEventsUntilRegistered) && void 0 !== p ? p : function () {\n            return !1;\n          },\n          timeoutOptions: h({\n            connectionTimeoutMs: t.trouterSettings.trouterConnectTimeoutInMs || 3e4,\n            fetchTimeoutMs: 1e4,\n            pingTimeoutMs: 4e4,\n            pongTimeoutMs: 5e3,\n            maxBackoffMs: \"TeamsCDL\" === t.trouterSettings.productName ? 3e5 : 3e4,\n            requestTimeoutMs: 5e3,\n            userActivityResponseTimeoutMs: 1e4\n          }, t.trouterSettings.timeoutOptions),\n          incallTimeoutOptions: h({\n            connectionTimeoutMs: 1e4,\n            fetchTimeoutMs: 5e3,\n            pingTimeoutMs: 5e3,\n            pongTimeoutMs: 2e3,\n            maxBackoffMs: \"TeamsCDL\" === t.trouterSettings.productName ? 3e5 : 1e4,\n            requestTimeoutMs: 5e3,\n            userActivityResponseTimeoutMs: 1e4\n          }, t.trouterSettings.incallTimeoutOptions),\n          incallModeTimeoutMs: null !== (g = t.trouterSettings.incallModeTimeoutMs) && void 0 !== g ? g : 0,\n          lingeringConnectionDelayMs: 6e4,\n          userActivitySecondResendDelayMs: t.trouterSettings.userActivitySecondResendDelayMs || 1e4,\n          duplicateDisconnectThresholdMs: 1e4,\n          connectionCache: t.connectionCache,\n          registrationStateCallback: t.registrationStateCallbackForAcsDoNotUse,\n          rewriteUrlForProxy: f,\n          retryLimitOnTokenFetch: t.trouterSettings.retryLimitOnTokenFetch,\n          extraConnectionHeaders: t.trouterSettings.extraConnectionHeaders,\n          expediteBackoffOnStartMinimumDelayMs: 1e4,\n          toJSON: function () {\n            return h(h({}, this), {\n              connectionCache: this.connectionCache ? {} : this.connectionCache\n            });\n          }\n        };\n      }\n      function r(t) {\n        return new S(t);\n      }\n      function s() {\n        return p.CLIENT_VERSION;\n      }\n      function c(t, e) {\n        var n = t.indexOf(\"://\");\n        if (n >= 0) {\n          var o = t.indexOf(\"/\", n + 3);\n          if (o >= 0) return e + t.substr(o);\n        }\n        return \"\";\n      }\n      function a(t) {\n        var e = this;\n        return function (n) {\n          return d(e, void 0, void 0, function () {\n            var e;\n            return l(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return e = {}, [4, t(n.needFresh)];\n                case 1:\n                  return [2, (e.token = o.sent(), e.tokenType = \"skype\", e)];\n              }\n            });\n          });\n        };\n      }\n      function u(t, e) {\n        var n,\n          o = this;\n        return function (i) {\n          return d(o, void 0, void 0, function () {\n            var o, r, s;\n            return l(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  o = new Date(), r = setInterval(function () {\n                    var e = Math.round((Date.now() - o.getTime()) / 6e4);\n                    t.warn(\"Note: Trouter auth token request promise from \".concat(o.toISOString(), \" has not been resolved for \").concat(e, \" minutes. The client is blocked from operating properly\"));\n                  }, 3e5), c.label = 1;\n                case 1:\n                  return c.trys.push([1,, 3, 4]), [4, e(i)];\n                case 2:\n                  return s = c.sent(), i.needFresh && s.token === n && t.error(\"API violation: Trouter auth token provider got a request with needRefresh=true, but returned the same token as last time anyway. Please fix the host app\"), n = s.token, [2, s];\n                case 3:\n                  return clearInterval(r), [7];\n                case 4:\n                  return [2];\n              }\n            });\n          });\n        };\n      }\n      var h = this && this.__assign || function () {\n          return h = Object.assign || function (t) {\n            for (var e, n = 1, o = arguments.length; n < o; n++) {\n              e = arguments[n];\n              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);\n            }\n            return t;\n          }, h.apply(this, arguments);\n        },\n        d = this && this.__awaiter || function (t, e, n, o) {\n          function i(t) {\n            return t instanceof n ? t : new n(function (e) {\n              e(t);\n            });\n          }\n          return new (n || (n = Promise))(function (n, r) {\n            function s(t) {\n              try {\n                a(o.next(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function c(t) {\n              try {\n                a(o.throw(t));\n              } catch (t) {\n                r(t);\n              }\n            }\n            function a(t) {\n              t.done ? n(t.value) : i(t.value).then(s, c);\n            }\n            a((o = o.apply(t, e || [])).next());\n          });\n        },\n        l = this && this.__generator || function (t, e) {\n          function n(t) {\n            return function (e) {\n              return o([t, e]);\n            };\n          }\n          function o(n) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; c && (c = 0, n[0] && (a = 0)), a;) try {\n              if (i = 1, r && (s = 2 & n[0] ? r.return : n[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, n[1])).done) return s;\n              switch (r = 0, s && (n = [2 & n[0], s.value]), n[0]) {\n                case 0:\n                case 1:\n                  s = n;\n                  break;\n                case 4:\n                  return a.label++, {\n                    value: n[1],\n                    done: !1\n                  };\n                case 5:\n                  a.label++, r = n[1], n = [0];\n                  continue;\n                case 7:\n                  n = a.ops.pop(), a.trys.pop();\n                  continue;\n                default:\n                  if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {\n                    a = 0;\n                    continue;\n                  }\n                  if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {\n                    a.label = n[1];\n                    break;\n                  }\n                  if (6 === n[0] && a.label < s[1]) {\n                    a.label = s[1], s = n;\n                    break;\n                  }\n                  if (s && a.label < s[2]) {\n                    a.label = s[2], a.ops.push(n);\n                    break;\n                  }\n                  s[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n              n = e.call(t, a);\n            } catch (t) {\n              n = [6, t], r = 0;\n            } finally {\n              i = s = 0;\n            }\n            if (5 & n[0]) throw n[1];\n            return {\n              value: n[0] ? n[1] : void 0,\n              done: !0\n            };\n          }\n          var i,\n            r,\n            s,\n            c,\n            a = {\n              label: 0,\n              sent: function () {\n                if (1 & s[0]) throw s[1];\n                return s[1];\n              },\n              trys: [],\n              ops: []\n            };\n          return c = {\n            next: n(0),\n            throw: n(1),\n            return: n(2)\n          }, \"function\" == typeof Symbol && (c[Symbol.iterator] = function () {\n            return this;\n          }), c;\n        };\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.replaceTrouterUrlBase = e.getTrouterServiceVersion = e.createTrouterService = e.TrouterService = e.UserActivityState = e.TrouterState = void 0;\n      var p = n(1),\n        g = n(2);\n      Object.defineProperty(e, \"TrouterState\", {\n        enumerable: !0,\n        get: function () {\n          return g.TrouterState;\n        }\n      }), Object.defineProperty(e, \"UserActivityState\", {\n        enumerable: !0,\n        get: function () {\n          return g.UserActivityState;\n        }\n      });\n      var f = n(0),\n        v = n(8),\n        m = n(9),\n        y = n(10),\n        T = n(11),\n        S = function () {\n          function t(t) {\n            this.logProvider = t, this.stateChangedListeners = [], this.logger = new f.Logger(\"Trouter\", t), this.trouterUrlPromise = new T.TrouterUrlPromise(t), this.messageHandlers = new v.MessageHandlerRegistry(t), this.listeners = {}, this.connectionInfo = null, this.logger.info(\"Created TrouterService version \".concat(p.CLIENT_VERSION));\n          }\n          return t.prototype.start = function (t) {\n            var e;\n            if (this.logger.info(\"Start\"), !t.skypeTokenProvider && !t.authTokenProvider) throw new Error(\"no token provider has been configured, either skypeTokenProvider or authTokenProvider must be populated\");\n            t.skypeTokenProvider && !t.trouterSettings.disableInternalSkypeTokenCache && (t.skypeTokenProvider = (0, m.addCacheAsBackupTo)(t.skypeTokenProvider)), this.trouterCfg = t;\n            var n = i(t, this.logger, this.ecsCfg);\n            !1 === t.internalEnableV4cProtocol && (n.forceV4aProtocol = !0);\n            var o = u(this.logger, null !== (e = t.authTokenProvider) && void 0 !== e ? e : a(t.skypeTokenProvider));\n            void 0 === this.trouterServer && (this.trouterServer = new y.TrouterManager(this.logProvider, n, o, void 0 === t.authTokenProvider, this)), void 0 !== this.pendingActivityState && (this.trouterServer.setUserActivityState(this.pendingActivityState[0], this.pendingActivityState[1]), this.pendingActivityState = void 0), this.trouterServer.start();\n          }, t.prototype.stop = function (t) {\n            this.logger.info(\"close connection\"), this.trouterUrlPromise.rejectUrl(new Error(\"TrouterService is stopped\")), void 0 !== this.trouterServer && this.trouterServer.stop(t);\n          }, t.prototype.setEcsConfig = function (t) {\n            return d(this, void 0, void 0, function () {\n              var e = this;\n              return l(this, function (n) {\n                return [2, new Promise(function (n) {\n                  if (e.ecsCfg = t.TrouterJScriptClient, e.logger.info(\"Setting ECS configuration to \".concat(JSON.stringify(e.ecsCfg))), void 0 !== e.trouterServer && void 0 !== e.trouterCfg) {\n                    var o = i(e.trouterCfg, e.logger, e.ecsCfg);\n                    e.trouterServer.configure(o);\n                  }\n                  n();\n                })];\n              });\n            });\n          }, t.prototype.checkConnection = function (t) {\n            void 0 !== this.trouterServer && this.trouterServer.checkConnection(null !== t && void 0 !== t && t);\n          }, t.prototype.resendRegistration = function () {\n            return d(this, void 0, void 0, function () {\n              return l(this, function (t) {\n                if (!this.trouterServer) throw new Error(\"resendRegistration called too early\");\n                return [2, this.trouterServer.resendRegistration()];\n              });\n            });\n          }, t.prototype.registerListener = function (t, e) {\n            return \"\" === e || !e.startsWith(\"/\") || e.includes(\"?\") || e.includes(\"#\") ? (this.logger.error(\"Listener path '\".concat(e, \"' is not valid\")), !1) : this.listeners[e] ? (this.logger.error(\"Another listener is already registered for path '\".concat(e, \"'\")), !1) : (this.listeners[e] = t, this.logger.debug(\"Listener for path '\".concat(e, \"' registered\")), this.connectionInfo && t.onTrouterConnected(this.connectionInfo.baseEndpointUrl + e, this.connectionInfo), !0);\n          }, t.prototype.unregisterListener = function (t) {\n            for (var e = [], n = 0, o = Object.keys(this.listeners); n < o.length; n++) {\n              var i = o[n];\n              this.listeners[i] === t && e.push(i);\n            }\n            if (0 === e.length) return !1;\n            for (var r = 0, s = e; r < s.length; r++) {\n              var i = s[r];\n              delete this.listeners[i];\n            }\n            return this.logger.debug(\"Listener for path(s) '\".concat(e.join(\"', '\"), \"' unregistered\")), !0;\n          }, t.prototype.onTrouterConnected = function (t, e) {\n            this.logger.debug(\"Trouter is now connected\");\n            for (var n = 0, o = Object.keys(this.listeners); n < o.length; n++) {\n              var i = o[n];\n              try {\n                this.listeners[i].onTrouterConnected(e.baseEndpointUrl + i, e);\n              } catch (t) {\n                this.logger.error(\"Listener '\".concat(i, \"' threw an exception from onTrouterConnected(): \").concat(t));\n              }\n            }\n            this.connectionInfo = e, this.trouterUrlPromise.resolveUrl(t), this.notifyStateChanged(g.TrouterState.Connected, {\n              url: t,\n              getRemainingTtlInSec: function () {\n                return e.connectionTtlSec;\n              }\n            });\n          }, t.prototype.onTrouterDisconnected = function () {\n            this.logger.debug(\"Trouter is now disconnected\"), this.connectionInfo = null;\n            for (var t = 0, e = Object.keys(this.listeners); t < e.length; t++) {\n              var n = e[t],\n                o = this.listeners[n];\n              if (o.onTrouterDisconnected) try {\n                o.onTrouterDisconnected();\n              } catch (t) {\n                this.logger.error(\"Listener '\".concat(n, \"' threw an exception from onTrouterDisconnected(): \").concat(t));\n              }\n            }\n            this.notifyStateChanged(g.TrouterState.Disconnected);\n          }, t.prototype.onTrouterRequest = function (t, e) {\n            for (var n = \"\", o = 0, i = Object.keys(this.listeners); o < i.length; o++) {\n              var r = i[o];\n              t.path.startsWith(r) && r.length > n.length && (n = r);\n            }\n            if (\"\" === n) this.tryMessageHandlers(t, e) || (e.status = 404, e.headers = {\n              \"Trouter-Responder\": \"ClientLib\"\n            }, e.send());else try {\n              this.listeners[n].onTrouterRequest(t, e);\n            } catch (t) {\n              this.logger.error(\"Listener '\".concat(n, \"' threw an exception from onTrouterRequest(): \").concat(t)), e.status = 500, e.headers = {\n                \"Trouter-Responder\": \"ClientLib\"\n              }, e.send();\n            }\n          }, t.prototype.onTrouterMessageLoss = function (t) {\n            this.logger.info(\"onTrouterMessageLoss called with tags [\".concat(t, \"]\"));\n            for (var e = !0, n = 0, o = Object.keys(this.listeners); n < o.length; n++) {\n              var i = o[n],\n                r = this.listeners[i];\n              if (r.onTrouterMessageLoss) try {\n                e = r.onTrouterMessageLoss(t) && e, void 0 === e && (this.logger.error(\"Listener '\".concat(i, \"' did not return a boolean value from onTrouterMessageLoss()\")), e = !1);\n              } catch (t) {\n                this.logger.error(\"Listener '\".concat(i, \"' threw an exception from onTrouterMessageLoss(): \").concat(t)), e = !1;\n              }\n            }\n            return e;\n          }, t.prototype.onTrouterUserActivityStateAccepted = function (t) {\n            this.logger.debug(\"onTrouterUserActivityStateAccepted cv: \".concat(t));\n            for (var e = 0, n = Object.keys(this.listeners); e < n.length; e++) {\n              var o = n[e],\n                i = this.listeners[o];\n              if (i.onTrouterUserActivityStateAccepted) try {\n                i.onTrouterUserActivityStateAccepted(t);\n              } catch (t) {\n                this.logger.error(\"Listener '\".concat(o, \"' threw an exception from onTrouterUserActivityStateAccepted(): \").concat(t));\n              }\n            }\n          }, t.prototype.onAudiencesSetResolved = function (t, e) {\n            this.logger.debug(\"onAudiencesSetResolved cv: \".concat(e));\n            for (var n = 0, o = Object.keys(this.listeners); n < o.length; n++) {\n              var i = o[n],\n                r = this.listeners[i];\n              if (r.onAudiencesSetResolved) try {\n                r.onAudiencesSetResolved(t, e);\n              } catch (t) {\n                this.logger.error(\"Listener '\".concat(i, \"' threw an exception from onAudienceSubscribed(): \").concat(t));\n              }\n            }\n          }, t.prototype.setUserActivityState = function (t, e) {\n            if (t !== g.UserActivityState.Active && t !== g.UserActivityState.Inactive) throw new Error(\"setUserActivityState called with unsupported value \".concat(t));\n            this.logger.info(\"setUserActivityState called with value \".concat(g.UserActivityState[t])), this.trouterServer && this.state() !== g.TrouterState.Unknown ? this.trouterServer.setUserActivityState(t, e) : (this.pendingActivityState = [t, e], this.logger.warn(\"setUserActivityState called before start() or after stop()\"));\n          }, t.prototype.setAudienceSubscriptions = function (t, e) {\n            if (t.audienceSubscriptions.length > 1) throw new Error(\"Only singular audience subscription is supported\");\n            if (this.trouterServer && this.state() !== g.TrouterState.Unknown) return this.trouterServer.setAudienceSubscriptionsAsync(t, 15e3, e);\n            throw new Error(\"audience subscribe called before start() or after stop()\");\n          }, t.prototype.state = function () {\n            return void 0 !== this.trouterServer ? this.trouterServer.getState() : g.TrouterState.Unknown;\n          }, t.prototype.isInTerminalState = function () {\n            return void 0 !== this.trouterServer && this.trouterServer.isInTerminalState();\n          }, t.prototype.reportStateInfo = function () {\n            return void 0 === this.trouterServer ? \"\" : this.trouterServer.reportStateInfo();\n          }, t.prototype.getServerState = function () {\n            if (void 0 !== this.trouterServer) return this.trouterServer.getServerState();\n          }, t.prototype.getTrouterUrlAsync = function () {\n            return void 0 !== this.trouterServer ? this.trouterUrlPromise.getPromise() : Promise.reject(new Error(\"TrouterService has not been started\"));\n          }, t.prototype.onStateChanged = function (t) {\n            if (this.logger.info(\"onStateChanged called\"), void 0 === t) this.stateChangedListeners = this.stateChangedListeners.filter(function (t) {\n              return void 0 === t.wrappedCallback;\n            });else {\n              this.offStateChanged(t);\n              var e = function (e, n) {\n                t(e, n ? n.url : \"\");\n              };\n              e.wrappedCallback = t, this.stateChangedListeners.push(e);\n            }\n          }, t.prototype.offStateChanged = function (t) {\n            this.logger.info(\"offStateChanged called\");\n            var e = this.stateChangedListeners.length;\n            return this.stateChangedListeners = this.stateChangedListeners.filter(function (e) {\n              return e.wrappedCallback !== t;\n            }), e > this.stateChangedListeners.length;\n          }, t.prototype.addCallback = function (t) {\n            this.logger.info(\"addListener called\"), -1 === this.stateChangedListeners.indexOf(t, 0) && void 0 !== t && this.stateChangedListeners.push(t);\n          }, t.prototype.removeCallback = function (t) {\n            this.logger.info(\"removeListener called\");\n            var e = this.stateChangedListeners.indexOf(t, 0);\n            return e > -1 && (this.stateChangedListeners.splice(e, 1), !0);\n          }, t.prototype.registerMessageHandler = function (t) {\n            this.logger.info(\"registerMessageHandler is called\"), this.messageHandlers.register(t);\n          }, t.prototype.clearMessageHandlers = function () {\n            this.logger.info(\"clearMessageHandlers is called\"), this.messageHandlers.clear();\n          }, t.prototype.notifyStateChanged = function (t, e) {\n            var n = this;\n            this.logger.info(\"notifyStateChanged called, will forward to \".concat(this.stateChangedListeners.length, \" listeners\")), this.stateChangedListeners.forEach(function (o) {\n              try {\n                o(t, e);\n              } catch (t) {\n                n.logger.error(\"Error in callback \".concat(t));\n              }\n            });\n          }, t.prototype.tryMessageHandlers = function (t, e) {\n            if (!this.messageHandlers.active()) return !1;\n            var n,\n              o = null;\n            try {\n              n = JSON.parse(t.body), o = n && (n.evt || n.eventId) || null;\n            } catch (t) {}\n            var i = {\n                eventId: o,\n                url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : \"\") + t.path,\n                body: n,\n                rawBody: t.body,\n                headers: t.headers\n              },\n              r = this.messageHandlers.handleMessage(i);\n            return !!r.isHandled && (e.status = r.resultCode, r.responseHeaders && (e.headers = r.responseHeaders), r.responseBody && (e.body = r.responseBody), e.send(), !0);\n          }, t;\n        }();\n      e.TrouterService = S, e.createTrouterService = r, e.getTrouterServiceVersion = s, e.replaceTrouterUrlBase = c;\n    }, function (e, n) {\n      e.exports = t;\n    }]);\n  });\n});\nunwrapExports(tstrouter);\nvar chat = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DeleteReason = void 0;\n  var DeleteReason = /*#__PURE__*/function (DeleteReason) {\n    DeleteReason[\"DeletedByPolicy\"] = \"deletedByPolicy\";\n    DeleteReason[\"DeletedByUser\"] = \"deletedByUser\";\n    return DeleteReason;\n  }(DeleteReason || (exports.DeleteReason = DeleteReason = {}));\n});\nunwrapExports(chat);\nchat.DeleteReason;\nvar constants = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PACKAGE_VERSION = exports.CONFIG_API_VERSION = exports.EudbCountries = exports.CloudPrefix = exports.CloudType = exports.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = void 0;\n  exports.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = 3;\n  // Gov cloud types\n  var CloudType = /*#__PURE__*/function (CloudType) {\n    CloudType[\"Public\"] = \"Public\";\n    CloudType[\"GccHigh\"] = \"GCC High\";\n    CloudType[\"Dod\"] = \"DoD\";\n    return CloudType;\n  }(CloudType || (exports.CloudType = CloudType = {}));\n  var CloudPrefix = /*#__PURE__*/function (CloudPrefix) {\n    CloudPrefix[\"OrgId\"] = \"orgid\";\n    CloudPrefix[\"Acs\"] = \"acs\";\n    CloudPrefix[\"Spool\"] = \"spool\";\n    CloudPrefix[\"GccHigh\"] = \"gcch\";\n    CloudPrefix[\"GccHighAcs\"] = \"gcch-acs\";\n    CloudPrefix[\"Dod\"] = \"dod\";\n    CloudPrefix[\"DodAcs\"] = \"dod-acs\";\n    return CloudPrefix;\n  }(CloudPrefix || (exports.CloudPrefix = CloudPrefix = {}));\n  exports.EudbCountries = [\"europe\", \"france\", \"germany\", \"norway\", \"switzerland\", \"sweden\"];\n  exports.CONFIG_API_VERSION = \"2024-09-01\";\n  exports.PACKAGE_VERSION = \"1.0.0-beta.34\";\n});\nunwrapExports(constants);\nconstants.PACKAGE_VERSION;\nconstants.CONFIG_API_VERSION;\nconstants.EudbCountries;\nconstants.CloudPrefix;\nconstants.CloudType;\nconstants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES;\nvar chat_1 = chat;\nvar constants_1 = constants;\nvar TrouterUtils = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isEudbLocation = exports.parseTokenCredential = exports.base64decode = exports.toTelemetrySender = exports.toLogProvider = exports.toMessageHandler = void 0;\n  exports.generateUuid = generateUuid;\n  const eventIds = new Map([[\"chatMessageReceived\", 200], [\"typingIndicatorReceived\", 245], [\"readReceiptReceived\", 246], [\"chatMessageEdited\", 247], [\"chatMessageDeleted\", 248], [\"chatThreadCreated\", 257], [\"chatThreadPropertiesUpdated\", 258], [\"chatThreadDeleted\", 259], [\"participantsAdded\", 260], [\"participantsRemoved\", 261]]);\n  const publicTeamsUserPrefix = \"8:orgid:\";\n  const dodTeamsUserPrefix = \"8:dod:\";\n  const gcchTeamsUserPrefix = \"8:gcch:\";\n  const teamsVisitorUserPrefix = \"8:teamsvisitor:\";\n  const phoneNumberPrefix = \"4:\";\n  const acsUserPrefix = \"8:acs:\";\n  const acsGcchUserPrefix = \"8:gcch-acs:\";\n  const acsDodUserPrefix = \"8:dod-acs:\";\n  const spoolUserPrefix = \"8:spool:\";\n  const toMessageHandler = (event, listener, resourceEndpoint, gatewayApiVersion) => {\n    const eventId = eventIds.get(event);\n    return {\n      handleMessage(message) {\n        let genericPayload = null;\n        if (message === null || message === void 0 ? void 0 : message.rawBody) {\n          genericPayload = JSON.parse(message.rawBody);\n        }\n        if (genericPayload === null || genericPayload.eventId !== eventId) {\n          return undefined;\n        }\n        const eventPayload = toEventPayload(event, genericPayload, resourceEndpoint, gatewayApiVersion);\n        if (eventPayload === null) {\n          return undefined;\n        }\n        listener(eventPayload);\n        return {\n          isHandled: true,\n          resultCode: 200\n        };\n      }\n    };\n  };\n  exports.toMessageHandler = toMessageHandler;\n  function toChatMessageReceivedEvent(payload, resourceEndpoint, gatewayApiVersion) {\n    return {\n      threadId: payload.groupId,\n      sender: constructIdentifierKindFromMri(payload.senderId),\n      senderDisplayName: payload.senderDisplayName,\n      recipient: constructIdentifierKindFromMri(payload.recipientMri),\n      id: payload.messageId,\n      createdOn: new Date(payload.originalArrivalTime),\n      version: payload.version,\n      type: payload.messageType,\n      message: payload.messageBody,\n      metadata: parseJsonString(payload.acsChatMessageMetadata) || {},\n      attachments: transformEndpoint(parseJsonString(payload.attachments) || [], resourceEndpoint, gatewayApiVersion)\n    };\n  }\n  function toChatMessageEditedEvent(payload, resourceEndpoint, gatewayApiVersion) {\n    return Object.assign(Object.assign({}, toChatMessageReceivedEvent(payload, resourceEndpoint, gatewayApiVersion)), {\n      editedOn: new Date(payload.edittime)\n    });\n  }\n  const toEventPayload = (event, genericPayload, resourceEndpoint, gatewayApiVersion) => {\n    if (event === \"chatMessageReceived\") {\n      const payload = genericPayload;\n      return toChatMessageReceivedEvent(payload, resourceEndpoint, gatewayApiVersion);\n    }\n    if (event === \"chatMessageEdited\") {\n      const payload = genericPayload;\n      return toChatMessageEditedEvent(payload, resourceEndpoint, gatewayApiVersion);\n    }\n    if (event === \"chatMessageDeleted\") {\n      const payload = genericPayload;\n      const eventPayload = {\n        threadId: payload.groupId,\n        sender: constructIdentifierKindFromMri(payload.senderId),\n        senderDisplayName: payload.senderDisplayName,\n        recipient: constructIdentifierKindFromMri(payload.recipientMri),\n        id: payload.messageId,\n        createdOn: new Date(payload.originalArrivalTime),\n        version: payload.version,\n        deletedOn: new Date(payload.deletetime),\n        type: payload.messageType\n      };\n      return eventPayload;\n    }\n    if (event === \"typingIndicatorReceived\") {\n      const payload = genericPayload;\n      const eventPayload = {\n        threadId: payload.groupId,\n        sender: constructIdentifierKindFromMri(payload.senderId),\n        senderDisplayName: payload.senderDisplayName,\n        recipient: constructIdentifierKindFromMri(payload.recipientMri),\n        version: payload.version,\n        receivedOn: new Date(payload.originalArrivalTime)\n      };\n      return eventPayload;\n    }\n    if (event === \"readReceiptReceived\") {\n      const payload = genericPayload;\n      const readReceiptMessageBody = JSON.parse(payload.messageBody);\n      const consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(\";\");\n      const eventPayload = {\n        threadId: payload.groupId,\n        sender: constructIdentifierKindFromMri(payload.senderId),\n        senderDisplayName: \"\",\n        recipient: constructIdentifierKindFromMri(payload.recipientMri),\n        chatMessageId: payload.messageId,\n        readOn: new Date(+consumptionHorizon[1])\n      };\n      return eventPayload;\n    }\n    if (event === \"chatThreadCreated\") {\n      const payload = genericPayload;\n      const createdByPayload = JSON.parse(unescape(payload.createdBy));\n      const membersPayload = JSON.parse(unescape(payload.members));\n      const createdBy = toChatParticipant(createdByPayload);\n      const chatParticipants = membersPayload.map(m => {\n        return toChatParticipant(m);\n      });\n      const eventPayload = {\n        threadId: payload.threadId,\n        createdOn: new Date(payload.createTime),\n        createdBy: createdBy,\n        version: payload.version,\n        participants: chatParticipants,\n        properties: toThreadProperties(JSON.parse(unescape(payload.properties))),\n        retentionPolicy: getRetentionPolicy(JSON.parse(unescape(payload.properties)))\n      };\n      return eventPayload;\n    }\n    if (event === \"chatThreadPropertiesUpdated\") {\n      const payload = genericPayload;\n      const updatedByPayload = JSON.parse(unescape(payload.editedBy));\n      const updatedBy = toChatParticipant(updatedByPayload);\n      const eventPayload = {\n        threadId: payload.threadId,\n        updatedOn: new Date(payload.editTime),\n        updatedBy: updatedBy,\n        version: payload.version,\n        properties: toThreadProperties(JSON.parse(unescape(payload.properties))),\n        retentionPolicy: getRetentionPolicy(JSON.parse(unescape(payload.properties)))\n      };\n      return eventPayload;\n    }\n    if (event === \"chatThreadDeleted\") {\n      const payload = genericPayload;\n      const deletedBy = genericPayload.reason == chat_1.DeleteReason.DeletedByPolicy ? null : toChatParticipant(JSON.parse(unescape(payload.deletedBy)));\n      const eventPayload = {\n        threadId: payload.threadId,\n        deletedOn: new Date(payload.deleteTime),\n        deletedBy: deletedBy,\n        version: payload.version,\n        reason: payload.reason\n      };\n      return eventPayload;\n    }\n    if (event === \"participantsAdded\") {\n      const payload = genericPayload;\n      const addedByPayload = JSON.parse(unescape(payload.addedBy));\n      const participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));\n      const addedBy = toChatParticipant(addedByPayload);\n      const chatParticipants = participantsAddedPayload.map(m => {\n        return toChatParticipant(m);\n      });\n      const eventPayload = {\n        threadId: payload.threadId,\n        addedOn: new Date(payload.time),\n        addedBy: addedBy,\n        version: payload.version,\n        participantsAdded: chatParticipants\n      };\n      return eventPayload;\n    }\n    if (event === \"participantsRemoved\") {\n      const payload = genericPayload;\n      const removedByPayload = JSON.parse(unescape(payload.removedBy));\n      const participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));\n      const removedBy = toChatParticipant(removedByPayload);\n      const chatParticipants = participantsRemovedPayload.map(m => {\n        return toChatParticipant(m);\n      });\n      const eventPayload = {\n        threadId: payload.threadId,\n        removedOn: new Date(payload.time),\n        removedBy: removedBy,\n        version: payload.version,\n        participantsRemoved: chatParticipants\n      };\n      return eventPayload;\n    }\n    return null;\n  };\n  const toChatParticipant = payload => {\n    var _a;\n    const participant = {\n      id: constructIdentifierKindFromMri(payload.participantId),\n      displayName: payload.displayName,\n      metadata: parseJsonString((_a = payload.memberMetaData) !== null && _a !== void 0 ? _a : \"\") || {}\n    };\n    if (payload.shareHistoryTime) {\n      participant.shareHistoryTime = new Date(payload.shareHistoryTime);\n    }\n    return participant;\n  };\n  const toThreadProperties = payload => {\n    var _a;\n    return {\n      topic: payload.topic,\n      metadata: parseJsonString((_a = payload.acsChatThreadMetadata) !== null && _a !== void 0 ? _a : \"\") || {}\n    };\n  };\n  const getRetentionPolicy = payload => {\n    const raw = payload.retentionPolicy;\n    // No policy string  none\n    if (!raw) {\n      return {\n        kind: \"none\"\n      };\n    }\n    let parsed;\n    try {\n      parsed = JSON.parse(raw);\n    } catch (_a) {\n      return {\n        kind: \"none\"\n      };\n    }\n    // Expected executeAfter format dd.hh:mm:ss if more than 1 day. Or hh:mm:ss if less than one day.\n    if (parsed.retentionPolicyType === \"DeleteAfterCreationTime\" && typeof parsed.executeAfter === \"string\") {\n      // Handle sign, spaces\n      const s = parsed.executeAfter.trim().replace(/^[+-]/, \"\");\n      // only take the part before the dot, otherwise 0\n      const daysPart = s.includes(\".\") ? s.split(\".\")[0] : \"0\";\n      const days = parseInt(daysPart, 10);\n      return {\n        kind: \"threadCreationDate\",\n        deleteThreadAfterDays: isNaN(days) ? 0 : days\n      };\n    }\n    return {\n      kind: \"none\"\n    };\n  };\n  const toLogProvider = logger => {\n    return {\n      log: (...message) => logger.info(message),\n      warn: (...message) => logger.warning(message),\n      error: (...message) => logger.error(message),\n      debug: (...message) => logger.verbose(message),\n      info: (...message) => logger.verbose(message)\n    };\n  };\n  exports.toLogProvider = toLogProvider;\n  const toTelemetrySender = logger => {\n    return {\n      logEvent: clientEvent => logger.info(clientEvent)\n    };\n  };\n  exports.toTelemetrySender = toTelemetrySender;\n  const constructIdentifierKindFromMri = mri => {\n    if (mri.startsWith(publicTeamsUserPrefix)) {\n      return {\n        kind: \"microsoftTeamsUser\",\n        rawId: mri,\n        microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),\n        isAnonymous: false,\n        cloud: \"public\"\n      };\n    } else if (mri.startsWith(dodTeamsUserPrefix)) {\n      return {\n        kind: \"microsoftTeamsUser\",\n        rawId: mri,\n        microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),\n        isAnonymous: false,\n        cloud: \"dod\"\n      };\n    } else if (mri.startsWith(gcchTeamsUserPrefix)) {\n      return {\n        kind: \"microsoftTeamsUser\",\n        rawId: mri,\n        microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),\n        isAnonymous: false,\n        cloud: \"gcch\"\n      };\n    } else if (mri.startsWith(teamsVisitorUserPrefix)) {\n      return {\n        kind: \"microsoftTeamsUser\",\n        rawId: mri,\n        microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),\n        isAnonymous: true\n      };\n    } else if (mri.startsWith(phoneNumberPrefix)) {\n      return {\n        kind: \"phoneNumber\",\n        rawId: mri,\n        phoneNumber: mri.substring(phoneNumberPrefix.length)\n      };\n    } else if (mri.startsWith(acsUserPrefix) || mri.startsWith(acsGcchUserPrefix) || mri.startsWith(acsDodUserPrefix) || mri.startsWith(spoolUserPrefix)) {\n      return {\n        kind: \"communicationUser\",\n        communicationUserId: mri\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        id: mri\n      };\n    }\n  };\n  const parseJsonString = str => {\n    if (str === undefined || str === null || str === \"\" || str === \"null\" || str === \"{}\" || str === \"[]\") {\n      return undefined;\n    }\n    return JSON.parse(str);\n  };\n  const createMediaUrlString = (urlString, resourceEndpoint, gatewayApiVersion) => {\n    let url;\n    try {\n      url = new URL(urlString);\n      if (url.protocol === \"http:\" || url.protocol === \"https:\") {\n        // If its already a full url, substitute the origin\n        url = new URL(url.pathname, resourceEndpoint);\n      }\n    } catch (_) {\n      // urlString is a likely a relative URL, so create a new one with the resourceEndpoint as base\n      try {\n        url = new URL(urlString, resourceEndpoint);\n      } catch (_) {\n        // If we get here, then the urlString passed in is likely incorrect, so just pass it along\n        // As there's nothing we can do at this point.\n        return urlString;\n      }\n    }\n    // Append api-version query and return string\n    url.searchParams.set(\"api-version\", gatewayApiVersion);\n    return url.toString();\n  };\n  const isValidURL = str => {\n    let url;\n    try {\n      url = new URL(str);\n    } catch (_) {\n      return false;\n    }\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  };\n  const transformEndpoint = (attachments, resourceEndpoint, gatewayApiVersion) => {\n    if (resourceEndpoint === undefined || resourceEndpoint === null || resourceEndpoint === \"\" || !isValidURL(resourceEndpoint)) {\n      return attachments;\n    }\n    attachments.filter(e => e.attachmentType.toLowerCase() === \"image\".toLowerCase()).map(attachment => {\n      if (attachment.previewUrl) {\n        attachment.previewUrl = createMediaUrlString(attachment.previewUrl, resourceEndpoint, gatewayApiVersion);\n      }\n      if (attachment.url) {\n        attachment.url = createMediaUrlString(attachment.url, resourceEndpoint, gatewayApiVersion);\n      }\n    });\n    return attachments;\n  };\n  const base64decode = encodedString => !coreUtil__default[\"default\"].isNodeLike ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n  exports.base64decode = base64decode;\n  const parseJWT = token => {\n    let [, payload] = token === null || token === void 0 ? void 0 : token.split(\".\");\n    if (payload === undefined) {\n      throw new Error(\"Invalid token\");\n    }\n    payload = payload.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return JSON.parse(decodeURIComponent(escape((0, exports.base64decode)(payload))));\n  };\n  const parseTokenCredential = credential => __awaiter(void 0, void 0, void 0, function* () {\n    const accessToken = yield credential.getToken();\n    const jwtToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.token;\n    const parsedJwtToken = parseJWT(jwtToken);\n    const identityMri = parsedJwtToken.skypeid;\n    const acsResourceId = parsedJwtToken.resourceId;\n    const cloudType = getCloudTypeFromSkypeId(identityMri);\n    const resourceLocation = parsedJwtToken.resourceLocation || \"\";\n    return {\n      jwtToken,\n      acsResourceId,\n      identityMri,\n      cloudType,\n      resourceLocation\n    };\n  });\n  exports.parseTokenCredential = parseTokenCredential;\n  /**\n   * Generated Universally Unique Identifier\n   *\n   * @returns RFC4122 v4 UUID.\n   * @internal\n   */\n  function generateUuid() {\n    return (0, uuid__default[\"default\"].v4)();\n  }\n  const isEudbLocation = location => !!location && !!constants_1.EudbCountries.find(euLocation => euLocation === location);\n  exports.isEudbLocation = isEudbLocation;\n  function getCloudTypeFromSkypeId(skypeId) {\n    const cloudPrefix = skypeId.substring(0, skypeId.indexOf(\":\"));\n    switch (cloudPrefix) {\n      case constants_1.CloudPrefix.OrgId:\n      case constants_1.CloudPrefix.Acs:\n      case constants_1.CloudPrefix.Spool:\n        {\n          return constants_1.CloudType.Public;\n        }\n      case constants_1.CloudPrefix.GccHigh:\n      case constants_1.CloudPrefix.GccHighAcs:\n        {\n          return constants_1.CloudType.GccHigh;\n        }\n      case constants_1.CloudPrefix.Dod:\n      case constants_1.CloudPrefix.DodAcs:\n        {\n          return constants_1.CloudType.Dod;\n        }\n      default:\n        {\n          return constants_1.CloudType.Public;\n        }\n    }\n  }\n});\nunwrapExports(TrouterUtils);\nTrouterUtils.isEudbLocation;\nTrouterUtils.parseTokenCredential;\nTrouterUtils.base64decode;\nTrouterUtils.toTelemetrySender;\nTrouterUtils.toLogProvider;\nTrouterUtils.toMessageHandler;\nTrouterUtils.generateUuid;\nvar TrouterConfigClient_1$1 = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = {\n        enumerable: true,\n        get: function () {\n          return m[k];\n        }\n      };\n    }\n    Object.defineProperty(o, k2, desc);\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {\n    Object.defineProperty(o, \"default\", {\n      enumerable: true,\n      value: v\n    });\n  } : function (o, v) {\n    o[\"default\"] = v;\n  });\n  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.RealTimeNotificationConfiguration = exports.TrouterConfigClient = void 0;\n  const coreClient = __importStar(coreClient__default[\"default\"]); // External library import\n  // Grouped imports from the same module\n\n  class TrouterConfigClient extends coreClient.ServiceClient {\n    constructor(endpoint, options) {\n      // Initializing default values for options\n      if (!options) {\n        options = {};\n      }\n      const packageDetails = `azsdk-js-communication-signaling/${constants_1.PACKAGE_VERSION}`;\n      const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n      const clientOptions = Object.assign(Object.assign({}, options), {\n        userAgentOptions: {\n          userAgentPrefix\n        },\n        additionalPolicies: options.additionalPolicies\n      });\n      super(clientOptions);\n      this.apiVersion = constants_1.CONFIG_API_VERSION;\n      this.endpoint = endpoint;\n      this.httpClient = (0, coreRestPipeline__default[\"default\"].createDefaultHttpClient)();\n    }\n    fetchServiceUrls(credential) {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          const token = (yield credential.getToken()).token;\n          const request = (0, coreRestPipeline__default[\"default\"].createPipelineRequest)({\n            url: `${this.endpoint}/chat/config/realTimeNotifications?api-version=${this.apiVersion}`,\n            method: \"GET\",\n            headers: (0, coreRestPipeline__default[\"default\"].createHttpHeaders)({\n              Authorization: `Bearer ${token}`\n            })\n          });\n          const response = yield this.pipeline.sendRequest(this.httpClient, request);\n          if (response.status !== 200 || !response.bodyAsText) {\n            throw new Error(`Failed to fetch service URLs. Status: ${response.status}, Body: ${response.bodyAsText || \"No response body\"}`);\n          }\n          const data = JSON.parse(response.bodyAsText);\n          // Ensure all necessary data fields are present\n          if (!data.trouterServiceUrl || !data.registrarServiceUrl || !data.cloudType) {\n            throw new Error(\"One or more required fields are missing in the response data\");\n          }\n          return new RealTimeNotificationConfiguration(data.trouterServiceUrl, data.registrarServiceUrl, data.cloudType);\n        } catch (error) {\n          throw new Error(`Error fetching real-time notification configuration from Chat Gateway: ${error.message}`);\n        }\n      });\n    }\n  }\n  exports.TrouterConfigClient = TrouterConfigClient;\n  class RealTimeNotificationConfiguration {\n    constructor(trouterServiceUrl, registrarServiceUrl, cloudType) {\n      this.trouterServiceUrl = trouterServiceUrl;\n      this.registrarServiceUrl = registrarServiceUrl;\n      this.cloudType = cloudType;\n    }\n  }\n  exports.RealTimeNotificationConfiguration = RealTimeNotificationConfiguration;\n});\nunwrapExports(TrouterConfigClient_1$1);\nTrouterConfigClient_1$1.RealTimeNotificationConfiguration;\nTrouterConfigClient_1$1.TrouterConfigClient;\nvar TrouterUtils_1 = TrouterUtils;\nvar TrouterConfigClient_1 = TrouterConfigClient_1$1;\nvar TrouterSettings = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.defaultTelemetrySettings = exports.createSettings = void 0;\n  const defaultSettings = {\n    version: \"1.0.0\",\n    // SignalingClient version, required for trouter connection\n    registrationId: \"\",\n    // Required for trouter connection\n    sessionId: \"\",\n    // Required for trouter connection\n    pnhAppId: \"AcsWeb\",\n    pnhTemplate: \"AcsWeb_Chat_2.1\",\n    platform: \"SPOOL\",\n    platformUIVersion: \"0.0.0\",\n    environment: \"\",\n    // TBD\n    productName: \"acs-chat-web\",\n    trouterServiceUrl: \"\",\n    registrarServiceUrl: \"\",\n    registrarRefreshTimeoutInMs: 350000,\n    timeoutOptions: {\n      connectionTimeoutMs: 20000,\n      fetchTimeoutMs: 10000,\n      pingTimeoutMs: 40000,\n      pongTimeoutMs: 5000,\n      maxBackoffMs: 50000,\n      requestTimeoutMs: 5000\n    },\n    maxRegistrationTimeInMs: 7200000\n  };\n  // Main function to create settings based on environment\n  const createSettings = (credential, options) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const endpoint = options === null || options === void 0 ? void 0 : options.resourceEndpoint;\n    // Throw an error if resourceEndpoint is null or undefined\n    if (endpoint === undefined) {\n      throw new Error(\"'endpoint' cannot be null\");\n    }\n    // Initialize the settings by cloning the default ones\n    const settings = Object.assign({}, defaultSettings);\n    settings.registrationId = (0, TrouterUtils_1.generateUuid)(); // Generate unique IDs\n    settings.sessionId = (0, TrouterUtils_1.generateUuid)();\n    // Fetch the real time configuration from the service\n    const trouterConfigClient = new TrouterConfigClient_1.TrouterConfigClient(endpoint, options);\n    const realTimeNotificationConfiguration = yield trouterConfigClient.fetchServiceUrls(credential);\n    // Append suffix to trouterServiceUrl and registrarServiceUrl\n    settings.trouterServiceUrl = `${realTimeNotificationConfiguration.trouterServiceUrl}/v4/a`;\n    settings.registrarServiceUrl = `${realTimeNotificationConfiguration.registrarServiceUrl}/v3/registrations`;\n    // Customize settings if the environment is INT\n    if (realTimeNotificationConfiguration.cloudType === \"int\") {\n      settings.pnhAppId = \"cns-e2e-test\";\n      settings.pnhTemplate = \"cns-e2e-test:1.8\";\n    }\n    settings.maxRegistrationTimeInMs = (_a = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a !== void 0 ? _a : defaultSettings.maxRegistrationTimeInMs;\n    return settings;\n  });\n  exports.createSettings = createSettings;\n  exports.defaultTelemetrySettings = {\n    // TBD Can we hook up OpenTelemetry?\n    enabled: false\n  };\n});\nunwrapExports(TrouterSettings);\nTrouterSettings.defaultTelemetrySettings;\nTrouterSettings.createSettings;\nvar TrouterSettings_1 = TrouterSettings;\nvar SignalingClient = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CommunicationSignalingClient = exports.ConnectionState = void 0;\n  var ConnectionState = /*#__PURE__*/function (ConnectionState) {\n    ConnectionState[ConnectionState[\"Unknown\"] = 0] = \"Unknown\";\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n    ConnectionState[ConnectionState[\"Disconnected\"] = 3] = \"Disconnected\";\n    ConnectionState[ConnectionState[\"Switching\"] = 9] = \"Switching\";\n    return ConnectionState;\n  }(ConnectionState || (exports.ConnectionState = ConnectionState = {}));\n  class CommunicationSignalingClient {\n    constructor(credential, logger, options) {\n      this.credential = credential;\n      this.logger = logger;\n      this.options = options;\n      this.stateChangedListener = null;\n      this.tokenFetchRetries = 0;\n      this.trouter = (0, tstrouter.createTrouterService)((0, TrouterUtils_1.toLogProvider)(logger));\n    }\n    start() {\n      return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        this.resourceEndpoint = (_a = this.options) === null || _a === void 0 ? void 0 : _a.resourceEndpoint;\n        if (this.resourceEndpoint === undefined) {\n          throw new Error(\"'endpoint' cannot be null\");\n        }\n        this.gatewayApiVersion = ((_b = this.options) === null || _b === void 0 ? void 0 : _b.gatewayApiVersion) || \"2024-03-07\";\n        if (this.config === undefined) {\n          this.config = {\n            trouterSettings: yield (0, TrouterSettings_1.createSettings)(this.credential, this.options),\n            skypeTokenProvider: forceRefresh => __awaiter(this, void 0, void 0, function* () {\n              if (forceRefresh) {\n                this.tokenFetchRetries += 1;\n                if (this.tokenFetchRetries > constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES) {\n                  yield this.stop(true);\n                  throw new Error(`Access token is expired and failed to fetch a valid one after ${constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES} retries`);\n                }\n              } else {\n                this.tokenFetchRetries = 0;\n              }\n              return Promise.resolve((yield this.credential.getToken()).token);\n            }),\n            telemetryConfig: {\n              eventLogger: (0, TrouterUtils_1.toTelemetrySender)(this.logger),\n              settings: TrouterSettings_1.defaultTelemetrySettings\n            }\n          };\n        }\n        this.trouter.start(this.config);\n        this.trouter.setUserActivityState(tstrouter.UserActivityState.Active);\n      });\n    }\n    stop(isTokenExpired) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.trouter.offStateChanged(this.stateChangedListener);\n        this.trouter.clearMessageHandlers();\n        this.trouter.stop(isTokenExpired !== null && isTokenExpired !== void 0 ? isTokenExpired : this.tokenFetchRetries > constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES);\n      });\n    }\n    on(event, listener) {\n      if (event === \"connectionChanged\") {\n        this.trouter.offStateChanged(this.stateChangedListener);\n        this.stateChangedListener = (state, _url) => listener(state);\n        this.trouter.onStateChanged(this.stateChangedListener);\n        return;\n      }\n      this.trouter.registerMessageHandler((0, TrouterUtils_1.toMessageHandler)(event, listener, this.resourceEndpoint, this.gatewayApiVersion));\n    }\n  }\n  exports.CommunicationSignalingClient = CommunicationSignalingClient;\n});\nunwrapExports(SignalingClient);\nSignalingClient.CommunicationSignalingClient;\nSignalingClient.ConnectionState;\nvar require$$0 = SignalingClient;\nvar src = createCommonjsModule(function (module, exports) {\n  // Copyright (c) Microsoft Corporation.\n  // Licensed under the MIT license.\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = {\n        enumerable: true,\n        get: function () {\n          return m[k];\n        }\n      };\n    }\n    Object.defineProperty(o, k2, desc);\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  __exportStar(require$$0, exports);\n});\nvar index = unwrapExports(src);\nmodule.exports = index;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}