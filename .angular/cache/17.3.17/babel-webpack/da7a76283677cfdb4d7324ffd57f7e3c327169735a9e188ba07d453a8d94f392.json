{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a, _b;\n    this._requestContentType = options.requestContentType;\n    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.pipeline.sendRequest(_this._httpClient, request);\n    })();\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  sendOperationRequest(operationArguments, operationSpec) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const endpoint = operationSpec.baseUrl || _this2._endpoint;\n      if (!endpoint) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n      }\n      // Templatized URLs sometimes reference properties on the ServiceClient child class,\n      // so we have to pass `this` below in order to search these properties if they're\n      // not part of OperationArguments\n      const url = getRequestUrl(endpoint, operationSpec, operationArguments, _this2);\n      const request = createPipelineRequest({\n        url\n      });\n      request.method = operationSpec.httpMethod;\n      const operationInfo = getOperationRequestInfo(request);\n      operationInfo.operationSpec = operationSpec;\n      operationInfo.operationArguments = operationArguments;\n      const contentType = operationSpec.contentType || _this2._requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        request.headers.set(\"Content-Type\", contentType);\n      }\n      const options = operationArguments.options;\n      if (options) {\n        const requestOptions = options.requestOptions;\n        if (requestOptions) {\n          if (requestOptions.timeout) {\n            request.timeout = requestOptions.timeout;\n          }\n          if (requestOptions.onUploadProgress) {\n            request.onUploadProgress = requestOptions.onUploadProgress;\n          }\n          if (requestOptions.onDownloadProgress) {\n            request.onDownloadProgress = requestOptions.onDownloadProgress;\n          }\n          if (requestOptions.shouldDeserialize !== undefined) {\n            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n          }\n          if (requestOptions.allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n          }\n        }\n        if (options.abortSignal) {\n          request.abortSignal = options.abortSignal;\n        }\n        if (options.tracingOptions) {\n          request.tracingOptions = options.tracingOptions;\n        }\n      }\n      if (_this2._allowInsecureConnection) {\n        request.allowInsecureConnection = true;\n      }\n      if (request.streamResponseStatusCodes === undefined) {\n        request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n      }\n      try {\n        const rawResponse = yield _this2.sendRequest(request);\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse);\n        }\n        return flatResponse;\n      } catch (error) {\n        if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n          const rawResponse = error.response;\n          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n          error.details = flatResponse;\n          if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(rawResponse, flatResponse, error);\n          }\n        }\n        throw error;\n      }\n    })();\n  }\n}\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n  return undefined;\n}\n//# sourceMappingURL=serviceClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}