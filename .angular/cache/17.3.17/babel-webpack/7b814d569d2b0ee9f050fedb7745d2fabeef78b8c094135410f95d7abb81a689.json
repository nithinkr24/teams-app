{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nimport { randomUUID } from \"../util/uuidUtils.js\";\nimport { concat } from \"../util/concat.js\";\nfunction generateBoundary() {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\nfunction encodeHeaders(headers) {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\nfunction getLength(source) {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\nfunction getTotalLength(sources) {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\nfunction buildRequestBody(_x, _x2, _x3) {\n  return _buildRequestBody.apply(this, arguments);\n}\n/**\n * Name of multipart policy\n */\nfunction _buildRequestBody() {\n  _buildRequestBody = _asyncToGenerator(function* (request, parts, boundary) {\n    const sources = [stringToUint8Array(`--${boundary}`, \"utf-8\"), ...parts.flatMap(part => [stringToUint8Array(\"\\r\\n\", \"utf-8\"), stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"), stringToUint8Array(\"\\r\\n\", \"utf-8\"), part.body, stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\")]), stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\")];\n    const contentLength = getTotalLength(sources);\n    if (contentLength) {\n      request.headers.set(\"Content-Length\", contentLength);\n    }\n    request.body = yield concat(sources);\n  });\n  return _buildRequestBody.apply(this, arguments);\n}\nexport const multipartPolicyName = \"multipartPolicy\";\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);\nfunction assertValidBoundary(boundary) {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n  if (Array.from(boundary).some(x => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n  return {\n    name: multipartPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a;\n        if (!request.multipartBody) {\n          return next(request);\n        }\n        if (request.body) {\n          throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n        }\n        let boundary = request.multipartBody.boundary;\n        const contentTypeHeader = (_a = request.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"multipart/mixed\";\n        const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n        if (!parsedHeader) {\n          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);\n        }\n        const [, contentType, parsedBoundary] = parsedHeader;\n        if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);\n        }\n        boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;\n        if (boundary) {\n          assertValidBoundary(boundary);\n        } else {\n          boundary = generateBoundary();\n        }\n        request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n        yield buildRequestBody(request, request.multipartBody.parts, boundary);\n        request.multipartBody = undefined;\n        return next(request);\n      })();\n    }\n  };\n}\n//# sourceMappingURL=multipartPolicy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}