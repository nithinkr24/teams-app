{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"./abort-controller/AbortError.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  sendRequest(request) {\n    return _asyncToGenerator(function* () {\n      const url = new URL(request.url);\n      const isInsecure = url.protocol !== \"https:\";\n      if (isInsecure && !request.allowInsecureConnection) {\n        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n      }\n      if (request.proxySettings) {\n        throw new Error(\"HTTP proxy is not supported in browser environment\");\n      }\n      try {\n        return yield makeRequest(request);\n      } catch (e) {\n        throw getError(e, request);\n      }\n    })();\n  }\n}\n/**\n * Sends a request\n */\nfunction makeRequest(_x) {\n  return _makeRequest.apply(this, arguments);\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nfunction _makeRequest() {\n  _makeRequest = _asyncToGenerator(function* (request) {\n    const {\n      abortController,\n      abortControllerCleanup\n    } = setupAbortSignal(request);\n    try {\n      const headers = buildFetchHeaders(request.headers);\n      const {\n        streaming,\n        body: requestBody\n      } = buildRequestBody(request);\n      const requestInit = Object.assign(Object.assign({\n        body: requestBody,\n        method: request.method,\n        headers: headers,\n        signal: abortController.signal\n      }, \"credentials\" in Request.prototype ? {\n        credentials: request.withCredentials ? \"include\" : \"same-origin\"\n      } : {}), \"cache\" in Request.prototype ? {\n        cache: \"no-store\"\n      } : {});\n      // According to https://fetch.spec.whatwg.org/#fetch-method,\n      // init.duplex must be set when body is a ReadableStream object.\n      // currently \"half\" is the only valid value.\n      if (streaming) {\n        requestInit.duplex = \"half\";\n      }\n      /**\n       * Developers of the future:\n       * Do not set redirect: \"manual\" as part\n       * of request options.\n       * It will not work as you expect.\n       */\n      const response = yield fetch(request.url, Object.assign(Object.assign({}, requestInit), request.requestOverrides));\n      // If we're uploading a blob, we need to fire the progress event manually\n      if (isBlob(request.body) && request.onUploadProgress) {\n        request.onUploadProgress({\n          loadedBytes: request.body.size\n        });\n      }\n      return buildPipelineResponse(response, request, abortControllerCleanup);\n    } catch (e) {\n      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n      throw e;\n    }\n  });\n  return _makeRequest.apply(this, arguments);\n}\nfunction buildPipelineResponse(_x2, _x3, _x4) {\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction _buildPipelineResponse() {\n  _buildPipelineResponse = _asyncToGenerator(function* (httpResponse, request, abortControllerCleanup) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n      request,\n      headers,\n      status: httpResponse.status\n    };\n    const bodyStream = isWebReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {\n      onProgress: request.onDownloadProgress,\n      onEnd: abortControllerCleanup\n    }) : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n      if (request.enableBrowserStreams) {\n        response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n      } else {\n        const responseStream = new Response(bodyStream);\n        response.blobBody = responseStream.blob();\n        abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n      }\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.bodyAsText = yield responseStream.text();\n      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n    }\n    return response;\n  });\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController();\n  // Cleanup function\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n    }\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      var _a;\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e, request) {\n  var _a;\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isWebReadableStream(body) ? {\n    streaming: true,\n    body: buildBodyStream(body, {\n      onProgress: request.onUploadProgress\n    })\n  } : {\n    streaming: false,\n    body\n  };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, options = {}) {\n  let loadedBytes = 0;\n  const {\n    onProgress,\n    onEnd\n  } = options;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      },\n      flush() {\n        onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      pull(controller) {\n        return _asyncToGenerator(function* () {\n          var _a;\n          const {\n            done,\n            value\n          } = yield reader.read();\n          // When no more data needs to be consumed, break the reading\n          if (done || !value) {\n            onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n            // Close the stream\n            controller.close();\n            reader.releaseLock();\n            return;\n          }\n          loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n          // Enqueue the next data chunk into our target stream\n          controller.enqueue(value);\n          if (onProgress) {\n            onProgress({\n              loadedBytes\n            });\n          }\n        })();\n      },\n      cancel(reason) {\n        onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n        return reader.cancel(reason);\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","isWebReadableStream","isBlob","body","Blob","FetchHttpClient","sendRequest","request","_asyncToGenerator","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","_x","_makeRequest","apply","arguments","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","streaming","requestBody","buildRequestBody","requestInit","Object","assign","method","signal","Request","prototype","credentials","withCredentials","cache","duplex","response","fetch","requestOverrides","onUploadProgress","loadedBytes","size","buildPipelineResponse","_x2","_x3","_x4","_buildPipelineResponse","httpResponse","_a","_b","buildPipelineHeaders","status","bodyStream","buildBodyStream","onProgress","onDownloadProgress","onEnd","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","options","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","flush","reader","getReader","ReadableStream","pull","done","read","close","releaseLock","cancel","reason","createFetchHttpClient","self"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/fetchHttpClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"./abort-controller/AbortError.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n    // File objects count as a type of Blob, so we want to use instanceof explicitly\n    return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    async sendRequest(request) {\n        const url = new URL(request.url);\n        const isInsecure = url.protocol !== \"https:\";\n        if (isInsecure && !request.allowInsecureConnection) {\n            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n        }\n        if (request.proxySettings) {\n            throw new Error(\"HTTP proxy is not supported in browser environment\");\n        }\n        try {\n            return await makeRequest(request);\n        }\n        catch (e) {\n            throw getError(e, request);\n        }\n    }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n    const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n    try {\n        const headers = buildFetchHeaders(request.headers);\n        const { streaming, body: requestBody } = buildRequestBody(request);\n        const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers: headers, signal: abortController.signal }, (\"credentials\" in Request.prototype\n            ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n            : {})), (\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}));\n        // According to https://fetch.spec.whatwg.org/#fetch-method,\n        // init.duplex must be set when body is a ReadableStream object.\n        // currently \"half\" is the only valid value.\n        if (streaming) {\n            requestInit.duplex = \"half\";\n        }\n        /**\n         * Developers of the future:\n         * Do not set redirect: \"manual\" as part\n         * of request options.\n         * It will not work as you expect.\n         */\n        const response = await fetch(request.url, Object.assign(Object.assign({}, requestInit), request.requestOverrides));\n        // If we're uploading a blob, we need to fire the progress event manually\n        if (isBlob(request.body) && request.onUploadProgress) {\n            request.onUploadProgress({ loadedBytes: request.body.size });\n        }\n        return buildPipelineResponse(response, request, abortControllerCleanup);\n    }\n    catch (e) {\n        abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n        throw e;\n    }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n        request,\n        headers,\n        status: httpResponse.status,\n    };\n    const bodyStream = isWebReadableStream(httpResponse.body)\n        ? buildBodyStream(httpResponse.body, {\n            onProgress: request.onDownloadProgress,\n            onEnd: abortControllerCleanup,\n        })\n        : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||\n        ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n        if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n        }\n        else {\n            const responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n            abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n        }\n    }\n    else {\n        const responseStream = new Response(bodyStream);\n        response.bodyAsText = await responseStream.text();\n        abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n    }\n    return response;\n}\nfunction setupAbortSignal(request) {\n    const abortController = new AbortController();\n    // Cleanup function\n    let abortControllerCleanup;\n    /**\n     * Attach an abort listener to the request\n     */\n    let abortListener;\n    if (request.abortSignal) {\n        if (request.abortSignal.aborted) {\n            throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n        }\n        abortListener = (event) => {\n            if (event.type === \"abort\") {\n                abortController.abort();\n            }\n        };\n        request.abortSignal.addEventListener(\"abort\", abortListener);\n        abortControllerCleanup = () => {\n            var _a;\n            if (abortListener) {\n                (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n            }\n        };\n    }\n    // If a timeout was passed, call the abort signal once the time elapses\n    if (request.timeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n        }, request.timeout);\n    }\n    return { abortController, abortControllerCleanup };\n}\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e, request) {\n    var _a;\n    if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        return e;\n    }\n    else {\n        return new RestError(`Error sending request: ${e.message}`, {\n            code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n            request,\n        });\n    }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n    const headers = new Headers();\n    for (const [name, value] of pipelineHeaders) {\n        headers.append(name, value);\n    }\n    return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n    const responseHeaders = createHttpHeaders();\n    for (const [name, value] of httpResponse.headers) {\n        responseHeaders.set(name, value);\n    }\n    return responseHeaders;\n}\nfunction buildRequestBody(request) {\n    const body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (isNodeReadableStream(body)) {\n        throw new Error(\"Node streams are not supported in browser environment.\");\n    }\n    return isWebReadableStream(body)\n        ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n        : { streaming: false, body };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, options = {}) {\n    let loadedBytes = 0;\n    const { onProgress, onEnd } = options;\n    // If the current browser supports pipeThrough we use a TransformStream\n    // to report progress\n    if (isTransformStreamSupported(readableStream)) {\n        return readableStream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                if (chunk === null) {\n                    controller.terminate();\n                    return;\n                }\n                controller.enqueue(chunk);\n                loadedBytes += chunk.length;\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n            flush() {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n            },\n        }));\n    }\n    else {\n        // If we can't use transform streams, wrap the original stream in a new readable stream\n        // and use pull to enqueue each chunk and report progress.\n        const reader = readableStream.getReader();\n        return new ReadableStream({\n            async pull(controller) {\n                var _a;\n                const { done, value } = await reader.read();\n                // When no more data needs to be consumed, break the reading\n                if (done || !value) {\n                    onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n                    // Close the stream\n                    controller.close();\n                    reader.releaseLock();\n                    return;\n                }\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n            cancel(reason) {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n    return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}