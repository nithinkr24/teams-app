{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n  const stringifyXML = options.stringifyXML;\n  return {\n    name: serializationPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const operationInfo = getOperationRequestInfo(request);\n        const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n        const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n        if (operationSpec && operationArguments) {\n          serializeHeaders(request, operationArguments, operationSpec);\n          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n        }\n        return next(request);\n      })();\n    }\n  };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n  var _a, _b;\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n        }\n      }\n    }\n  }\n  const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n  throw new Error(\"XML serialization unsupported!\");\n}) {\n  var _a, _b, _c, _d, _e;\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY\n    }\n  };\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperTypeNames.Stream;\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n  return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return {\n      [elementName]: obj\n    };\n  }\n  const result = {\n    [elementName]: obj\n  };\n  result[XML_ATTRKEY] = {\n    [xmlNamespaceKey]: xmlNamespace\n  };\n  return result;\n}\n//# sourceMappingURL=serializationPolicy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}