{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isRestError, RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { createPipelineRequest } from \"../pipelineRequest.js\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers.js\";\nimport { isReadableStream } from \"../util/typeGuards.js\";\nimport { buildMultipartBody } from \"./multipart.js\";\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport function sendRequest(_x, _x2, _x3) {\n  return _sendRequest.apply(this, arguments);\n}\n/**\n * Function to determine the request content type\n * @param options - request options InternalRequestParameters\n * @returns returns the content-type\n */\nfunction _sendRequest() {\n  _sendRequest = _asyncToGenerator(function* (method, url, pipeline, options = {}, customHttpClient) {\n    var _a;\n    const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();\n    const request = buildPipelineRequest(method, url, options);\n    try {\n      const response = yield pipeline.sendRequest(httpClient, request);\n      const headers = response.headers.toJSON();\n      const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;\n      const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n      const body = stream !== null && stream !== void 0 ? stream : parsedBody;\n      if (options === null || options === void 0 ? void 0 : options.onResponse) {\n        options.onResponse(Object.assign(Object.assign({}, response), {\n          request,\n          rawHeaders: headers,\n          parsedBody\n        }));\n      }\n      return {\n        request,\n        headers,\n        status: `${response.status}`,\n        body\n      };\n    } catch (e) {\n      if (isRestError(e) && e.response && options.onResponse) {\n        const {\n          response\n        } = e;\n        const rawHeaders = response.headers.toJSON();\n        // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property\n        options === null || options === void 0 ? void 0 : options.onResponse(Object.assign(Object.assign({}, response), {\n          request,\n          rawHeaders\n        }), e);\n      }\n      throw e;\n    }\n  });\n  return _sendRequest.apply(this, arguments);\n}\nfunction getRequestContentType(options = {}) {\n  var _a, _b, _c;\n  return (_c = (_a = options.contentType) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b[\"content-type\"]) !== null && _c !== void 0 ? _c : getContentType(options.body);\n}\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body) {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n  if (typeof body === \"string\") {\n    try {\n      JSON.parse(body);\n      return \"application/json\";\n    } catch (error) {\n      // If we fail to parse the body, it is not json\n      return undefined;\n    }\n  }\n  // By default return json\n  return \"application/json\";\n}\nfunction buildPipelineRequest(method, url, options = {}) {\n  var _a, _b, _c;\n  const requestContentType = getRequestContentType(options);\n  const {\n    body,\n    multipartBody\n  } = getRequestBody(options.body, requestContentType);\n  const hasContent = body !== undefined || multipartBody !== undefined;\n  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), {\n    accept: (_c = (_a = options.accept) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b.accept) !== null && _c !== void 0 ? _c : \"application/json\"\n  }), hasContent && requestContentType && {\n    \"content-type\": requestContentType\n  }));\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    multipartBody,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined\n  });\n}\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body, contentType = \"\") {\n  if (body === undefined) {\n    return {\n      body: undefined\n    };\n  }\n  if (typeof FormData !== \"undefined\" && body instanceof FormData) {\n    return {\n      body\n    };\n  }\n  if (isReadableStream(body)) {\n    return {\n      body\n    };\n  }\n  if (ArrayBuffer.isView(body)) {\n    return {\n      body: body instanceof Uint8Array ? body : JSON.stringify(body)\n    };\n  }\n  const firstType = contentType.split(\";\")[0];\n  switch (firstType) {\n    case \"application/json\":\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"multipart/form-data\":\n      if (Array.isArray(body)) {\n        return {\n          multipartBody: buildMultipartBody(body)\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"text/plain\":\n      return {\n        body: String(body)\n      };\n    default:\n      if (typeof body === \"string\") {\n        return {\n          body\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n  }\n}\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response) {\n  var _a, _b;\n  // Set the default response type\n  const contentType = (_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : \"\";\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\nfunction createParseError(response, err) {\n  var _a;\n  const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n  const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response\n  });\n}","map":{"version":3,"names":["isRestError","RestError","createHttpHeaders","createPipelineRequest","getCachedDefaultHttpsClient","isReadableStream","buildMultipartBody","sendRequest","_x","_x2","_x3","_sendRequest","apply","arguments","_asyncToGenerator","method","url","pipeline","options","customHttpClient","_a","httpClient","request","buildPipelineRequest","response","headers","toJSON","stream","readableStreamBody","browserStreamBody","parsedBody","responseAsStream","undefined","getResponseBody","body","onResponse","Object","assign","rawHeaders","status","e","getRequestContentType","_b","_c","contentType","getContentType","ArrayBuffer","isView","JSON","parse","error","requestContentType","multipartBody","getRequestBody","hasContent","accept","allowInsecureConnection","abortSignal","onUploadProgress","onDownloadProgress","timeout","enableBrowserStreams","streamResponseStatusCodes","Set","Number","POSITIVE_INFINITY","FormData","Uint8Array","stringify","firstType","split","Array","isArray","String","get","bodyToParse","bodyAsText","createParseError","err","msg","errCode","code","PARSE_ERROR","statusCode"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/client/sendRequest.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isRestError, RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { createPipelineRequest } from \"../pipelineRequest.js\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers.js\";\nimport { isReadableStream } from \"../util/typeGuards.js\";\nimport { buildMultipartBody } from \"./multipart.js\";\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {\n    var _a;\n    const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();\n    const request = buildPipelineRequest(method, url, options);\n    try {\n        const response = await pipeline.sendRequest(httpClient, request);\n        const headers = response.headers.toJSON();\n        const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;\n        const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n        const body = stream !== null && stream !== void 0 ? stream : parsedBody;\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(Object.assign(Object.assign({}, response), { request, rawHeaders: headers, parsedBody }));\n        }\n        return {\n            request,\n            headers,\n            status: `${response.status}`,\n            body,\n        };\n    }\n    catch (e) {\n        if (isRestError(e) && e.response && options.onResponse) {\n            const { response } = e;\n            const rawHeaders = response.headers.toJSON();\n            // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property\n            options === null || options === void 0 ? void 0 : options.onResponse(Object.assign(Object.assign({}, response), { request, rawHeaders }), e);\n        }\n        throw e;\n    }\n}\n/**\n * Function to determine the request content type\n * @param options - request options InternalRequestParameters\n * @returns returns the content-type\n */\nfunction getRequestContentType(options = {}) {\n    var _a, _b, _c;\n    return ((_c = (_a = options.contentType) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b[\"content-type\"]) !== null && _c !== void 0 ? _c : getContentType(options.body));\n}\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body) {\n    if (ArrayBuffer.isView(body)) {\n        return \"application/octet-stream\";\n    }\n    if (typeof body === \"string\") {\n        try {\n            JSON.parse(body);\n            return \"application/json\";\n        }\n        catch (error) {\n            // If we fail to parse the body, it is not json\n            return undefined;\n        }\n    }\n    // By default return json\n    return \"application/json\";\n}\nfunction buildPipelineRequest(method, url, options = {}) {\n    var _a, _b, _c;\n    const requestContentType = getRequestContentType(options);\n    const { body, multipartBody } = getRequestBody(options.body, requestContentType);\n    const hasContent = body !== undefined || multipartBody !== undefined;\n    const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, (options.headers ? options.headers : {})), { accept: (_c = (_a = options.accept) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b.accept) !== null && _c !== void 0 ? _c : \"application/json\" }), (hasContent &&\n        requestContentType && {\n        \"content-type\": requestContentType,\n    })));\n    return createPipelineRequest({\n        url,\n        method,\n        body,\n        multipartBody,\n        headers,\n        allowInsecureConnection: options.allowInsecureConnection,\n        abortSignal: options.abortSignal,\n        onUploadProgress: options.onUploadProgress,\n        onDownloadProgress: options.onDownloadProgress,\n        timeout: options.timeout,\n        enableBrowserStreams: true,\n        streamResponseStatusCodes: options.responseAsStream\n            ? new Set([Number.POSITIVE_INFINITY])\n            : undefined,\n    });\n}\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body, contentType = \"\") {\n    if (body === undefined) {\n        return { body: undefined };\n    }\n    if (typeof FormData !== \"undefined\" && body instanceof FormData) {\n        return { body };\n    }\n    if (isReadableStream(body)) {\n        return { body };\n    }\n    if (ArrayBuffer.isView(body)) {\n        return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };\n    }\n    const firstType = contentType.split(\";\")[0];\n    switch (firstType) {\n        case \"application/json\":\n            return { body: JSON.stringify(body) };\n        case \"multipart/form-data\":\n            if (Array.isArray(body)) {\n                return { multipartBody: buildMultipartBody(body) };\n            }\n            return { body: JSON.stringify(body) };\n        case \"text/plain\":\n            return { body: String(body) };\n        default:\n            if (typeof body === \"string\") {\n                return { body };\n            }\n            return { body: JSON.stringify(body) };\n    }\n}\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response) {\n    var _a, _b;\n    // Set the default response type\n    const contentType = (_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\";\n    const firstType = contentType.split(\";\")[0];\n    const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : \"\";\n    if (firstType === \"text/plain\") {\n        return String(bodyToParse);\n    }\n    // Default to \"application/json\" and fallback to string;\n    try {\n        return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n    }\n    catch (error) {\n        // If we were supposed to get a JSON object and failed to\n        // parse, throw a parse error\n        if (firstType === \"application/json\") {\n            throw createParseError(response, error);\n        }\n        // We are not sure how to handle the response so we return it as\n        // plain text.\n        return String(bodyToParse);\n    }\n}\nfunction createParseError(response, err) {\n    var _a;\n    const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n    const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;\n    return new RestError(msg, {\n        code: errCode,\n        statusCode: response.status,\n        request: response.request,\n        response: response,\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}