{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n  return mapperTypeName !== \"Composite\" && mapperTypeName !== \"Dictionary\" && (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n    return responseObject.shouldWrapBody ? {\n      body: null\n    } : null;\n  } else {\n    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {\n      body: responseObject.body\n    }) : combinedHeadersAndBody;\n  }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n  var _a, _b;\n  const parsedHeaders = fullResponse.parsedHeaders;\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      body: fullResponse.parsedBody\n    });\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody\n    });\n  }\n  const modelProperties = expectedBodyTypeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n  const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n      }\n    }\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;\n  }\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)\n  });\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}