{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nfunction trySendRequest(_x, _x2) {\n  return _trySendRequest.apply(this, arguments);\n}\n/**\n * Default authorize request handler\n */\nfunction _trySendRequest() {\n  _trySendRequest = _asyncToGenerator(function* (request, next) {\n    try {\n      return [yield next(request), undefined];\n    } catch (e) {\n      if (isRestError(e) && e.response) {\n        return [e.response, e];\n      } else {\n        throw e;\n      }\n    }\n  });\n  return _trySendRequest.apply(this, arguments);\n}\nfunction defaultAuthorizeRequest(_x3) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    // Enable CAE true by default\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions,\n      enableCae: true\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\nfunction isChallengeResponse(response) {\n  return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nfunction authorizeRequestOnCaeChallenge(_x4, _x5) {\n  return _authorizeRequestOnCaeChallenge.apply(this, arguments);\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nfunction _authorizeRequestOnCaeChallenge() {\n  _authorizeRequestOnCaeChallenge = _asyncToGenerator(function* (onChallengeOptions, caeClaims) {\n    var _a;\n    const {\n      scopes\n    } = onChallengeOptions;\n    const accessToken = yield onChallengeOptions.getAccessToken(scopes, {\n      enableCae: true,\n      claims: caeClaims\n    });\n    if (!accessToken) {\n      return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n  });\n  return _authorizeRequestOnCaeChallenge.apply(this, arguments);\n}\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a, _b, _c;\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks)\n  };\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential ? createTokenCycler(credential /* , options */) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n        let shouldSendRequest;\n        [response, error] = yield trySendRequest(request, next);\n        if (isChallengeResponse(response)) {\n          let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n          // Handle CAE by default when receive CAE claim\n          if (claims) {\n            let parsedClaim;\n            // Return the response immediately if claims is not a valid base64 encoded string\n            try {\n              parsedClaim = atob(claims);\n            } catch (e) {\n              logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n              return response;\n            }\n            shouldSendRequest = yield authorizeRequestOnCaeChallenge({\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              response,\n              request,\n              getAccessToken,\n              logger\n            }, parsedClaim);\n            // Send updated request and handle response for RestError\n            if (shouldSendRequest) {\n              [response, error] = yield trySendRequest(request, next);\n            }\n          } else if (callbacks.authorizeRequestOnChallenge) {\n            // Handle custom challenges when client provides custom callback\n            shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              request,\n              response,\n              getAccessToken,\n              logger\n            });\n            // Send updated request and handle response for RestError\n            if (shouldSendRequest) {\n              [response, error] = yield trySendRequest(request, next);\n            }\n            // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n            if (isChallengeResponse(response)) {\n              claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n              if (claims) {\n                let parsedClaim;\n                try {\n                  parsedClaim = atob(claims);\n                } catch (e) {\n                  logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                  return response;\n                }\n                shouldSendRequest = yield authorizeRequestOnCaeChallenge({\n                  scopes: Array.isArray(scopes) ? scopes : [scopes],\n                  response,\n                  request,\n                  getAccessToken,\n                  logger\n                }, parsedClaim);\n                // Send updated request and handle response for RestError\n                if (shouldSendRequest) {\n                  [response, error] = yield trySendRequest(request, next);\n                }\n              }\n            }\n          }\n        }\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n  };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n  // The challenge regex captures parameteres with either quotes values or unquoted values\n  const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n  // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n  const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n  const parsedChallenges = [];\n  let match;\n  // Iterate over each challenge match\n  while ((match = challengeRegex.exec(challenges)) !== null) {\n    const scheme = match[1];\n    const paramsString = match[2];\n    const params = {};\n    let paramMatch;\n    // Iterate over each parameter match\n    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n      params[paramMatch[1]] = paramMatch[2];\n    }\n    parsedChallenges.push({\n      scheme,\n      params\n    });\n  }\n  return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n  var _a;\n  if (!challenges) {\n    return;\n  }\n  // Find all challenges present in the header\n  const parsedChallenges = parseChallenges(challenges);\n  return (_a = parsedChallenges.find(x => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","isRestError","bearerTokenAuthenticationPolicyName","trySendRequest","_x","_x2","_trySendRequest","apply","arguments","_asyncToGenerator","request","next","undefined","e","response","defaultAuthorizeRequest","_x3","_defaultAuthorizeRequest","options","scopes","getAccessToken","getTokenOptions","abortSignal","tracingOptions","enableCae","accessToken","headers","set","token","isChallengeResponse","status","has","authorizeRequestOnCaeChallenge","_x4","_x5","_authorizeRequestOnCaeChallenge","onChallengeOptions","caeClaims","_a","claims","tokenType","bearerTokenAuthenticationPolicy","_b","_c","credential","challengeCallbacks","callbacks","authorizeRequest","bind","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","url","toLowerCase","startsWith","Error","Array","isArray","error","shouldSendRequest","getCaeChallengeClaims","get","parsedClaim","atob","warning","parseChallenges","challenges","challengeRegex","paramRegex","parsedChallenges","match","exec","scheme","paramsString","params","paramMatch","push","find","x"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(request, next) {\n    try {\n        return [await next(request), undefined];\n    }\n    catch (e) {\n        if (isRestError(e) && e.response) {\n            return [e.response, e];\n        }\n        else {\n            throw e;\n        }\n    }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    // Enable CAE true by default\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n        enableCae: true,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response) {\n    return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {\n    var _a;\n    const { scopes } = onChallengeOptions;\n    const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n        enableCae: true,\n        claims: caeClaims,\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a, _b, _c;\n    const { credential, scopes, challengeCallbacks } = options;\n    const logger = options.logger || coreLogger;\n    const callbacks = {\n        authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n        authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks),\n    };\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            let shouldSendRequest;\n            [response, error] = await trySendRequest(request, next);\n            if (isChallengeResponse(response)) {\n                let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                // Handle CAE by default when receive CAE claim\n                if (claims) {\n                    let parsedClaim;\n                    // Return the response immediately if claims is not a valid base64 encoded string\n                    try {\n                        parsedClaim = atob(claims);\n                    }\n                    catch (e) {\n                        logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                        return response;\n                    }\n                    shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        response,\n                        request,\n                        getAccessToken,\n                        logger,\n                    }, parsedClaim);\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                }\n                else if (callbacks.authorizeRequestOnChallenge) {\n                    // Handle custom challenges when client provides custom callback\n                    shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        request,\n                        response,\n                        getAccessToken,\n                        logger,\n                    });\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                    // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n                    if (isChallengeResponse(response)) {\n                        claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                        if (claims) {\n                            let parsedClaim;\n                            try {\n                                parsedClaim = atob(claims);\n                            }\n                            catch (e) {\n                                logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                                return response;\n                            }\n                            shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                                response,\n                                request,\n                                getAccessToken,\n                                logger,\n                            }, parsedClaim);\n                            // Send updated request and handle response for RestError\n                            if (shouldSendRequest) {\n                                [response, error] = await trySendRequest(request, next);\n                            }\n                        }\n                    }\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n    // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n    // The challenge regex captures parameteres with either quotes values or unquoted values\n    const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n    // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n    // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n    const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n    const parsedChallenges = [];\n    let match;\n    // Iterate over each challenge match\n    while ((match = challengeRegex.exec(challenges)) !== null) {\n        const scheme = match[1];\n        const paramsString = match[2];\n        const params = {};\n        let paramMatch;\n        // Iterate over each parameter match\n        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n            params[paramMatch[1]] = paramMatch[2];\n        }\n        parsedChallenges.push({ scheme, params });\n    }\n    return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n    var _a;\n    if (!challenges) {\n        return;\n    }\n    // Find all challenges present in the header\n    const parsedChallenges = parseChallenges(challenges);\n    return (_a = parsedChallenges.find((x) => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}