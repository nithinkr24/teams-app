{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const response = yield next(request);\n        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n      })();\n    }\n  };\n}\nfunction getOperationResponseMap(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  let result;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\nfunction deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction _deserializeResponseBody() {\n  _deserializeResponseBody = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = yield parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n      return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n      return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const {\n      error,\n      shouldReturnResponse\n    } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n      throw error;\n    } else if (shouldReturnResponse) {\n      return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n      if (responseSpec.bodyMapper) {\n        let valueToDeserialize = parsedResponse.parsedBody;\n        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n        }\n        try {\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n        } catch (deserializeError) {\n          const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse\n          });\n          throw restError;\n        }\n      } else if (operationSpec.httpMethod === \"HEAD\") {\n        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n      }\n      if (responseSpec.headersMapper) {\n        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", {\n          xml: {},\n          ignoreUnknownProperties: true\n        });\n      }\n    }\n    return parsedResponse;\n  });\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n  var _a, _b, _c, _d, _e;\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  });\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // and the parsed body doesn't look like an error object,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec && !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n    throw error;\n  }\n  const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n      }\n      const internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    }\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\nfunction parse(_x6, _x7, _x8, _x9, _x0) {\n  return _parse.apply(this, arguments);\n}\nfunction _parse() {\n  _parse = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {\n      const text = operationResponse.bodyAsText;\n      const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n      const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n      try {\n        if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n          operationResponse.parsedBody = JSON.parse(text);\n          return operationResponse;\n        } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n          if (!parseXML) {\n            throw new Error(\"Parsing XML not supported.\");\n          }\n          const body = yield parseXML(text, opts.xml);\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        }\n      } catch (err) {\n        const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n        const errCode = err.code || RestError.PARSE_ERROR;\n        const e = new RestError(msg, {\n          code: errCode,\n          statusCode: operationResponse.status,\n          request: operationResponse.request,\n          response: operationResponse\n        });\n        throw e;\n      }\n    }\n    return operationResponse;\n  });\n  return _parse.apply(this, arguments);\n}","map":{"version":3,"names":["XML_CHARKEY","RestError","MapperTypeNames","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","options","_a","_b","_c","_d","_e","_f","_g","jsonContentTypes","expectedContentTypes","json","xmlContentTypes","xml","parseXML","serializerOptions","updatedOptions","rootName","includeRoot","xmlCharKey","name","sendRequest","request","next","_asyncToGenerator","response","deserializeResponseBody","getOperationResponseMap","parsedResponse","result","operationInfo","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","undefined","_x","_x2","_x3","_x4","_x5","_deserializeResponseBody","apply","arguments","parse","responseSpec","error","shouldReturnResponse","handleErrorResponse","bodyMapper","valueToDeserialize","parsedBody","isXML","type","Sequence","xmlElementName","serializer","deserialize","deserializeError","restError","bodyAsText","statusCode","httpMethod","headersMapper","parsedHeaders","headers","toJSON","ignoreUnknownProperties","isOperationSpecEmpty","expectedStatusCodes","Object","keys","length","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","initialErrorMessage","streamResponseStatusCodes","has","code","message","defaultBodyMapper","defaultHeadersMapper","deserializedError","elementName","internalError","defaultError","_x6","_x7","_x8","_x9","_x0","_parse","operationResponse","opts","text","contentType","get","contentComponents","split","map","component","toLowerCase","some","indexOf","JSON","Error","body","err","msg","errCode","PARSE_ERROR","e"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-client/dist/browser/deserializationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n    const parseXML = options.parseXML;\n    const serializerOptions = options.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,\n        },\n    };\n    return {\n        name: deserializationPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n        },\n    };\n}\nfunction getOperationResponseMap(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (operationSpec) {\n        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n        return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n        return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n        throw error;\n    }\n    else if (shouldReturnResponse) {\n        return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n        if (responseSpec.bodyMapper) {\n            let valueToDeserialize = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n                valueToDeserialize =\n                    typeof valueToDeserialize === \"object\"\n                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                        : [];\n            }\n            try {\n                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n            }\n            catch (deserializeError) {\n                const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n                    statusCode: parsedResponse.status,\n                    request: parsedResponse.request,\n                    response: parsedResponse,\n                });\n                throw restError;\n            }\n        }\n        else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n        }\n        if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", { xml: {}, ignoreUnknownProperties: true });\n        }\n    }\n    return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n    var _a, _b, _c, _d, _e;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, {\n        statusCode: parsedResponse.status,\n        request: parsedResponse.request,\n        response: parsedResponse,\n    });\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // and the parsed body doesn't look like an error object,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec &&\n        !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let deserializedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n                    valueToDeserialize = [];\n                    const elementName = defaultBodyMapper.xmlElementName;\n                    if (typeof parsedBody === \"object\" && elementName) {\n                        valueToDeserialize = parsedBody[elementName];\n                    }\n                }\n                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n            }\n            const internalError = parsedBody.error || deserializedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = deserializedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders =\n                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&\n        operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        try {\n            if (contentComponents.length === 0 ||\n                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n                operationResponse.parsedBody = JSON.parse(text);\n                return operationResponse;\n            }\n            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n                if (!parseXML) {\n                    throw new Error(\"Parsing XML not supported.\");\n                }\n                const body = await parseXML(text, opts.xml);\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            }\n        }\n        catch (err) {\n            const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n            const errCode = err.code || RestError.PARSE_ERROR;\n            const e = new RestError(msg, {\n                code: errCode,\n                statusCode: operationResponse.status,\n                request: operationResponse.request,\n                response: operationResponse,\n            });\n            throw e;\n        }\n    }\n    return operationResponse;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}