{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a, _b;\n    this._requestContentType = options.requestContentType;\n    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.pipeline.sendRequest(_this._httpClient, request);\n    })();\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  sendOperationRequest(operationArguments, operationSpec) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const endpoint = operationSpec.baseUrl || _this2._endpoint;\n      if (!endpoint) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n      }\n      // Templatized URLs sometimes reference properties on the ServiceClient child class,\n      // so we have to pass `this` below in order to search these properties if they're\n      // not part of OperationArguments\n      const url = getRequestUrl(endpoint, operationSpec, operationArguments, _this2);\n      const request = createPipelineRequest({\n        url\n      });\n      request.method = operationSpec.httpMethod;\n      const operationInfo = getOperationRequestInfo(request);\n      operationInfo.operationSpec = operationSpec;\n      operationInfo.operationArguments = operationArguments;\n      const contentType = operationSpec.contentType || _this2._requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        request.headers.set(\"Content-Type\", contentType);\n      }\n      const options = operationArguments.options;\n      if (options) {\n        const requestOptions = options.requestOptions;\n        if (requestOptions) {\n          if (requestOptions.timeout) {\n            request.timeout = requestOptions.timeout;\n          }\n          if (requestOptions.onUploadProgress) {\n            request.onUploadProgress = requestOptions.onUploadProgress;\n          }\n          if (requestOptions.onDownloadProgress) {\n            request.onDownloadProgress = requestOptions.onDownloadProgress;\n          }\n          if (requestOptions.shouldDeserialize !== undefined) {\n            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n          }\n          if (requestOptions.allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n          }\n        }\n        if (options.abortSignal) {\n          request.abortSignal = options.abortSignal;\n        }\n        if (options.tracingOptions) {\n          request.tracingOptions = options.tracingOptions;\n        }\n      }\n      if (_this2._allowInsecureConnection) {\n        request.allowInsecureConnection = true;\n      }\n      if (request.streamResponseStatusCodes === undefined) {\n        request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n      }\n      try {\n        const rawResponse = yield _this2.sendRequest(request);\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse);\n        }\n        return flatResponse;\n      } catch (error) {\n        if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n          const rawResponse = error.response;\n          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n          error.details = flatResponse;\n          if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(rawResponse, flatResponse, error);\n          }\n        }\n        throw error;\n      }\n    })();\n  }\n}\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n  return undefined;\n}","map":{"version":3,"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","logger","ServiceClient","constructor","options","_a","_b","_requestContentType","requestContentType","_endpoint","endpoint","baseUri","warning","_allowInsecureConnection","allowInsecureConnection","_httpClient","httpClient","pipeline","createDefaultPipeline","additionalPolicies","length","policy","position","afterPhase","undefined","addPolicy","sendRequest","request","_this","_asyncToGenerator","sendOperationRequest","operationArguments","operationSpec","_this2","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential","Object","assign"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-client/dist/browser/serviceClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._requestContentType = options.requestContentType;\n        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n        if (options.baseUri) {\n            logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n        }\n        this._allowInsecureConnection = options.allowInsecureConnection;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this.pipeline = options.pipeline || createDefaultPipeline(options);\n        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n            for (const { policy, position } of options.additionalPolicies) {\n                // Sign happens after Retry and is commonly needed to occur\n                // before policies that intercept post-retry.\n                const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n                this.pipeline.addPolicy(policy, {\n                    afterPhase,\n                });\n            }\n        }\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    async sendRequest(request) {\n        return this.pipeline.sendRequest(this._httpClient, request);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @typeParam T - The typed result of the request, based on the OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     */\n    async sendOperationRequest(operationArguments, operationSpec) {\n        const endpoint = operationSpec.baseUrl || this._endpoint;\n        if (!endpoint) {\n            throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n        }\n        // Templatized URLs sometimes reference properties on the ServiceClient child class,\n        // so we have to pass `this` below in order to search these properties if they're\n        // not part of OperationArguments\n        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n        const request = createPipelineRequest({\n            url,\n        });\n        request.method = operationSpec.httpMethod;\n        const operationInfo = getOperationRequestInfo(request);\n        operationInfo.operationSpec = operationSpec;\n        operationInfo.operationArguments = operationArguments;\n        const contentType = operationSpec.contentType || this._requestContentType;\n        if (contentType && operationSpec.requestBody) {\n            request.headers.set(\"Content-Type\", contentType);\n        }\n        const options = operationArguments.options;\n        if (options) {\n            const requestOptions = options.requestOptions;\n            if (requestOptions) {\n                if (requestOptions.timeout) {\n                    request.timeout = requestOptions.timeout;\n                }\n                if (requestOptions.onUploadProgress) {\n                    request.onUploadProgress = requestOptions.onUploadProgress;\n                }\n                if (requestOptions.onDownloadProgress) {\n                    request.onDownloadProgress = requestOptions.onDownloadProgress;\n                }\n                if (requestOptions.shouldDeserialize !== undefined) {\n                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n                }\n                if (requestOptions.allowInsecureConnection) {\n                    request.allowInsecureConnection = true;\n                }\n            }\n            if (options.abortSignal) {\n                request.abortSignal = options.abortSignal;\n            }\n            if (options.tracingOptions) {\n                request.tracingOptions = options.tracingOptions;\n            }\n        }\n        if (this._allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n        }\n        if (request.streamResponseStatusCodes === undefined) {\n            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n        }\n        try {\n            const rawResponse = await this.sendRequest(request);\n            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n            if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                options.onResponse(rawResponse, flatResponse);\n            }\n            return flatResponse;\n        }\n        catch (error) {\n            if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n                const rawResponse = error.response;\n                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n                error.details = flatResponse;\n                if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                    options.onResponse(rawResponse, flatResponse, error);\n                }\n            }\n            throw error;\n        }\n    }\n}\nfunction createDefaultPipeline(options) {\n    const credentialScopes = getCredentialScopes(options);\n    const credentialOptions = options.credential && credentialScopes\n        ? { credentialScopes, credential: options.credential }\n        : undefined;\n    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));\n}\nfunction getCredentialScopes(options) {\n    if (options.credentialScopes) {\n        return options.credentialScopes;\n    }\n    if (options.endpoint) {\n        return `${options.endpoint}/.default`;\n    }\n    if (options.baseUri) {\n        return `${options.baseUri}/.default`;\n    }\n    if (options.credential && !options.credentialScopes) {\n        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n    }\n    return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}