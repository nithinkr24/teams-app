{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { parseToken } from \"./tokenParser.js\";\nconst expiredToken = {\n  token: \"\",\n  expiresOnTimestamp: -10\n};\nconst minutesToMs = minutes => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\nexport class AutoRefreshTokenCredential {\n  constructor(refreshArgs) {\n    this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;\n    this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.disposed = false;\n    const {\n      tokenRefresher,\n      token,\n      refreshProactively\n    } = refreshArgs;\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n  getToken(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.isTokenExpiringSoon(_this.currentToken)) {\n        return _this.currentToken;\n      }\n      if (!_this.isTokenValid(_this.currentToken)) {\n        const updatePromise = _this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);\n        yield updatePromise;\n      }\n      return _this.currentToken;\n    })();\n  }\n  dispose() {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n  updateTokenAndReschedule(abortSignal) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.activeTokenUpdating) {\n        return _this2.activeTokenUpdating;\n      }\n      _this2.activeTokenUpdating = _this2.refreshTokenAndReschedule(abortSignal);\n      try {\n        yield _this2.activeTokenUpdating;\n      } finally {\n        _this2.activeTokenUpdating = null;\n      }\n    })();\n  }\n  refreshTokenAndReschedule(abortSignal) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const newToken = yield _this3.refreshToken(abortSignal);\n      if (!_this3.isTokenValid(newToken)) {\n        throw new Error(\"The token returned from the tokenRefresher is expired.\");\n      }\n      _this3.currentToken = newToken;\n      if (_this3.refreshProactively) {\n        _this3.scheduleRefresh();\n      }\n    })();\n  }\n  refreshToken(abortSignal) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this4.activeTokenFetching) {\n          _this4.activeTokenFetching = _this4.refresh(abortSignal);\n        }\n        return parseToken(yield _this4.activeTokenFetching);\n      } finally {\n        _this4.activeTokenFetching = null;\n      }\n    })();\n  }\n  scheduleRefresh() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n    let timespanInMs = null;\n    if (this.isTokenExpiringSoon(this.currentToken)) {\n      // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n    } else {\n      // Schedule the next refresh for when it gets in to the soon-to-expire window.\n      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n    }\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n  isTokenValid(token) {\n    return token && Date.now() < token.expiresOnTimestamp;\n  }\n  isTokenExpiringSoon(token) {\n    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n  }\n}\n//# sourceMappingURL=autoRefreshTokenCredential.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}