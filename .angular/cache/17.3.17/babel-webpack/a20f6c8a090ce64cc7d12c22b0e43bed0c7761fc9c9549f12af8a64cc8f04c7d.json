{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nfunction sendAuthorizeRequest(_x) {\n  return _sendAuthorizeRequest.apply(this, arguments);\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nfunction _sendAuthorizeRequest() {\n  _sendAuthorizeRequest = _asyncToGenerator(function* (options) {\n    var _a, _b;\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    return (_b = (_a = yield getAccessToken(scopes, getTokenOptions)) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n  });\n  return _sendAuthorizeRequest.apply(this, arguments);\n}\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n  const {\n    credentials,\n    scopes\n  } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap();\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n        if (!credentials || credentials.length === 0) {\n          logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n          return next(request);\n        }\n        const tokenPromises = [];\n        for (const credential of credentials) {\n          let getAccessToken = tokenCyclerMap.get(credential);\n          if (!getAccessToken) {\n            getAccessToken = createTokenCycler(credential);\n            tokenCyclerMap.set(credential, getAccessToken);\n          }\n          tokenPromises.push(sendAuthorizeRequest({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            getAccessToken,\n            logger\n          }));\n        }\n        const auxiliaryTokens = (yield Promise.all(tokenPromises)).filter(token => Boolean(token));\n        if (auxiliaryTokens.length === 0) {\n          logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n          return next(request);\n        }\n        request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map(token => `Bearer ${token}`).join(\", \"));\n        return next(request);\n      })();\n    }\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","auxiliaryAuthenticationHeaderPolicyName","AUTHORIZATION_AUXILIARY_HEADER","sendAuthorizeRequest","_x","_sendAuthorizeRequest","apply","arguments","_asyncToGenerator","options","_a","_b","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","token","auxiliaryAuthenticationHeaderPolicy","credentials","tokenCyclerMap","WeakMap","name","sendRequest","next","url","toLowerCase","startsWith","Error","length","info","tokenPromises","credential","get","set","push","Array","isArray","auxiliaryTokens","Promise","all","filter","Boolean","warning","headers","map","join"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nasync function sendAuthorizeRequest(options) {\n    var _a, _b;\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    return (_b = (_a = (await getAccessToken(scopes, getTokenOptions))) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n    const { credentials, scopes } = options;\n    const logger = options.logger || coreLogger;\n    const tokenCyclerMap = new WeakMap();\n    return {\n        name: auxiliaryAuthenticationHeaderPolicyName,\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            if (!credentials || credentials.length === 0) {\n                logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n                return next(request);\n            }\n            const tokenPromises = [];\n            for (const credential of credentials) {\n                let getAccessToken = tokenCyclerMap.get(credential);\n                if (!getAccessToken) {\n                    getAccessToken = createTokenCycler(credential);\n                    tokenCyclerMap.set(credential, getAccessToken);\n                }\n                tokenPromises.push(sendAuthorizeRequest({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    getAccessToken,\n                    logger,\n                }));\n            }\n            const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n            if (auxiliaryTokens.length === 0) {\n                logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n                return next(request);\n            }\n            request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"));\n            return next(request);\n        },\n    };\n}\n"],"mappings":";AAAA;AACA;AACA,SAASA,iBAAiB,QAAQ,wBAAwB;AAC1D,SAASC,MAAM,IAAIC,UAAU,QAAQ,WAAW;AAChD;AACA;AACA;AACA,OAAO,MAAMC,uCAAuC,GAAG,qCAAqC;AAC5F,MAAMC,8BAA8B,GAAG,8BAA8B;AAAC,SACvDC,oBAAoBA,CAAAC,EAAA;EAAA,OAAAC,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AASnC;AACA;AACA;AACA;AACA;AACA;AALA,SAAAF,sBAAA;EAAAA,qBAAA,GAAAG,iBAAA,CATA,WAAoCC,OAAO,EAAE;IACzC,IAAIC,EAAE,EAAEC,EAAE;IACV,MAAM;MAAEC,MAAM;MAAEC,cAAc;MAAEC;IAAQ,CAAC,GAAGL,OAAO;IACnD,MAAMM,eAAe,GAAG;MACpBC,WAAW,EAAEF,OAAO,CAACE,WAAW;MAChCC,cAAc,EAAEH,OAAO,CAACG;IAC5B,CAAC;IACD,OAAO,CAACN,EAAE,GAAG,CAACD,EAAE,SAAUG,cAAc,CAACD,MAAM,EAAEG,eAAe,CAAE,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACQ,KAAK,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;EAC1J,CAAC;EAAA,OAAAN,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAOD,OAAO,SAASY,mCAAmCA,CAACV,OAAO,EAAE;EACzD,MAAM;IAAEW,WAAW;IAAER;EAAO,CAAC,GAAGH,OAAO;EACvC,MAAMV,MAAM,GAAGU,OAAO,CAACV,MAAM,IAAIC,UAAU;EAC3C,MAAMqB,cAAc,GAAG,IAAIC,OAAO,CAAC,CAAC;EACpC,OAAO;IACHC,IAAI,EAAEtB,uCAAuC;IACvCuB,WAAWA,CAACV,OAAO,EAAEW,IAAI,EAAE;MAAA,OAAAjB,iBAAA;QAC7B,IAAI,CAACM,OAAO,CAACY,GAAG,CAACC,WAAW,CAAC,CAAC,CAACC,UAAU,CAAC,UAAU,CAAC,EAAE;UACnD,MAAM,IAAIC,KAAK,CAAC,2GAA2G,CAAC;QAChI;QACA,IAAI,CAACT,WAAW,IAAIA,WAAW,CAACU,MAAM,KAAK,CAAC,EAAE;UAC1C/B,MAAM,CAACgC,IAAI,CAAC,GAAG9B,uCAAuC,mDAAmD,CAAC;UAC1G,OAAOwB,IAAI,CAACX,OAAO,CAAC;QACxB;QACA,MAAMkB,aAAa,GAAG,EAAE;QACxB,KAAK,MAAMC,UAAU,IAAIb,WAAW,EAAE;UAClC,IAAIP,cAAc,GAAGQ,cAAc,CAACa,GAAG,CAACD,UAAU,CAAC;UACnD,IAAI,CAACpB,cAAc,EAAE;YACjBA,cAAc,GAAGf,iBAAiB,CAACmC,UAAU,CAAC;YAC9CZ,cAAc,CAACc,GAAG,CAACF,UAAU,EAAEpB,cAAc,CAAC;UAClD;UACAmB,aAAa,CAACI,IAAI,CAACjC,oBAAoB,CAAC;YACpCS,MAAM,EAAEyB,KAAK,CAACC,OAAO,CAAC1B,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;YACjDE,OAAO;YACPD,cAAc;YACdd;UACJ,CAAC,CAAC,CAAC;QACP;QACA,MAAMwC,eAAe,GAAG,OAAOC,OAAO,CAACC,GAAG,CAACT,aAAa,CAAC,EAAEU,MAAM,CAAExB,KAAK,IAAKyB,OAAO,CAACzB,KAAK,CAAC,CAAC;QAC5F,IAAIqB,eAAe,CAACT,MAAM,KAAK,CAAC,EAAE;UAC9B/B,MAAM,CAAC6C,OAAO,CAAC,2CAA2C1C,8BAA8B,0BAA0B,CAAC;UACnH,OAAOuB,IAAI,CAACX,OAAO,CAAC;QACxB;QACAA,OAAO,CAAC+B,OAAO,CAACV,GAAG,CAACjC,8BAA8B,EAAEqC,eAAe,CAACO,GAAG,CAAE5B,KAAK,IAAK,UAAUA,KAAK,EAAE,CAAC,CAAC6B,IAAI,CAAC,IAAI,CAAC,CAAC;QACjH,OAAOtB,IAAI,CAACX,OAAO,CAAC;MAAC;IACzB;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}