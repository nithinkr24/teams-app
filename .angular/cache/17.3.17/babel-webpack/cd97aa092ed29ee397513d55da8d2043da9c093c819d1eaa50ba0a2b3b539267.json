{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n  const {\n    namespace,\n    packageName,\n    packageVersion\n  } = options;\n  function startSpan(name, operationOptions, spanOptions) {\n    var _a;\n    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), {\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext\n    }));\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions = Object.assign({}, operationOptions, {\n      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {\n        tracingContext\n      })\n    });\n    return {\n      span,\n      updatedOptions\n    };\n  }\n  function withSpan(_x, _x2, _x3, _x4) {\n    return _withSpan.apply(this, arguments);\n  }\n  function _withSpan() {\n    _withSpan = _asyncToGenerator(function* (name, operationOptions, callback, spanOptions) {\n      const {\n        span,\n        updatedOptions\n      } = startSpan(name, operationOptions, spanOptions);\n      try {\n        const result = yield withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n        span.setStatus({\n          status: \"success\"\n        });\n        return result;\n      } catch (err) {\n        span.setStatus({\n          status: \"error\",\n          error: err\n        });\n        throw err;\n      } finally {\n        span.end();\n      }\n    });\n    return _withSpan.apply(this, arguments);\n  }\n  function withContext(context, callback, ...callbackArgs) {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader) {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext) {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders\n  };\n}\n//# sourceMappingURL=tracingClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}