{"ast":null,"code":"import _objectSpread from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport { ChatClient } from '@azure/communication-chat';\nimport { AzureCommunicationTokenCredential } from '@azure/communication-common';\nimport { getNextActiveThreadId } from '../utils/threadsUtils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./agent-work-item.service\";\nexport var ThreadItemStatus = /*#__PURE__*/function (ThreadItemStatus) {\n  ThreadItemStatus[\"ACTIVE\"] = \"active\";\n  ThreadItemStatus[\"RESOLVED\"] = \"resolved\";\n  return ThreadItemStatus;\n}(ThreadItemStatus || {});\nexport let ThreadsService = /*#__PURE__*/(() => {\n  var _ThreadsService;\n  class ThreadsService {\n    constructor(agentWorkItemService) {\n      this.agentWorkItemService = agentWorkItemService;\n      this.threadsSubject = new BehaviorSubject([]);\n      this.selectedThreadIdSubject = new BehaviorSubject(undefined);\n      this.resolvedThreadIdSubject = new BehaviorSubject(undefined);\n      this.isLoadingSubject = new BehaviorSubject(true);\n      this.threads$ = this.threadsSubject.asObservable();\n      this.selectedThreadId$ = this.selectedThreadIdSubject.asObservable();\n      this.resolvedThreadId$ = this.resolvedThreadIdSubject.asObservable();\n      this.isLoading$ = this.isLoadingSubject.asObservable();\n    }\n    initializeChatClient(userId, token, endpointUrl) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const tokenCredential = new AzureCommunicationTokenCredential(token);\n          _this.chatClient = new ChatClient(endpointUrl, tokenCredential);\n          yield _this.chatClient.startRealtimeNotifications();\n          // Add real-time listeners\n          _this.addChatClientListeners(userId);\n          // Fetch initial threads\n          yield _this.fetchThreads();\n        } catch (error) {\n          console.error('Failed to initialize chat client:', error);\n        }\n      })();\n    }\n    addChatClientListeners(userId) {\n      var _this2 = this;\n      if (!this.chatClient) return;\n      this.chatClient.on('participantsAdded', /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (event) {\n          const participantsAdded = event.participantsAdded;\n          const isCurrentUserAdded = participantsAdded.some(participant => {\n            const participantId = participant.id;\n            return participantId.communicationUserId === userId;\n          });\n          if (isCurrentUserAdded) {\n            try {\n              const topic = (yield _this2.chatClient.getChatThreadClient(event.threadId).getProperties()).topic;\n              const threadItem = {\n                id: event.threadId,\n                topic: topic,\n                lastMessageReceivedOn: new Date(),\n                status: ThreadItemStatus.ACTIVE\n              };\n              _this2.addNewThread(threadItem);\n            } catch (error) {\n              console.error('Failed to get thread properties:', error);\n            }\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      // Listen for participants removed\n      this.chatClient.on('participantsRemoved', /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (event) {\n          const threadId = event.threadId;\n          _this2.updateThreadStatus(threadId, ThreadItemStatus.RESOLVED);\n          // Auto-select next active thread if current thread is resolved\n          if (_this2.selectedThreadIdSubject.value === threadId) {\n            const nextActiveThreadId = getNextActiveThreadId(_this2.threadsSubject.value, threadId);\n            _this2.setSelectedThreadId(nextActiveThreadId);\n          }\n          _this2.setResolvedThreadId(threadId);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      // Listen for new messages\n      this.chatClient.on('chatMessageReceived', event => {\n        const threadId = event.threadId;\n        this.updateThreadLastMessage(threadId, new Date());\n        // Reactivate resolved thread if customer sends a message\n        if (event.sender.communicationUserId !== userId) {\n          this.reactivateThreadIfResolved(threadId);\n        }\n        // Emit message received event for real-time updates\n        this.emitMessageReceived(threadId, event);\n      });\n    }\n    emitMessageReceived(threadId, event) {\n      // Create a custom event for message updates\n      const messageUpdateEvent = new CustomEvent('messageReceived', {\n        detail: {\n          threadId,\n          event\n        }\n      });\n      window.dispatchEvent(messageUpdateEvent);\n    }\n    fetchThreads() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this3.chatClient) return;\n        try {\n          _this3.isLoadingSubject.next(true);\n          const threadsResponse = yield _this3.chatClient.listChatThreads().byPage().next();\n          const threads = threadsResponse.value;\n          const threadItems = threads.map(thread => ({\n            id: thread.id,\n            topic: thread.topic,\n            lastMessageReceivedOn: thread.lastMessageReceivedOn\n          }));\n          // Get agent work items to determine thread status\n          const agentWorkItems = yield _this3.agentWorkItemService.getAgentWorkItems();\n          for (const thread of threadItems) {\n            const agentWorkItem = agentWorkItems.find(item => item.id === thread.id);\n            if (!agentWorkItem) {\n              try {\n                yield _this3.agentWorkItemService.createAgentWorkItem(thread.id, ThreadItemStatus.ACTIVE);\n                thread.status = ThreadItemStatus.ACTIVE;\n              } catch (error) {\n                console.error(`Failed to create thread status work item for thread ${thread.id}:`, error);\n                thread.status = ThreadItemStatus.ACTIVE; // Default to active\n              }\n            } else {\n              thread.status = agentWorkItem.status;\n            }\n          }\n          // Sort threads by last message received time\n          threadItems.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n          _this3.threadsSubject.next(threadItems);\n          // Auto-select first active thread if no thread is selected\n          _this3.autoSelectFirstActiveThread(threadItems);\n        } catch (error) {\n          console.error('Failed to fetch threads:', error);\n        } finally {\n          _this3.isLoadingSubject.next(false);\n        }\n      })();\n    }\n    autoSelectFirstActiveThread(threads) {\n      if (!this.selectedThreadIdSubject.value && threads.length > 0) {\n        const firstActiveThread = threads.find(thread => thread.status === ThreadItemStatus.ACTIVE);\n        if (firstActiveThread) {\n          this.setSelectedThreadId(firstActiveThread.id);\n        } else {\n          this.setSelectedThreadId(threads[0].id);\n        }\n      }\n    }\n    addNewThread(threadItem) {\n      const currentThreads = this.threadsSubject.value;\n      const existingThreadIndex = currentThreads.findIndex(thread => thread.id === threadItem.id);\n      if (existingThreadIndex === -1) {\n        // Add new thread to the beginning of the list\n        const newThreads = [threadItem, ...currentThreads];\n        this.threadsSubject.next(newThreads);\n        // Auto-select the new thread if it's the first one\n        if (newThreads.length === 1) {\n          this.setSelectedThreadId(threadItem.id);\n        }\n      }\n    }\n    updateThreadStatus(threadId, status) {\n      const currentThreads = this.threadsSubject.value;\n      const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n      if (threadIndex !== -1) {\n        const updatedThreads = [...currentThreads];\n        updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n          status\n        });\n        // Move resolved threads to the end and sort by last message time\n        if (status === ThreadItemStatus.RESOLVED) {\n          const [resolvedThread] = updatedThreads.splice(threadIndex, 1);\n          updatedThreads.push(resolvedThread);\n        } else if (status === ThreadItemStatus.ACTIVE) {\n          // Move active threads to the top based on last message time\n          const [activeThread] = updatedThreads.splice(threadIndex, 1);\n          updatedThreads.unshift(activeThread);\n        }\n        // Sort threads by last message received time (most recent first)\n        updatedThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n        this.threadsSubject.next(updatedThreads);\n        // If the resolved thread was the selected one, auto-select next active thread\n        if (status === ThreadItemStatus.RESOLVED && this.selectedThreadIdSubject.value === threadId) {\n          const nextActiveThreadId = getNextActiveThreadId(updatedThreads, threadId);\n          if (nextActiveThreadId) {\n            this.setSelectedThreadId(nextActiveThreadId);\n          }\n        }\n      }\n    }\n    updateThreadLastMessage(threadId, lastMessageReceivedOn) {\n      const currentThreads = this.threadsSubject.value;\n      const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n      if (threadIndex !== -1) {\n        const updatedThreads = [...currentThreads];\n        updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n          lastMessageReceivedOn\n        });\n        // Move thread to the top since it has the most recent message\n        const [updatedThread] = updatedThreads.splice(threadIndex, 1);\n        updatedThreads.unshift(updatedThread);\n        // Sort remaining threads by last message time\n        const remainingThreads = updatedThreads.slice(1);\n        remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n        // Combine updated thread with sorted remaining threads\n        const finalThreads = [updatedThread, ...remainingThreads];\n        this.threadsSubject.next(finalThreads);\n      }\n    }\n    reactivateThreadIfResolved(threadId) {\n      const currentThreads = this.threadsSubject.value;\n      const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n      if (threadIndex !== -1 && currentThreads[threadIndex].status === ThreadItemStatus.RESOLVED) {\n        // Update status to active\n        const updatedThreads = [...currentThreads];\n        updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n          status: ThreadItemStatus.ACTIVE\n        });\n        // Move to top and sort\n        const [reactivatedThread] = updatedThreads.splice(threadIndex, 1);\n        updatedThreads.unshift(reactivatedThread);\n        // Sort remaining threads\n        const remainingThreads = updatedThreads.slice(1);\n        remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n        const finalThreads = [reactivatedThread, ...remainingThreads];\n        this.threadsSubject.next(finalThreads);\n        // Clear resolved thread ID if it was this thread\n        if (this.resolvedThreadIdSubject.value === threadId) {\n          this.setResolvedThreadId(undefined);\n        }\n      }\n    }\n    setSelectedThreadId(threadId) {\n      if (threadId) {\n        // Validate that the thread exists\n        const threadExists = this.threadsSubject.value.some(thread => thread.id === threadId);\n        if (!threadExists) {\n          console.warn(`Thread ${threadId} not found in threads list`);\n          return;\n        }\n      }\n      this.selectedThreadIdSubject.next(threadId);\n    }\n    setResolvedThreadId(threadId) {\n      this.resolvedThreadIdSubject.next(threadId);\n    }\n    getNextActiveThreadIdFromService(currentThreadId) {\n      return getNextActiveThreadId(this.threadsSubject.value, currentThreadId);\n    }\n    // Method to manually refresh threads\n    refreshThreads() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        if (_this4.chatClient) {\n          yield _this4.fetchThreads();\n        } else {}\n      })();\n    }\n    // Method to update thread status (used when resolving chat)\n    updateThreadStatusExternal(threadId, status) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Update backend first\n          if (status === ThreadItemStatus.RESOLVED) {\n            yield _this5.agentWorkItemService.updateAgentWorkItem(threadId, status);\n          } else {\n            yield _this5.agentWorkItemService.createAgentWorkItem(threadId, status);\n          }\n          // Then update local state\n          _this5.updateThreadStatus(threadId, status);\n        } catch (error) {\n          console.error(`Failed to update thread ${threadId} status:`, error);\n          throw error;\n        }\n      })();\n    }\n  }\n  _ThreadsService = ThreadsService;\n  _ThreadsService.ɵfac = function ThreadsService_Factory(t) {\n    return new (t || _ThreadsService)(i0.ɵɵinject(i1.AgentWorkItemService));\n  };\n  _ThreadsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _ThreadsService,\n    factory: _ThreadsService.ɵfac,\n    providedIn: 'root'\n  });\n  return ThreadsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}