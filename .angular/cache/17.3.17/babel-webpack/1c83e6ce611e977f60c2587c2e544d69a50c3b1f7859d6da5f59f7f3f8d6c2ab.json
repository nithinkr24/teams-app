{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isQueryParameterWithOptions(x) {\n  const value = x.value;\n  return value !== undefined && value.toString !== undefined && typeof value.toString === \"function\";\n}\n/**\n * Builds the request url, filling in query and path parameters\n * @param endpoint - base url which can be a template url\n * @param routePath - path to append to the endpoint\n * @param pathParameters - values of the path parameters\n * @param options - request parameters including query parameters\n * @returns a full url with path and query parameters\n */\nexport function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {\n  if (routePath.startsWith(\"https://\") || routePath.startsWith(\"http://\")) {\n    return routePath;\n  }\n  endpoint = buildBaseUrl(endpoint, options);\n  routePath = buildRoutePath(routePath, pathParameters, options);\n  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);\n  const url = new URL(requestUrl);\n  return url.toString()\n  // Remove double forward slashes\n  .replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nfunction getQueryParamValue(key, allowReserved, style, param) {\n  let separator;\n  if (style === \"pipeDelimited\") {\n    separator = \"|\";\n  } else if (style === \"spaceDelimited\") {\n    separator = \"%20\";\n  } else {\n    separator = \",\";\n  }\n  let paramValues;\n  if (Array.isArray(param)) {\n    paramValues = param;\n  } else if (typeof param === \"object\" && param.toString === Object.prototype.toString) {\n    // If the parameter is an object without a custom toString implementation (e.g. a Date),\n    // then we should deconstruct the object into an array [key1, value1, key2, value2, ...].\n    paramValues = Object.entries(param).flat();\n  } else {\n    paramValues = [param];\n  }\n  const value = paramValues.map(p => {\n    if (p === null || p === undefined) {\n      return \"\";\n    }\n    if (!p.toString || typeof p.toString !== \"function\") {\n      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);\n    }\n    const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();\n    return allowReserved ? rawValue : encodeURIComponent(rawValue);\n  }).join(separator);\n  return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;\n}\nfunction appendQueryParams(url, options = {}) {\n  var _a, _b, _c, _d;\n  if (!options.queryParameters) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  const queryParams = options.queryParameters;\n  const paramStrings = [];\n  for (const key of Object.keys(queryParams)) {\n    const param = queryParams[key];\n    if (param === undefined || param === null) {\n      continue;\n    }\n    const hasMetadata = isQueryParameterWithOptions(param);\n    const rawValue = hasMetadata ? param.value : param;\n    const explode = hasMetadata ? (_a = param.explode) !== null && _a !== void 0 ? _a : false : false;\n    const style = hasMetadata && param.style ? param.style : \"form\";\n    if (explode) {\n      if (Array.isArray(rawValue)) {\n        for (const item of rawValue) {\n          paramStrings.push(getQueryParamValue(key, (_b = options.skipUrlEncoding) !== null && _b !== void 0 ? _b : false, style, item));\n        }\n      } else if (typeof rawValue === \"object\") {\n        // For object explode, the name of the query parameter is ignored and we use the object key instead\n        for (const [actualKey, value] of Object.entries(rawValue)) {\n          paramStrings.push(getQueryParamValue(actualKey, (_c = options.skipUrlEncoding) !== null && _c !== void 0 ? _c : false, style, value));\n        }\n      } else {\n        // Explode doesn't really make sense for primitives\n        throw new Error(\"explode can only be set to true for objects and arrays\");\n      }\n    } else {\n      paramStrings.push(getQueryParamValue(key, (_d = options.skipUrlEncoding) !== null && _d !== void 0 ? _d : false, style, rawValue));\n    }\n  }\n  if (parsedUrl.search !== \"\") {\n    parsedUrl.search += \"&\";\n  }\n  parsedUrl.search += paramStrings.join(\"&\");\n  return parsedUrl.toString();\n}\nexport function buildBaseUrl(endpoint, options) {\n  var _a;\n  if (!options.pathParameters) {\n    return endpoint;\n  }\n  const pathParams = options.pathParameters;\n  for (const [key, param] of Object.entries(pathParams)) {\n    if (param === undefined || param === null) {\n      throw new Error(`Path parameters ${key} must not be undefined or null`);\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);\n    }\n    let value = param.toISOString !== undefined ? param.toISOString() : String(param);\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(param);\n    }\n    endpoint = (_a = replaceAll(endpoint, `{${key}}`, value)) !== null && _a !== void 0 ? _a : \"\";\n  }\n  return endpoint;\n}\nfunction buildRoutePath(routePath, pathParameters, options = {}) {\n  var _a;\n  for (const pathParam of pathParameters) {\n    const allowReserved = typeof pathParam === \"object\" && ((_a = pathParam.allowReserved) !== null && _a !== void 0 ? _a : false);\n    let value = typeof pathParam === \"object\" ? pathParam.value : pathParam;\n    if (!options.skipUrlEncoding && !allowReserved) {\n      value = encodeURIComponent(value);\n    }\n    routePath = routePath.replace(/\\{[\\w-]+\\}/, String(value));\n  }\n  return routePath;\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n//# sourceMappingURL=urlHelpers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}