{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nfunction trySendRequest(_x, _x2) {\n  return _trySendRequest.apply(this, arguments);\n}\n/**\n * Default authorize request handler\n */\nfunction _trySendRequest() {\n  _trySendRequest = _asyncToGenerator(function* (request, next) {\n    try {\n      return [yield next(request), undefined];\n    } catch (e) {\n      if (isRestError(e) && e.response) {\n        return [e.response, e];\n      } else {\n        throw e;\n      }\n    }\n  });\n  return _trySendRequest.apply(this, arguments);\n}\nfunction defaultAuthorizeRequest(_x3) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    // Enable CAE true by default\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions,\n      enableCae: true\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\nfunction isChallengeResponse(response) {\n  return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nfunction authorizeRequestOnCaeChallenge(_x4, _x5) {\n  return _authorizeRequestOnCaeChallenge.apply(this, arguments);\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nfunction _authorizeRequestOnCaeChallenge() {\n  _authorizeRequestOnCaeChallenge = _asyncToGenerator(function* (onChallengeOptions, caeClaims) {\n    var _a;\n    const {\n      scopes\n    } = onChallengeOptions;\n    const accessToken = yield onChallengeOptions.getAccessToken(scopes, {\n      enableCae: true,\n      claims: caeClaims\n    });\n    if (!accessToken) {\n      return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n  });\n  return _authorizeRequestOnCaeChallenge.apply(this, arguments);\n}\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a, _b, _c;\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks)\n  };\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential ? createTokenCycler(credential /* , options */) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n        let shouldSendRequest;\n        [response, error] = yield trySendRequest(request, next);\n        if (isChallengeResponse(response)) {\n          let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n          // Handle CAE by default when receive CAE claim\n          if (claims) {\n            let parsedClaim;\n            // Return the response immediately if claims is not a valid base64 encoded string\n            try {\n              parsedClaim = atob(claims);\n            } catch (e) {\n              logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n              return response;\n            }\n            shouldSendRequest = yield authorizeRequestOnCaeChallenge({\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              response,\n              request,\n              getAccessToken,\n              logger\n            }, parsedClaim);\n            // Send updated request and handle response for RestError\n            if (shouldSendRequest) {\n              [response, error] = yield trySendRequest(request, next);\n            }\n          } else if (callbacks.authorizeRequestOnChallenge) {\n            // Handle custom challenges when client provides custom callback\n            shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              request,\n              response,\n              getAccessToken,\n              logger\n            });\n            // Send updated request and handle response for RestError\n            if (shouldSendRequest) {\n              [response, error] = yield trySendRequest(request, next);\n            }\n            // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n            if (isChallengeResponse(response)) {\n              claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n              if (claims) {\n                let parsedClaim;\n                try {\n                  parsedClaim = atob(claims);\n                } catch (e) {\n                  logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                  return response;\n                }\n                shouldSendRequest = yield authorizeRequestOnCaeChallenge({\n                  scopes: Array.isArray(scopes) ? scopes : [scopes],\n                  response,\n                  request,\n                  getAccessToken,\n                  logger\n                }, parsedClaim);\n                // Send updated request and handle response for RestError\n                if (shouldSendRequest) {\n                  [response, error] = yield trySendRequest(request, next);\n                }\n              }\n            }\n          }\n        }\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n  };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n  // The challenge regex captures parameteres with either quotes values or unquoted values\n  const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n  // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n  const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n  const parsedChallenges = [];\n  let match;\n  // Iterate over each challenge match\n  while ((match = challengeRegex.exec(challenges)) !== null) {\n    const scheme = match[1];\n    const paramsString = match[2];\n    const params = {};\n    let paramMatch;\n    // Iterate over each parameter match\n    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n      params[paramMatch[1]] = paramMatch[2];\n    }\n    parsedChallenges.push({\n      scheme,\n      params\n    });\n  }\n  return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n  var _a;\n  if (!challenges) {\n    return;\n  }\n  // Find all challenges present in the header\n  const parsedChallenges = parseChallenges(challenges);\n  return (_a = parsedChallenges.find(x => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}\n//# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}