{"ast":null,"code":"import _objectSpread from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _ThreadsService;\nimport { BehaviorSubject } from 'rxjs';\nimport { ChatClient } from '@azure/communication-chat';\nimport { AzureCommunicationTokenCredential } from '@azure/communication-common';\nimport { getNextActiveThreadId } from '../utils/threadsUtils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./agent-work-item.service\";\nexport var ThreadItemStatus;\n(function (ThreadItemStatus) {\n  ThreadItemStatus[\"ACTIVE\"] = \"active\";\n  ThreadItemStatus[\"RESOLVED\"] = \"resolved\";\n})(ThreadItemStatus || (ThreadItemStatus = {}));\nexport class ThreadsService {\n  constructor(agentWorkItemService) {\n    this.agentWorkItemService = agentWorkItemService;\n    this.threadsSubject = new BehaviorSubject([]);\n    this.selectedThreadIdSubject = new BehaviorSubject(undefined);\n    this.resolvedThreadIdSubject = new BehaviorSubject(undefined);\n    this.isLoadingSubject = new BehaviorSubject(true);\n    this.threads$ = this.threadsSubject.asObservable();\n    this.selectedThreadId$ = this.selectedThreadIdSubject.asObservable();\n    this.resolvedThreadId$ = this.resolvedThreadIdSubject.asObservable();\n    this.isLoading$ = this.isLoadingSubject.asObservable();\n  }\n  initializeChatClient(userId, token, endpointUrl) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const tokenCredential = new AzureCommunicationTokenCredential(token);\n        _this.chatClient = new ChatClient(endpointUrl, tokenCredential);\n        yield _this.chatClient.startRealtimeNotifications();\n        // Add real-time listeners\n        _this.addChatClientListeners(userId);\n        // Fetch initial threads\n        yield _this.fetchThreads();\n      } catch (error) {\n        console.error('Failed to initialize chat client:', error);\n      }\n    })();\n  }\n  addChatClientListeners(userId) {\n    var _this2 = this;\n    if (!this.chatClient) return;\n    this.chatClient.on('participantsAdded', /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (event) {\n        const participantsAdded = event.participantsAdded;\n        const isCurrentUserAdded = participantsAdded.some(participant => {\n          const participantId = participant.id;\n          return participantId.communicationUserId === userId;\n        });\n        if (isCurrentUserAdded) {\n          try {\n            const topic = (yield _this2.chatClient.getChatThreadClient(event.threadId).getProperties()).topic;\n            const threadItem = {\n              id: event.threadId,\n              topic: topic,\n              lastMessageReceivedOn: new Date(),\n              status: ThreadItemStatus.ACTIVE\n            };\n            _this2.addNewThread(threadItem);\n          } catch (error) {\n            console.error('Failed to get thread properties:', error);\n          }\n        }\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    // Listen for participants removed\n    this.chatClient.on('participantsRemoved', /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (event) {\n        const threadId = event.threadId;\n        _this2.updateThreadStatus(threadId, ThreadItemStatus.RESOLVED);\n        // Auto-select next active thread if current thread is resolved\n        if (_this2.selectedThreadIdSubject.value === threadId) {\n          const nextActiveThreadId = getNextActiveThreadId(_this2.threadsSubject.value, threadId);\n          _this2.setSelectedThreadId(nextActiveThreadId);\n        }\n        _this2.setResolvedThreadId(threadId);\n      });\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    // Listen for new messages\n    this.chatClient.on('chatMessageReceived', event => {\n      const threadId = event.threadId;\n      this.updateThreadLastMessage(threadId, new Date());\n      // Reactivate resolved thread if customer sends a message\n      if (event.sender.communicationUserId !== userId) {\n        this.reactivateThreadIfResolved(threadId);\n      }\n      // Emit message received event for real-time updates\n      this.emitMessageReceived(threadId, event);\n    });\n  }\n  emitMessageReceived(threadId, event) {\n    // Create a custom event for message updates\n    const messageUpdateEvent = new CustomEvent('messageReceived', {\n      detail: {\n        threadId,\n        event\n      }\n    });\n    window.dispatchEvent(messageUpdateEvent);\n  }\n  fetchThreads() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.chatClient) return;\n      try {\n        _this3.isLoadingSubject.next(true);\n        const threadsResponse = yield _this3.chatClient.listChatThreads().byPage().next();\n        const threads = threadsResponse.value;\n        const threadItems = threads.map(thread => ({\n          id: thread.id,\n          topic: thread.topic,\n          lastMessageReceivedOn: thread.lastMessageReceivedOn\n        }));\n        // Get agent work items to determine thread status\n        const agentWorkItems = yield _this3.agentWorkItemService.getAgentWorkItems();\n        for (const thread of threadItems) {\n          const agentWorkItem = agentWorkItems.find(item => item.id === thread.id);\n          if (!agentWorkItem) {\n            try {\n              yield _this3.agentWorkItemService.createAgentWorkItem(thread.id, ThreadItemStatus.ACTIVE);\n              thread.status = ThreadItemStatus.ACTIVE;\n            } catch (error) {\n              console.error(`Failed to create thread status work item for thread ${thread.id}:`, error);\n              thread.status = ThreadItemStatus.ACTIVE; // Default to active\n            }\n          } else {\n            thread.status = agentWorkItem.status;\n          }\n        }\n        // Sort threads by last message received time\n        threadItems.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n        _this3.threadsSubject.next(threadItems);\n        // Auto-select first active thread if no thread is selected\n        _this3.autoSelectFirstActiveThread(threadItems);\n      } catch (error) {\n        console.error('Failed to fetch threads:', error);\n      } finally {\n        _this3.isLoadingSubject.next(false);\n      }\n    })();\n  }\n  autoSelectFirstActiveThread(threads) {\n    if (!this.selectedThreadIdSubject.value && threads.length > 0) {\n      const firstActiveThread = threads.find(thread => thread.status === ThreadItemStatus.ACTIVE);\n      if (firstActiveThread) {\n        this.setSelectedThreadId(firstActiveThread.id);\n      } else {\n        this.setSelectedThreadId(threads[0].id);\n      }\n    }\n  }\n  addNewThread(threadItem) {\n    const currentThreads = this.threadsSubject.value;\n    const existingThreadIndex = currentThreads.findIndex(thread => thread.id === threadItem.id);\n    if (existingThreadIndex === -1) {\n      // Add new thread to the beginning of the list\n      const newThreads = [threadItem, ...currentThreads];\n      this.threadsSubject.next(newThreads);\n      // Auto-select the new thread if it's the first one\n      if (newThreads.length === 1) {\n        this.setSelectedThreadId(threadItem.id);\n      }\n    }\n  }\n  updateThreadStatus(threadId, status) {\n    const currentThreads = this.threadsSubject.value;\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n    if (threadIndex !== -1) {\n      const updatedThreads = [...currentThreads];\n      updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n        status\n      });\n      // Move resolved threads to the end and sort by last message time\n      if (status === ThreadItemStatus.RESOLVED) {\n        const [resolvedThread] = updatedThreads.splice(threadIndex, 1);\n        updatedThreads.push(resolvedThread);\n      } else if (status === ThreadItemStatus.ACTIVE) {\n        // Move active threads to the top based on last message time\n        const [activeThread] = updatedThreads.splice(threadIndex, 1);\n        updatedThreads.unshift(activeThread);\n      }\n      // Sort threads by last message received time (most recent first)\n      updatedThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n      this.threadsSubject.next(updatedThreads);\n      // If the resolved thread was the selected one, auto-select next active thread\n      if (status === ThreadItemStatus.RESOLVED && this.selectedThreadIdSubject.value === threadId) {\n        const nextActiveThreadId = getNextActiveThreadId(updatedThreads, threadId);\n        if (nextActiveThreadId) {\n          this.setSelectedThreadId(nextActiveThreadId);\n        }\n      }\n    }\n  }\n  updateThreadLastMessage(threadId, lastMessageReceivedOn) {\n    const currentThreads = this.threadsSubject.value;\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n    if (threadIndex !== -1) {\n      const updatedThreads = [...currentThreads];\n      updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n        lastMessageReceivedOn\n      });\n      // Move thread to the top since it has the most recent message\n      const [updatedThread] = updatedThreads.splice(threadIndex, 1);\n      updatedThreads.unshift(updatedThread);\n      // Sort remaining threads by last message time\n      const remainingThreads = updatedThreads.slice(1);\n      remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n      // Combine updated thread with sorted remaining threads\n      const finalThreads = [updatedThread, ...remainingThreads];\n      this.threadsSubject.next(finalThreads);\n    }\n  }\n  reactivateThreadIfResolved(threadId) {\n    const currentThreads = this.threadsSubject.value;\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\n    if (threadIndex !== -1 && currentThreads[threadIndex].status === ThreadItemStatus.RESOLVED) {\n      // Update status to active\n      const updatedThreads = [...currentThreads];\n      updatedThreads[threadIndex] = _objectSpread(_objectSpread({}, updatedThreads[threadIndex]), {}, {\n        status: ThreadItemStatus.ACTIVE\n      });\n      // Move to top and sort\n      const [reactivatedThread] = updatedThreads.splice(threadIndex, 1);\n      updatedThreads.unshift(reactivatedThread);\n      // Sort remaining threads\n      const remainingThreads = updatedThreads.slice(1);\n      remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\n      const finalThreads = [reactivatedThread, ...remainingThreads];\n      this.threadsSubject.next(finalThreads);\n      // Clear resolved thread ID if it was this thread\n      if (this.resolvedThreadIdSubject.value === threadId) {\n        this.setResolvedThreadId(undefined);\n      }\n    }\n  }\n  setSelectedThreadId(threadId) {\n    if (threadId) {\n      // Validate that the thread exists\n      const threadExists = this.threadsSubject.value.some(thread => thread.id === threadId);\n      if (!threadExists) {\n        console.warn(`Thread ${threadId} not found in threads list`);\n        return;\n      }\n    }\n    this.selectedThreadIdSubject.next(threadId);\n  }\n  setResolvedThreadId(threadId) {\n    this.resolvedThreadIdSubject.next(threadId);\n  }\n  getNextActiveThreadIdFromService(currentThreadId) {\n    return getNextActiveThreadId(this.threadsSubject.value, currentThreadId);\n  }\n  // Method to manually refresh threads\n  refreshThreads() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_this4.chatClient) {\n        yield _this4.fetchThreads();\n      } else {}\n    })();\n  }\n  // Method to update thread status (used when resolving chat)\n  updateThreadStatusExternal(threadId, status) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Update backend first\n        if (status === ThreadItemStatus.RESOLVED) {\n          yield _this5.agentWorkItemService.updateAgentWorkItem(threadId, status);\n        } else {\n          yield _this5.agentWorkItemService.createAgentWorkItem(threadId, status);\n        }\n        // Then update local state\n        _this5.updateThreadStatus(threadId, status);\n      } catch (error) {\n        console.error(`Failed to update thread ${threadId} status:`, error);\n        throw error;\n      }\n    })();\n  }\n}\n_ThreadsService = ThreadsService;\n_ThreadsService.ɵfac = function ThreadsService_Factory(t) {\n  return new (t || _ThreadsService)(i0.ɵɵinject(i1.AgentWorkItemService));\n};\n_ThreadsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _ThreadsService,\n  factory: _ThreadsService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["BehaviorSubject","ChatClient","AzureCommunicationTokenCredential","getNextActiveThreadId","ThreadItemStatus","ThreadsService","constructor","agentWorkItemService","threadsSubject","selectedThreadIdSubject","undefined","resolvedThreadIdSubject","isLoadingSubject","threads$","asObservable","selectedThreadId$","resolvedThreadId$","isLoading$","initializeChatClient","userId","token","endpointUrl","_this","_asyncToGenerator","tokenCredential","chatClient","startRealtimeNotifications","addChatClientListeners","fetchThreads","error","console","_this2","on","_ref","event","participantsAdded","isCurrentUserAdded","some","participant","participantId","id","communicationUserId","topic","getChatThreadClient","threadId","getProperties","threadItem","lastMessageReceivedOn","Date","status","ACTIVE","addNewThread","_x","apply","arguments","_ref2","updateThreadStatus","RESOLVED","value","nextActiveThreadId","setSelectedThreadId","setResolvedThreadId","_x2","updateThreadLastMessage","sender","reactivateThreadIfResolved","emitMessageReceived","messageUpdateEvent","CustomEvent","detail","window","dispatchEvent","_this3","next","threadsResponse","listChatThreads","byPage","threads","threadItems","map","thread","agentWorkItems","getAgentWorkItems","agentWorkItem","find","item","createAgentWorkItem","sort","a","b","getTime","autoSelectFirstActiveThread","length","firstActiveThread","currentThreads","existingThreadIndex","findIndex","newThreads","threadIndex","updatedThreads","_objectSpread","resolvedThread","splice","push","activeThread","unshift","updatedThread","remainingThreads","slice","finalThreads","reactivatedThread","threadExists","warn","getNextActiveThreadIdFromService","currentThreadId","refreshThreads","_this4","updateThreadStatusExternal","_this5","updateAgentWorkItem","i0","ɵɵinject","i1","AgentWorkItemService","factory","ɵfac","providedIn"],"sources":["D:\\Project\\github-teams\\teams-app-new\\src\\app\\services\\threads.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\r\nimport { ChatClient, ChatMessageReceivedEvent, ChatThreadItem } from '@azure/communication-chat';\r\nimport { AzureCommunicationTokenCredential, CommunicationUserKind } from '@azure/communication-common';\r\nimport { AgentWorkItemService, AgentWorkItem } from './agent-work-item.service';\r\nimport { getNextActiveThreadId } from '../utils/threadsUtils';\r\n\r\nexport interface ThreadItem {\r\n  id: string;\r\n  topic: string;\r\n  lastMessageReceivedOn: Date;\r\n  status?: ThreadItemStatus;\r\n}\r\n\r\nexport enum ThreadItemStatus {\r\n  ACTIVE = 'active',\r\n  RESOLVED = 'resolved'\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ThreadsService {\r\n  private threadsSubject = new BehaviorSubject<ThreadItem[]>([]);\r\n  private selectedThreadIdSubject = new BehaviorSubject<string | undefined>(undefined);\r\n  private resolvedThreadIdSubject = new BehaviorSubject<string | undefined>(undefined);\r\n  private isLoadingSubject = new BehaviorSubject<boolean>(true);\r\n  private chatClient: ChatClient | undefined;\r\n\r\n  public threads$ = this.threadsSubject.asObservable();\r\n  public selectedThreadId$ = this.selectedThreadIdSubject.asObservable();\r\n  public resolvedThreadId$ = this.resolvedThreadIdSubject.asObservable();\r\n  public isLoading$ = this.isLoadingSubject.asObservable();\r\n\r\n  constructor(private agentWorkItemService: AgentWorkItemService) {}\r\n\r\n  async initializeChatClient(userId: string, token: string, endpointUrl: string): Promise<void> {\r\n    try {\r\n      const tokenCredential = new AzureCommunicationTokenCredential(token);\r\n      this.chatClient = new ChatClient(endpointUrl, tokenCredential);\r\n      await this.chatClient.startRealtimeNotifications();\r\n      \r\n      // Add real-time listeners\r\n      this.addChatClientListeners(userId);\r\n      \r\n      // Fetch initial threads\r\n      await this.fetchThreads();\r\n    } catch (error) {\r\n      console.error('Failed to initialize chat client:', error);\r\n    }\r\n  }\r\n\r\n  private addChatClientListeners(userId: string): void {\r\n    if (!this.chatClient) return;\r\n\r\n    this.chatClient.on('participantsAdded', async (event) => {\r\n      const participantsAdded = event.participantsAdded;\r\n      const isCurrentUserAdded = participantsAdded.some((participant) => {\r\n        const participantId = participant.id as CommunicationUserKind;\r\n        return participantId.communicationUserId === userId;\r\n      });\r\n\r\n      if (isCurrentUserAdded) {\r\n        try {\r\n          const topic = (await this.chatClient!.getChatThreadClient(event.threadId).getProperties()).topic;\r\n          const threadItem: ThreadItem = {\r\n            id: event.threadId,\r\n            topic: topic,\r\n            lastMessageReceivedOn: new Date(),\r\n            status: ThreadItemStatus.ACTIVE\r\n          };\r\n\r\n          this.addNewThread(threadItem);\r\n        } catch (error) {\r\n          console.error('Failed to get thread properties:', error);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Listen for participants removed\r\n    this.chatClient.on('participantsRemoved', async (event) => {\r\n      const threadId = event.threadId;\r\n      this.updateThreadStatus(threadId, ThreadItemStatus.RESOLVED);\r\n      \r\n      // Auto-select next active thread if current thread is resolved\r\n      if (this.selectedThreadIdSubject.value === threadId) {\r\n        const nextActiveThreadId = getNextActiveThreadId(this.threadsSubject.value, threadId);\r\n        this.setSelectedThreadId(nextActiveThreadId);\r\n      }\r\n      \r\n      this.setResolvedThreadId(threadId);\r\n    });\r\n\r\n    // Listen for new messages\r\n    this.chatClient.on('chatMessageReceived', (event: ChatMessageReceivedEvent) => {\r\n      const threadId = event.threadId;\r\n      this.updateThreadLastMessage(threadId, new Date());\r\n      \r\n      // Reactivate resolved thread if customer sends a message\r\n      if ((event.sender as CommunicationUserKind).communicationUserId !== userId) {\r\n        this.reactivateThreadIfResolved(threadId);\r\n      }\r\n      \r\n      // Emit message received event for real-time updates\r\n      this.emitMessageReceived(threadId, event);\r\n    });\r\n  }\r\n  \r\n  private emitMessageReceived(threadId: string, event: ChatMessageReceivedEvent): void {\r\n    // Create a custom event for message updates\r\n    const messageUpdateEvent = new CustomEvent('messageReceived', {\r\n      detail: { threadId, event }\r\n    });\r\n    window.dispatchEvent(messageUpdateEvent);\r\n  }\r\n\r\n  private async fetchThreads(): Promise<void> {\r\n    if (!this.chatClient) return;\r\n\r\n    try {\r\n      this.isLoadingSubject.next(true);\r\n      \r\n      const threadsResponse = await this.chatClient.listChatThreads().byPage().next();\r\n      const threads = threadsResponse.value;\r\n      \r\n      const threadItems: ThreadItem[] = threads.map((thread: ChatThreadItem) => ({\r\n        id: thread.id,\r\n        topic: thread.topic,\r\n        lastMessageReceivedOn: thread.lastMessageReceivedOn\r\n      }));\r\n\r\n      // Get agent work items to determine thread status\r\n      const agentWorkItems = await this.agentWorkItemService.getAgentWorkItems();\r\n\r\n      for (const thread of threadItems) {\r\n        const agentWorkItem = agentWorkItems.find((item: AgentWorkItem) => item.id === thread.id);\r\n        if (!agentWorkItem) {\r\n          try {\r\n            await this.agentWorkItemService.createAgentWorkItem(thread.id, ThreadItemStatus.ACTIVE);\r\n            thread.status = ThreadItemStatus.ACTIVE;\r\n          } catch (error) {\r\n            console.error(`Failed to create thread status work item for thread ${thread.id}:`, error);\r\n            thread.status = ThreadItemStatus.ACTIVE; // Default to active\r\n          }\r\n        } else {\r\n          thread.status = agentWorkItem.status;\r\n        }\r\n      }\r\n\r\n      // Sort threads by last message received time\r\n      threadItems.sort((a, b) => \r\n        b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime()\r\n      );\r\n\r\n      this.threadsSubject.next(threadItems);\r\n      \r\n      // Auto-select first active thread if no thread is selected\r\n      this.autoSelectFirstActiveThread(threadItems);\r\n    } catch (error) {\r\n      console.error('Failed to fetch threads:', error);\r\n    } finally {\r\n      this.isLoadingSubject.next(false);\r\n    }\r\n  }\r\n  \r\n  private autoSelectFirstActiveThread(threads: ThreadItem[]): void {\r\n    if (!this.selectedThreadIdSubject.value && threads.length > 0) {\r\n      const firstActiveThread = threads.find(thread => thread.status === ThreadItemStatus.ACTIVE);\r\n      if (firstActiveThread) {\r\n        this.setSelectedThreadId(firstActiveThread.id);\r\n      } else {\r\n        this.setSelectedThreadId(threads[0].id);\r\n      }\r\n    }\r\n  }\r\n\r\n  private addNewThread(threadItem: ThreadItem): void {\r\n    const currentThreads = this.threadsSubject.value;\r\n    const existingThreadIndex = currentThreads.findIndex(thread => thread.id === threadItem.id);\r\n    \r\n    if (existingThreadIndex === -1) {\r\n      // Add new thread to the beginning of the list\r\n      const newThreads = [threadItem, ...currentThreads];\r\n      this.threadsSubject.next(newThreads);\r\n      \r\n      // Auto-select the new thread if it's the first one\r\n      if (newThreads.length === 1) {\r\n        this.setSelectedThreadId(threadItem.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  private updateThreadStatus(threadId: string, status: ThreadItemStatus): void {\r\n    const currentThreads = this.threadsSubject.value;\r\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\r\n    \r\n    if (threadIndex !== -1) {\r\n      const updatedThreads = [...currentThreads];\r\n      updatedThreads[threadIndex] = { ...updatedThreads[threadIndex], status };\r\n      \r\n      // Move resolved threads to the end and sort by last message time\r\n      if (status === ThreadItemStatus.RESOLVED) {\r\n        const [resolvedThread] = updatedThreads.splice(threadIndex, 1);\r\n        updatedThreads.push(resolvedThread);\r\n      } else if (status === ThreadItemStatus.ACTIVE) {\r\n        // Move active threads to the top based on last message time\r\n        const [activeThread] = updatedThreads.splice(threadIndex, 1);\r\n        updatedThreads.unshift(activeThread);\r\n      }\r\n      \r\n      // Sort threads by last message received time (most recent first)\r\n      updatedThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\r\n      \r\n      this.threadsSubject.next(updatedThreads);\r\n      \r\n      // If the resolved thread was the selected one, auto-select next active thread\r\n      if (status === ThreadItemStatus.RESOLVED && this.selectedThreadIdSubject.value === threadId) {\r\n        const nextActiveThreadId = getNextActiveThreadId(updatedThreads, threadId);\r\n        if (nextActiveThreadId) {\r\n          this.setSelectedThreadId(nextActiveThreadId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private updateThreadLastMessage(threadId: string, lastMessageReceivedOn: Date): void {\r\n    const currentThreads = this.threadsSubject.value;\r\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\r\n    \r\n    if (threadIndex !== -1) {\r\n      const updatedThreads = [...currentThreads];\r\n      updatedThreads[threadIndex] = { ...updatedThreads[threadIndex], lastMessageReceivedOn };\r\n      \r\n      // Move thread to the top since it has the most recent message\r\n      const [updatedThread] = updatedThreads.splice(threadIndex, 1);\r\n      updatedThreads.unshift(updatedThread);\r\n      \r\n      // Sort remaining threads by last message time\r\n      const remainingThreads = updatedThreads.slice(1);\r\n      remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\r\n      \r\n      // Combine updated thread with sorted remaining threads\r\n      const finalThreads = [updatedThread, ...remainingThreads];\r\n      this.threadsSubject.next(finalThreads);\r\n      \r\n    }\r\n  }\r\n\r\n  private reactivateThreadIfResolved(threadId: string): void {\r\n    const currentThreads = this.threadsSubject.value;\r\n    const threadIndex = currentThreads.findIndex(thread => thread.id === threadId);\r\n    \r\n    if (threadIndex !== -1 && currentThreads[threadIndex].status === ThreadItemStatus.RESOLVED) {\r\n      \r\n      // Update status to active\r\n      const updatedThreads = [...currentThreads];\r\n      updatedThreads[threadIndex] = { ...updatedThreads[threadIndex], status: ThreadItemStatus.ACTIVE };\r\n      \r\n      // Move to top and sort\r\n      const [reactivatedThread] = updatedThreads.splice(threadIndex, 1);\r\n      updatedThreads.unshift(reactivatedThread);\r\n      \r\n      // Sort remaining threads\r\n      const remainingThreads = updatedThreads.slice(1);\r\n      remainingThreads.sort((a, b) => b.lastMessageReceivedOn.getTime() - a.lastMessageReceivedOn.getTime());\r\n      \r\n      const finalThreads = [reactivatedThread, ...remainingThreads];\r\n      this.threadsSubject.next(finalThreads);\r\n      \r\n      // Clear resolved thread ID if it was this thread\r\n      if (this.resolvedThreadIdSubject.value === threadId) {\r\n        this.setResolvedThreadId(undefined);\r\n      }\r\n    }\r\n  }\r\n\r\n  setSelectedThreadId(threadId: string | undefined): void {\r\n    if (threadId) {\r\n      // Validate that the thread exists\r\n      const threadExists = this.threadsSubject.value.some(thread => thread.id === threadId);\r\n      if (!threadExists) {\r\n        console.warn(`Thread ${threadId} not found in threads list`);\r\n        return;\r\n      }\r\n    }\r\n    \r\n    this.selectedThreadIdSubject.next(threadId);\r\n  }\r\n\r\n  setResolvedThreadId(threadId: string | undefined): void {\r\n    this.resolvedThreadIdSubject.next(threadId);\r\n  }\r\n\r\n  getNextActiveThreadIdFromService(currentThreadId: string): string | undefined {\r\n    return getNextActiveThreadId(this.threadsSubject.value, currentThreadId);\r\n  }\r\n\r\n  // Method to manually refresh threads\r\n  async refreshThreads(): Promise<void> {\r\n    if (this.chatClient) {\r\n      await this.fetchThreads();\r\n    } else {\r\n    }\r\n  }\r\n\r\n  // Method to update thread status (used when resolving chat)\r\n  async updateThreadStatusExternal(threadId: string, status: ThreadItemStatus): Promise<void> {\r\n    try {\r\n      // Update backend first\r\n      if (status === ThreadItemStatus.RESOLVED) {\r\n        await this.agentWorkItemService.updateAgentWorkItem(threadId, status);\r\n      } else {\r\n        await this.agentWorkItemService.createAgentWorkItem(threadId, status);\r\n      }\r\n      \r\n      // Then update local state\r\n      this.updateThreadStatus(threadId, status);\r\n      \r\n    } catch (error) {\r\n      console.error(`Failed to update thread ${threadId} status:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}