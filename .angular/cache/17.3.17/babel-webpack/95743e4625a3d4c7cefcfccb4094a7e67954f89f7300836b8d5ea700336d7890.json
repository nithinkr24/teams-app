{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport debug from \"./debug.js\";\nconst TYPESPEC_RUNTIME_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\nfunction patchLogMethod(parent, child) {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\nfunction isTypeSpecRuntimeLogLevel(level) {\n  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);\n}\n/**\n * Creates a logger context base on the provided options.\n * @param options - The options for creating a logger context.\n * @returns The logger context.\n */\nexport function createLoggerContext(options) {\n  const registeredLoggers = new Set();\n  const logLevelFromEnv = typeof process !== \"undefined\" && process.env && process.env[options.logLevelEnvVarName] || undefined;\n  let logLevel;\n  const clientLogger = debug(options.namespace);\n  clientLogger.log = (...args) => {\n    debug.log(...args);\n  };\n  function contextSetLogLevel(level) {\n    if (level && !isTypeSpecRuntimeLogLevel(level)) {\n      throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\",\")}`);\n    }\n    logLevel = level;\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n    debug.enable(enabledNamespaces.join(\",\"));\n  }\n  if (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {\n      contextSetLogLevel(logLevelFromEnv);\n    } else {\n      console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\", \")}.`);\n    }\n  }\n  function shouldEnable(logger) {\n    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);\n  }\n  function createLogger(parent, level) {\n    const logger = Object.assign(parent.extend(level), {\n      level\n    });\n    patchLogMethod(parent, logger);\n    if (shouldEnable(logger)) {\n      const enabledNamespaces = debug.disable();\n      debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n    registeredLoggers.add(logger);\n    return logger;\n  }\n  function contextGetLogLevel() {\n    return logLevel;\n  }\n  function contextCreateClientLogger(namespace) {\n    const clientRootLogger = clientLogger.extend(namespace);\n    patchLogMethod(clientLogger, clientRootLogger);\n    return {\n      error: createLogger(clientRootLogger, \"error\"),\n      warning: createLogger(clientRootLogger, \"warning\"),\n      info: createLogger(clientRootLogger, \"info\"),\n      verbose: createLogger(clientRootLogger, \"verbose\")\n    };\n  }\n  return {\n    setLogLevel: contextSetLogLevel,\n    getLogLevel: contextGetLogLevel,\n    createClientLogger: contextCreateClientLogger,\n    logger: clientLogger\n  };\n}\nconst context = createLoggerContext({\n  logLevelEnvVarName: \"TYPESPEC_RUNTIME_LOG_LEVEL\",\n  namespace: \"typeSpecRuntime\"\n});\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const TypeSpecRuntimeLogger = context.logger;\n/**\n * Retrieves the currently specified log level.\n */\nexport function setLogLevel(logLevel) {\n  context.setLogLevel(logLevel);\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return context.getLogLevel();\n}\n/**\n * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n  return context.createClientLogger(namespace);\n}\n//# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}