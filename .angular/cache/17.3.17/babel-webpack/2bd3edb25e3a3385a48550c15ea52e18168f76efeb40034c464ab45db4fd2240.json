{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const response = yield next(request);\n        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n      })();\n    }\n  };\n}\nfunction getOperationResponseMap(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  let result;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\nfunction deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction _deserializeResponseBody() {\n  _deserializeResponseBody = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = yield parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n      return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n      return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const {\n      error,\n      shouldReturnResponse\n    } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n      throw error;\n    } else if (shouldReturnResponse) {\n      return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n      if (responseSpec.bodyMapper) {\n        let valueToDeserialize = parsedResponse.parsedBody;\n        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n        }\n        try {\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n        } catch (deserializeError) {\n          const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse\n          });\n          throw restError;\n        }\n      } else if (operationSpec.httpMethod === \"HEAD\") {\n        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n      }\n      if (responseSpec.headersMapper) {\n        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", {\n          xml: {},\n          ignoreUnknownProperties: true\n        });\n      }\n    }\n    return parsedResponse;\n  });\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n  var _a, _b, _c, _d, _e;\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  });\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // and the parsed body doesn't look like an error object,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec && !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n    throw error;\n  }\n  const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n      }\n      const internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    }\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\nfunction parse(_x6, _x7, _x8, _x9, _x0) {\n  return _parse.apply(this, arguments);\n} //# sourceMappingURL=deserializationPolicy.js.map\nfunction _parse() {\n  _parse = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {\n      const text = operationResponse.bodyAsText;\n      const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n      const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n      try {\n        if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n          operationResponse.parsedBody = JSON.parse(text);\n          return operationResponse;\n        } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n          if (!parseXML) {\n            throw new Error(\"Parsing XML not supported.\");\n          }\n          const body = yield parseXML(text, opts.xml);\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        }\n      } catch (err) {\n        const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n        const errCode = err.code || RestError.PARSE_ERROR;\n        const e = new RestError(msg, {\n          code: errCode,\n          statusCode: operationResponse.status,\n          request: operationResponse.request,\n          response: operationResponse\n        });\n        throw e;\n      }\n    }\n    return operationResponse;\n  });\n  return _parse.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}