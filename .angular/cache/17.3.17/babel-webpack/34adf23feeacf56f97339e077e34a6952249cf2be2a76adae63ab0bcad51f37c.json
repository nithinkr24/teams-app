{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isQueryParameterWithOptions(x) {\n  const value = x.value;\n  return value !== undefined && value.toString !== undefined && typeof value.toString === \"function\";\n}\n/**\n * Builds the request url, filling in query and path parameters\n * @param endpoint - base url which can be a template url\n * @param routePath - path to append to the endpoint\n * @param pathParameters - values of the path parameters\n * @param options - request parameters including query parameters\n * @returns a full url with path and query parameters\n */\nexport function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {\n  if (routePath.startsWith(\"https://\") || routePath.startsWith(\"http://\")) {\n    return routePath;\n  }\n  endpoint = buildBaseUrl(endpoint, options);\n  routePath = buildRoutePath(routePath, pathParameters, options);\n  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);\n  const url = new URL(requestUrl);\n  return url.toString()\n  // Remove double forward slashes\n  .replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nfunction getQueryParamValue(key, allowReserved, style, param) {\n  let separator;\n  if (style === \"pipeDelimited\") {\n    separator = \"|\";\n  } else if (style === \"spaceDelimited\") {\n    separator = \"%20\";\n  } else {\n    separator = \",\";\n  }\n  let paramValues;\n  if (Array.isArray(param)) {\n    paramValues = param;\n  } else if (typeof param === \"object\" && param.toString === Object.prototype.toString) {\n    // If the parameter is an object without a custom toString implementation (e.g. a Date),\n    // then we should deconstruct the object into an array [key1, value1, key2, value2, ...].\n    paramValues = Object.entries(param).flat();\n  } else {\n    paramValues = [param];\n  }\n  const value = paramValues.map(p => {\n    if (p === null || p === undefined) {\n      return \"\";\n    }\n    if (!p.toString || typeof p.toString !== \"function\") {\n      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);\n    }\n    const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();\n    return allowReserved ? rawValue : encodeURIComponent(rawValue);\n  }).join(separator);\n  return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;\n}\nfunction appendQueryParams(url, options = {}) {\n  var _a, _b, _c, _d;\n  if (!options.queryParameters) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  const queryParams = options.queryParameters;\n  const paramStrings = [];\n  for (const key of Object.keys(queryParams)) {\n    const param = queryParams[key];\n    if (param === undefined || param === null) {\n      continue;\n    }\n    const hasMetadata = isQueryParameterWithOptions(param);\n    const rawValue = hasMetadata ? param.value : param;\n    const explode = hasMetadata ? (_a = param.explode) !== null && _a !== void 0 ? _a : false : false;\n    const style = hasMetadata && param.style ? param.style : \"form\";\n    if (explode) {\n      if (Array.isArray(rawValue)) {\n        for (const item of rawValue) {\n          paramStrings.push(getQueryParamValue(key, (_b = options.skipUrlEncoding) !== null && _b !== void 0 ? _b : false, style, item));\n        }\n      } else if (typeof rawValue === \"object\") {\n        // For object explode, the name of the query parameter is ignored and we use the object key instead\n        for (const [actualKey, value] of Object.entries(rawValue)) {\n          paramStrings.push(getQueryParamValue(actualKey, (_c = options.skipUrlEncoding) !== null && _c !== void 0 ? _c : false, style, value));\n        }\n      } else {\n        // Explode doesn't really make sense for primitives\n        throw new Error(\"explode can only be set to true for objects and arrays\");\n      }\n    } else {\n      paramStrings.push(getQueryParamValue(key, (_d = options.skipUrlEncoding) !== null && _d !== void 0 ? _d : false, style, rawValue));\n    }\n  }\n  if (parsedUrl.search !== \"\") {\n    parsedUrl.search += \"&\";\n  }\n  parsedUrl.search += paramStrings.join(\"&\");\n  return parsedUrl.toString();\n}\nexport function buildBaseUrl(endpoint, options) {\n  var _a;\n  if (!options.pathParameters) {\n    return endpoint;\n  }\n  const pathParams = options.pathParameters;\n  for (const [key, param] of Object.entries(pathParams)) {\n    if (param === undefined || param === null) {\n      throw new Error(`Path parameters ${key} must not be undefined or null`);\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);\n    }\n    let value = param.toISOString !== undefined ? param.toISOString() : String(param);\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(param);\n    }\n    endpoint = (_a = replaceAll(endpoint, `{${key}}`, value)) !== null && _a !== void 0 ? _a : \"\";\n  }\n  return endpoint;\n}\nfunction buildRoutePath(routePath, pathParameters, options = {}) {\n  var _a;\n  for (const pathParam of pathParameters) {\n    const allowReserved = typeof pathParam === \"object\" && ((_a = pathParam.allowReserved) !== null && _a !== void 0 ? _a : false);\n    let value = typeof pathParam === \"object\" ? pathParam.value : pathParam;\n    if (!options.skipUrlEncoding && !allowReserved) {\n      value = encodeURIComponent(value);\n    }\n    routePath = routePath.replace(/\\{[\\w-]+\\}/, String(value));\n  }\n  return routePath;\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}","map":{"version":3,"names":["isQueryParameterWithOptions","x","value","undefined","toString","buildRequestUrl","endpoint","routePath","pathParameters","options","startsWith","buildBaseUrl","buildRoutePath","requestUrl","appendQueryParams","url","URL","replace","getQueryParamValue","key","allowReserved","style","param","separator","paramValues","Array","isArray","Object","prototype","entries","flat","map","p","Error","rawValue","toISOString","encodeURIComponent","join","_a","_b","_c","_d","queryParameters","parsedUrl","queryParams","paramStrings","keys","hasMetadata","explode","item","push","skipUrlEncoding","actualKey","search","pathParams","String","replaceAll","pathParam","searchValue","replaceValue","split"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/client/urlHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isQueryParameterWithOptions(x) {\n    const value = x.value;\n    return (value !== undefined && value.toString !== undefined && typeof value.toString === \"function\");\n}\n/**\n * Builds the request url, filling in query and path parameters\n * @param endpoint - base url which can be a template url\n * @param routePath - path to append to the endpoint\n * @param pathParameters - values of the path parameters\n * @param options - request parameters including query parameters\n * @returns a full url with path and query parameters\n */\nexport function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {\n    if (routePath.startsWith(\"https://\") || routePath.startsWith(\"http://\")) {\n        return routePath;\n    }\n    endpoint = buildBaseUrl(endpoint, options);\n    routePath = buildRoutePath(routePath, pathParameters, options);\n    const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);\n    const url = new URL(requestUrl);\n    return (url\n        .toString()\n        // Remove double forward slashes\n        .replace(/([^:]\\/)\\/+/g, \"$1\"));\n}\nfunction getQueryParamValue(key, allowReserved, style, param) {\n    let separator;\n    if (style === \"pipeDelimited\") {\n        separator = \"|\";\n    }\n    else if (style === \"spaceDelimited\") {\n        separator = \"%20\";\n    }\n    else {\n        separator = \",\";\n    }\n    let paramValues;\n    if (Array.isArray(param)) {\n        paramValues = param;\n    }\n    else if (typeof param === \"object\" && param.toString === Object.prototype.toString) {\n        // If the parameter is an object without a custom toString implementation (e.g. a Date),\n        // then we should deconstruct the object into an array [key1, value1, key2, value2, ...].\n        paramValues = Object.entries(param).flat();\n    }\n    else {\n        paramValues = [param];\n    }\n    const value = paramValues\n        .map((p) => {\n        if (p === null || p === undefined) {\n            return \"\";\n        }\n        if (!p.toString || typeof p.toString !== \"function\") {\n            throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);\n        }\n        const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();\n        return allowReserved ? rawValue : encodeURIComponent(rawValue);\n    })\n        .join(separator);\n    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;\n}\nfunction appendQueryParams(url, options = {}) {\n    var _a, _b, _c, _d;\n    if (!options.queryParameters) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    const queryParams = options.queryParameters;\n    const paramStrings = [];\n    for (const key of Object.keys(queryParams)) {\n        const param = queryParams[key];\n        if (param === undefined || param === null) {\n            continue;\n        }\n        const hasMetadata = isQueryParameterWithOptions(param);\n        const rawValue = hasMetadata ? param.value : param;\n        const explode = hasMetadata ? ((_a = param.explode) !== null && _a !== void 0 ? _a : false) : false;\n        const style = hasMetadata && param.style ? param.style : \"form\";\n        if (explode) {\n            if (Array.isArray(rawValue)) {\n                for (const item of rawValue) {\n                    paramStrings.push(getQueryParamValue(key, (_b = options.skipUrlEncoding) !== null && _b !== void 0 ? _b : false, style, item));\n                }\n            }\n            else if (typeof rawValue === \"object\") {\n                // For object explode, the name of the query parameter is ignored and we use the object key instead\n                for (const [actualKey, value] of Object.entries(rawValue)) {\n                    paramStrings.push(getQueryParamValue(actualKey, (_c = options.skipUrlEncoding) !== null && _c !== void 0 ? _c : false, style, value));\n                }\n            }\n            else {\n                // Explode doesn't really make sense for primitives\n                throw new Error(\"explode can only be set to true for objects and arrays\");\n            }\n        }\n        else {\n            paramStrings.push(getQueryParamValue(key, (_d = options.skipUrlEncoding) !== null && _d !== void 0 ? _d : false, style, rawValue));\n        }\n    }\n    if (parsedUrl.search !== \"\") {\n        parsedUrl.search += \"&\";\n    }\n    parsedUrl.search += paramStrings.join(\"&\");\n    return parsedUrl.toString();\n}\nexport function buildBaseUrl(endpoint, options) {\n    var _a;\n    if (!options.pathParameters) {\n        return endpoint;\n    }\n    const pathParams = options.pathParameters;\n    for (const [key, param] of Object.entries(pathParams)) {\n        if (param === undefined || param === null) {\n            throw new Error(`Path parameters ${key} must not be undefined or null`);\n        }\n        if (!param.toString || typeof param.toString !== \"function\") {\n            throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);\n        }\n        let value = param.toISOString !== undefined ? param.toISOString() : String(param);\n        if (!options.skipUrlEncoding) {\n            value = encodeURIComponent(param);\n        }\n        endpoint = (_a = replaceAll(endpoint, `{${key}}`, value)) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return endpoint;\n}\nfunction buildRoutePath(routePath, pathParameters, options = {}) {\n    var _a;\n    for (const pathParam of pathParameters) {\n        const allowReserved = typeof pathParam === \"object\" && ((_a = pathParam.allowReserved) !== null && _a !== void 0 ? _a : false);\n        let value = typeof pathParam === \"object\" ? pathParam.value : pathParam;\n        if (!options.skipUrlEncoding && !allowReserved) {\n            value = encodeURIComponent(value);\n        }\n        routePath = routePath.replace(/\\{[\\w-]+\\}/, String(value));\n    }\n    return routePath;\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(value, searchValue, replaceValue) {\n    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}