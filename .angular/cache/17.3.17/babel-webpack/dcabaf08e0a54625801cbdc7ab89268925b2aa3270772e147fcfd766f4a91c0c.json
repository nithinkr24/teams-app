{"ast":null,"code":"import e from \"../../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js\";\nconst t = \"1.0.1\",\n  n = {\n    onMessage: function (e, t) {\n      if (!e || !e.data || \"object\" != typeof e.data || null === e.data) return void a(\"Invalid message format, ignoring. Message: %o\", e);\n      if (!function (e, t) {\n        if (t === o) try {\n          return \"https:\" === new URL(t).protocol;\n        } catch (e) {\n          return d(\"Invalid message origin URL:\", e), !1;\n        }\n        return !1;\n      }(e.source, e.origin)) return void a(\"Message source/origin not allowed, ignoring.\");\n      const {\n          args: n\n        } = e.data,\n        [, r] = null != n ? n : [],\n        i = (() => {\n          try {\n            return JSON.parse(r);\n          } catch (e) {\n            return d(\"Failed to parse response message:\", e), null;\n          }\n        })();\n      if (!i || \"NestedAppAuthResponse\" !== i.messageType) return void a(\"Invalid response format, ignoring. Message: %o\", e);\n      t(r);\n    }\n  };\nlet o = null,\n  r = !1;\nfunction i(t, i, p = !1) {\n  if (r = p, !t) throw new Error(\"Cannot polyfill nestedAppAuthBridge as the current window does not exist\");\n  if (!i) throw new Error(\"Top origin is required to initialize the Nested App Auth Bridge\");\n  try {\n    const e = new URL(i);\n    if (\"https:\" !== e.protocol) throw new Error(`Invalid top origin: ${i}. Only HTTPS origins are allowed.`);\n    o = e.origin;\n  } catch (e) {\n    throw new Error(`Failed to initialize bridge: invalid top origin: ${i}`);\n  }\n  const u = t;\n  if (u.nestedAppAuthBridge) return void a(\"Nested App Auth Bridge is already present\");\n  const g = function (t) {\n    const r = new WeakMap(),\n      {\n        onMessage: i\n      } = n,\n      p = e => t => i(t, e);\n    return {\n      addEventListener: (e, n) => {\n        if (\"message\" === e) {\n          const o = p(n);\n          r.set(n, o), t.addEventListener(e, o);\n        } else a(`Event ${e} is not supported by nestedAppAuthBridge`);\n      },\n      postMessage: n => {\n        if (!t.top) throw new Error(\"window.top is not available for posting messages\");\n        try {\n          const r = JSON.parse(n);\n          if (\"object\" == typeof r && \"NestedAppAuthRequest\" === r.messageType) {\n            const r = function (t) {\n              const n = Date.now();\n              return {\n                id: s(),\n                uuid: e(),\n                func: \"nestedAppAuth.execute\",\n                timestamp: n,\n                apiVersionTag: \"v2_nestedAppAuth.execute\",\n                monotonicTimestamp: n,\n                args: [],\n                data: t\n              };\n            }(n);\n            if (t === t.top || !o) return void d(\"Not in an embedded iframe; skipping postMessage.\");\n            t.top.postMessage(r, o);\n          }\n        } catch (e) {\n          return void d(\"Failed to parse message:\", e, \"Original message:\", n);\n        }\n      },\n      removeEventListener: (e, n) => {\n        const o = r.get(n);\n        o && (t.removeEventListener(e, o), r.delete(n));\n      }\n    };\n  }(u);\n  g && (u.nestedAppAuthBridge = g);\n}\nfunction s() {\n  return \"undefined\" != typeof crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).substring(2, 11);\n}\nfunction a(...e) {\n  r && console.log(...e);\n}\nfunction d(...e) {\n  r && console.error(...e);\n}\nexport { i as initialize, t as version };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}