{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline {\n  constructor(policies) {\n    var _a;\n    this._policies = [];\n    this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n    this._orderedPolicies = undefined;\n  }\n  addPolicy(policy, options = {}) {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options\n    });\n    this._orderedPolicies = undefined;\n  }\n  removePolicy(options) {\n    const removedPolicies = [];\n    this._policies = this._policies.filter(policyDescriptor => {\n      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n    return removedPolicies;\n  }\n  sendRequest(httpClient, request) {\n    const policies = this.getOrderedPolicies();\n    const pipeline = policies.reduceRight((next, policy) => {\n      return req => {\n        return policy.sendRequest(req, next);\n      };\n    }, req => httpClient.sendRequest(req));\n    return pipeline(request);\n  }\n  getOrderedPolicies() {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n  clone() {\n    return new HttpPipeline(this._policies);\n  }\n  static create() {\n    return new HttpPipeline();\n  }\n  orderPolicies() {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result = [];\n    // Track all policies we know about.\n    const policyMap = new Map();\n    function createPhase(name) {\n      return {\n        name,\n        policies: new Set(),\n        hasRun: false,\n        hasAfterPolicies: false\n      };\n    }\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase) {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node = {\n        policy,\n        dependsOn: new Set(),\n        dependants: new Set()\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const {\n        policy,\n        options\n      } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n    function walkPhase(phase) {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n    function walkPhases() {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n    return result;\n  }\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n  return HttpPipeline.create();\n}","map":{"version":3,"names":["ValidPhaseNames","Set","HttpPipeline","constructor","policies","_a","_policies","slice","_orderedPolicies","undefined","addPolicy","policy","options","phase","afterPhase","Error","has","push","removePolicy","removedPolicies","filter","policyDescriptor","name","sendRequest","httpClient","request","getOrderedPolicies","pipeline","reduceRight","next","req","orderPolicies","clone","create","result","policyMap","Map","createPhase","hasRun","hasAfterPolicies","serializePhase","noPhase","deserializePhase","retryPhase","signPhase","orderedPhases","getPhase","descriptor","policyName","node","dependsOn","dependants","set","add","get","afterPolicies","afterPolicyName","afterNode","beforePolicies","beforePolicyName","beforeNode","walkPhase","size","dependant","delete","walkPhases","iteration","initialResultLength","length","createEmptyPipeline"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@typespec/ts-http-runtime/dist/browser/pipeline.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline {\n    constructor(policies) {\n        var _a;\n        this._policies = [];\n        this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n        this._orderedPolicies = undefined;\n    }\n    addPolicy(policy, options = {}) {\n        if (options.phase && options.afterPhase) {\n            throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n        }\n        if (options.phase && !ValidPhaseNames.has(options.phase)) {\n            throw new Error(`Invalid phase name: ${options.phase}`);\n        }\n        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n        }\n        this._policies.push({\n            policy,\n            options,\n        });\n        this._orderedPolicies = undefined;\n    }\n    removePolicy(options) {\n        const removedPolicies = [];\n        this._policies = this._policies.filter((policyDescriptor) => {\n            if ((options.name && policyDescriptor.policy.name === options.name) ||\n                (options.phase && policyDescriptor.options.phase === options.phase)) {\n                removedPolicies.push(policyDescriptor.policy);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n        this._orderedPolicies = undefined;\n        return removedPolicies;\n    }\n    sendRequest(httpClient, request) {\n        const policies = this.getOrderedPolicies();\n        const pipeline = policies.reduceRight((next, policy) => {\n            return (req) => {\n                return policy.sendRequest(req, next);\n            };\n        }, (req) => httpClient.sendRequest(req));\n        return pipeline(request);\n    }\n    getOrderedPolicies() {\n        if (!this._orderedPolicies) {\n            this._orderedPolicies = this.orderPolicies();\n        }\n        return this._orderedPolicies;\n    }\n    clone() {\n        return new HttpPipeline(this._policies);\n    }\n    static create() {\n        return new HttpPipeline();\n    }\n    orderPolicies() {\n        /**\n         * The goal of this method is to reliably order pipeline policies\n         * based on their declared requirements when they were added.\n         *\n         * Order is first determined by phase:\n         *\n         * 1. Serialize Phase\n         * 2. Policies not in a phase\n         * 3. Deserialize Phase\n         * 4. Retry Phase\n         * 5. Sign Phase\n         *\n         * Within each phase, policies are executed in the order\n         * they were added unless they were specified to execute\n         * before/after other policies or after a particular phase.\n         *\n         * To determine the final order, we will walk the policy list\n         * in phase order multiple times until all dependencies are\n         * satisfied.\n         *\n         * `afterPolicies` are the set of policies that must be\n         * executed before a given policy. This requirement is\n         * considered satisfied when each of the listed policies\n         * have been scheduled.\n         *\n         * `beforePolicies` are the set of policies that must be\n         * executed after a given policy. Since this dependency\n         * can be expressed by converting it into a equivalent\n         * `afterPolicies` declarations, they are normalized\n         * into that form for simplicity.\n         *\n         * An `afterPhase` dependency is considered satisfied when all\n         * policies in that phase have scheduled.\n         *\n         */\n        const result = [];\n        // Track all policies we know about.\n        const policyMap = new Map();\n        function createPhase(name) {\n            return {\n                name,\n                policies: new Set(),\n                hasRun: false,\n                hasAfterPolicies: false,\n            };\n        }\n        // Track policies for each phase.\n        const serializePhase = createPhase(\"Serialize\");\n        const noPhase = createPhase(\"None\");\n        const deserializePhase = createPhase(\"Deserialize\");\n        const retryPhase = createPhase(\"Retry\");\n        const signPhase = createPhase(\"Sign\");\n        // a list of phases in order\n        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n        // Small helper function to map phase name to each Phase\n        function getPhase(phase) {\n            if (phase === \"Retry\") {\n                return retryPhase;\n            }\n            else if (phase === \"Serialize\") {\n                return serializePhase;\n            }\n            else if (phase === \"Deserialize\") {\n                return deserializePhase;\n            }\n            else if (phase === \"Sign\") {\n                return signPhase;\n            }\n            else {\n                return noPhase;\n            }\n        }\n        // First walk each policy and create a node to track metadata.\n        for (const descriptor of this._policies) {\n            const policy = descriptor.policy;\n            const options = descriptor.options;\n            const policyName = policy.name;\n            if (policyMap.has(policyName)) {\n                throw new Error(\"Duplicate policy names not allowed in pipeline\");\n            }\n            const node = {\n                policy,\n                dependsOn: new Set(),\n                dependants: new Set(),\n            };\n            if (options.afterPhase) {\n                node.afterPhase = getPhase(options.afterPhase);\n                node.afterPhase.hasAfterPolicies = true;\n            }\n            policyMap.set(policyName, node);\n            const phase = getPhase(options.phase);\n            phase.policies.add(node);\n        }\n        // Now that each policy has a node, connect dependency references.\n        for (const descriptor of this._policies) {\n            const { policy, options } = descriptor;\n            const policyName = policy.name;\n            const node = policyMap.get(policyName);\n            if (!node) {\n                throw new Error(`Missing node for policy ${policyName}`);\n            }\n            if (options.afterPolicies) {\n                for (const afterPolicyName of options.afterPolicies) {\n                    const afterNode = policyMap.get(afterPolicyName);\n                    if (afterNode) {\n                        // Linking in both directions helps later\n                        // when we want to notify dependants.\n                        node.dependsOn.add(afterNode);\n                        afterNode.dependants.add(node);\n                    }\n                }\n            }\n            if (options.beforePolicies) {\n                for (const beforePolicyName of options.beforePolicies) {\n                    const beforeNode = policyMap.get(beforePolicyName);\n                    if (beforeNode) {\n                        // To execute before another node, make it\n                        // depend on the current node.\n                        beforeNode.dependsOn.add(node);\n                        node.dependants.add(beforeNode);\n                    }\n                }\n            }\n        }\n        function walkPhase(phase) {\n            phase.hasRun = true;\n            // Sets iterate in insertion order\n            for (const node of phase.policies) {\n                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n                    // If this node is waiting on a phase to complete,\n                    // we need to skip it for now.\n                    // Even if the phase is empty, we should wait for it\n                    // to be walked to avoid re-ordering policies.\n                    continue;\n                }\n                if (node.dependsOn.size === 0) {\n                    // If there's nothing else we're waiting for, we can\n                    // add this policy to the result list.\n                    result.push(node.policy);\n                    // Notify anything that depends on this policy that\n                    // the policy has been scheduled.\n                    for (const dependant of node.dependants) {\n                        dependant.dependsOn.delete(node);\n                    }\n                    policyMap.delete(node.policy.name);\n                    phase.policies.delete(node);\n                }\n            }\n        }\n        function walkPhases() {\n            for (const phase of orderedPhases) {\n                walkPhase(phase);\n                // if the phase isn't complete\n                if (phase.policies.size > 0 && phase !== noPhase) {\n                    if (!noPhase.hasRun) {\n                        // Try running noPhase to see if that unblocks this phase next tick.\n                        // This can happen if a phase that happens before noPhase\n                        // is waiting on a noPhase policy to complete.\n                        walkPhase(noPhase);\n                    }\n                    // Don't proceed to the next phase until this phase finishes.\n                    return;\n                }\n                if (phase.hasAfterPolicies) {\n                    // Run any policies unblocked by this phase\n                    walkPhase(noPhase);\n                }\n            }\n        }\n        // Iterate until we've put every node in the result list.\n        let iteration = 0;\n        while (policyMap.size > 0) {\n            iteration++;\n            const initialResultLength = result.length;\n            // Keep walking each phase in order until we can order every node.\n            walkPhases();\n            // The result list *should* get at least one larger each time\n            // after the first full pass.\n            // Otherwise, we're going to loop forever.\n            if (result.length <= initialResultLength && iteration > 1) {\n                throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n            }\n        }\n        return result;\n    }\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n    return HttpPipeline.create();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}