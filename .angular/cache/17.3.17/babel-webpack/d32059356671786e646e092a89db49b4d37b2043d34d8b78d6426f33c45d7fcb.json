{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n  return mapperTypeName !== \"Composite\" && mapperTypeName !== \"Dictionary\" && (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n    return responseObject.shouldWrapBody ? {\n      body: null\n    } : null;\n  } else {\n    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {\n      body: responseObject.body\n    }) : combinedHeadersAndBody;\n  }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n  var _a, _b;\n  const parsedHeaders = fullResponse.parsedHeaders;\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      body: fullResponse.parsedBody\n    });\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody\n    });\n  }\n  const modelProperties = expectedBodyTypeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n  const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n      }\n    }\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;\n  }\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)\n  });\n}","map":{"version":3,"names":["isPrimitiveBody","value","mapperTypeName","match","undefined","validateISODuration","isDuration","test","validUuidRegex","isValidUuid","uuid","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","Object","assign","headers","body","hasNullableType","getOwnPropertyNames","length","shouldWrapBody","flattenResponse","fullResponse","responseSpec","_a","_b","parsedHeaders","request","method","parsedBody","bodyMapper","isNullable","Boolean","nullable","expectedBodyTypeName","type","name","blobBody","readableStreamBody","modelProperties","isPageableResponse","keys","some","k","serializedName","arrayResponse","key"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-client/dist/browser/utils.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n    return (mapperTypeName !== \"Composite\" &&\n        mapperTypeName !== \"Dictionary\" &&\n        (typeof value === \"string\" ||\n            typeof value === \"number\" ||\n            typeof value === \"boolean\" ||\n            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==\n                null ||\n            value === undefined ||\n            value === null));\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n    return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n    return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n    if (responseObject.hasNullableType &&\n        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n        return responseObject.shouldWrapBody ? { body: null } : null;\n    }\n    else {\n        return responseObject.shouldWrapBody\n            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;\n    }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n    var _a, _b;\n    const parsedHeaders = fullResponse.parsedHeaders;\n    // head methods never have a body, but we return a boolean set to body property\n    // to indicate presence/absence of the resource\n    if (fullResponse.request.method === \"HEAD\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });\n    }\n    const bodyMapper = responseSpec && responseSpec.bodyMapper;\n    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n    /** If the body is asked for, we look at the expected body type to handle it */\n    if (expectedBodyTypeName === \"Stream\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });\n    }\n    const modelProperties = (expectedBodyTypeName === \"Composite\" &&\n        bodyMapper.type.modelProperties) ||\n        {};\n    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === \"\");\n    if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n        for (const key of Object.keys(modelProperties)) {\n            if (modelProperties[key].serializedName) {\n                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n            }\n        }\n        if (parsedHeaders) {\n            for (const key of Object.keys(parsedHeaders)) {\n                arrayResponse[key] = parsedHeaders[key];\n            }\n        }\n        return isNullable &&\n            !fullResponse.parsedBody &&\n            !parsedHeaders &&\n            Object.getOwnPropertyNames(modelProperties).length === 0\n            ? null\n            : arrayResponse;\n    }\n    return handleNullableResponseAndWrappableBody({\n        body: fullResponse.parsedBody,\n        headers: parsedHeaders,\n        hasNullableType: isNullable,\n        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}