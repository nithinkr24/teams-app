{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\nconst CollectionFormatToDelimiterMap = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n  let isAbsolutePath = false;\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n  const {\n    queryParams,\n    sequenceParams\n  } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n  return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n    }\n  }\n  return result;\n}\nfunction isAbsoluteUrl(url) {\n  return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n  if (!pathToAppend) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n  parsedUrl.pathname = newPath;\n  return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  const sequenceParams = new Set();\n  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n      if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {\n        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map(item => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map(item => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams\n  };\n}\nfunction simpleParseQueryParams(queryString) {\n  const result = new Map();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n  return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n  if (queryParams.size === 0) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n  const searchPieces = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}","map":{"version":3,"names":["getOperationArgumentValueFromParameter","getPathStringFromParameter","CollectionFormatToDelimiterMap","CSV","SSV","Multi","TSV","Pipes","getRequestUrl","baseUri","operationSpec","operationArguments","fallbackObject","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","startsWith","substring","isAbsoluteUrl","appendPath","queryParams","sequenceParams","calculateQueryParameters","appendQueryParams","input","replacements","result","searchValue","replaceValue","split","join","_a","Map","urlParameters","length","urlParameter","urlParameterValue","parameterPathString","serializer","serialize","mapper","skipEncoding","encodeURIComponent","set","serializedName","url","includes","pathToAppend","parsedUrl","URL","newPath","pathname","endsWith","searchStart","indexOf","search","toString","Set","queryParameters","queryParameter","type","name","add","queryParameterValue","undefined","required","delimiter","collectionFormat","Array","isArray","map","item","simpleParseQueryParams","queryString","slice","pairs","pair","value","existingValue","get","push","noOverwrite","size","combinedParams","valueSet","from","unshift","has","searchPieces","subValue"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-client/dist/browser/urlHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\nconst CollectionFormatToDelimiterMap = {\n    CSV: \",\",\n    SSV: \" \",\n    Multi: \"Multi\",\n    TSV: \"\\t\",\n    Pipes: \"|\",\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n    let isAbsolutePath = false;\n    let requestUrl = replaceAll(baseUri, urlReplacements);\n    if (operationSpec.path) {\n        let path = replaceAll(operationSpec.path, urlReplacements);\n        // QUIRK: sometimes we get a path component like /{nextLink}\n        // which may be a fully formed URL with a leading /. In that case, we should\n        // remove the leading /\n        if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        // QUIRK: sometimes we get a path component like {nextLink}\n        // which may be a fully formed URL. In that case, we should\n        // ignore the baseUri.\n        if (isAbsoluteUrl(path)) {\n            requestUrl = path;\n            isAbsolutePath = true;\n        }\n        else {\n            requestUrl = appendPath(requestUrl, path);\n        }\n    }\n    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n    /**\n     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n     * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n     * is still being built so there is nothing to overwrite.\n     */\n    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n    return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n    let result = input;\n    for (const [searchValue, replaceValue] of replacements) {\n        result = result.split(searchValue).join(replaceValue);\n    }\n    return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n            const parameterPathString = getPathStringFromParameter(urlParameter);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n            if (!urlParameter.skipEncoding) {\n                urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n        }\n    }\n    return result;\n}\nfunction isAbsoluteUrl(url) {\n    return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n    if (!pathToAppend) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    let newPath = parsedUrl.pathname;\n    if (!newPath.endsWith(\"/\")) {\n        newPath = `${newPath}/`;\n    }\n    if (pathToAppend.startsWith(\"/\")) {\n        pathToAppend = pathToAppend.substring(1);\n    }\n    const searchStart = pathToAppend.indexOf(\"?\");\n    if (searchStart !== -1) {\n        const path = pathToAppend.substring(0, searchStart);\n        const search = pathToAppend.substring(searchStart + 1);\n        newPath = newPath + path;\n        if (search) {\n            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n        }\n    }\n    else {\n        newPath = newPath + pathToAppend;\n    }\n    parsedUrl.pathname = newPath;\n    return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    const sequenceParams = new Set();\n    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const queryParameter of operationSpec.queryParameters) {\n            if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n                sequenceParams.add(queryParameter.mapper.serializedName);\n            }\n            let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||\n                queryParameter.mapper.required) {\n                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n                const delimiter = queryParameter.collectionFormat\n                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n                    : \"\";\n                if (Array.isArray(queryParameterValue)) {\n                    // replace null and undefined\n                    queryParameterValue = queryParameterValue.map((item) => {\n                        if (item === null || item === undefined) {\n                            return \"\";\n                        }\n                        return item;\n                    });\n                }\n                if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n                    continue;\n                }\n                else if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                        queryParameterValue = queryParameterValue.map((item) => {\n                            return encodeURIComponent(item);\n                        });\n                    }\n                    else {\n                        queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                }\n                // Join pipes and CSV *after* encoding, or the server will be upset.\n                if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n        }\n    }\n    return {\n        queryParams: result,\n        sequenceParams,\n    };\n}\nfunction simpleParseQueryParams(queryString) {\n    const result = new Map();\n    if (!queryString || queryString[0] !== \"?\") {\n        return result;\n    }\n    // remove the leading ?\n    queryString = queryString.slice(1);\n    const pairs = queryString.split(\"&\");\n    for (const pair of pairs) {\n        const [name, value] = pair.split(\"=\", 2);\n        const existingValue = result.get(name);\n        if (existingValue) {\n            if (Array.isArray(existingValue)) {\n                existingValue.push(value);\n            }\n            else {\n                result.set(name, [existingValue, value]);\n            }\n        }\n        else {\n            result.set(name, value);\n        }\n    }\n    return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n    if (queryParams.size === 0) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n    // can change their meaning to the server, such as in the case of a SAS signature.\n    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n    const combinedParams = simpleParseQueryParams(parsedUrl.search);\n    for (const [name, value] of queryParams) {\n        const existingValue = combinedParams.get(name);\n        if (Array.isArray(existingValue)) {\n            if (Array.isArray(value)) {\n                existingValue.push(...value);\n                const valueSet = new Set(existingValue);\n                combinedParams.set(name, Array.from(valueSet));\n            }\n            else {\n                existingValue.push(value);\n            }\n        }\n        else if (existingValue) {\n            if (Array.isArray(value)) {\n                value.unshift(existingValue);\n            }\n            else if (sequenceParams.has(name)) {\n                combinedParams.set(name, [existingValue, value]);\n            }\n            if (!noOverwrite) {\n                combinedParams.set(name, value);\n            }\n        }\n        else {\n            combinedParams.set(name, value);\n        }\n    }\n    const searchPieces = [];\n    for (const [name, value] of combinedParams) {\n        if (typeof value === \"string\") {\n            searchPieces.push(`${name}=${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // QUIRK: If we get an array of values, include multiple key/value pairs\n            for (const subValue of value) {\n                searchPieces.push(`${name}=${subValue}`);\n            }\n        }\n        else {\n            searchPieces.push(`${name}=${value}`);\n        }\n    }\n    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n    parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n    return parsedUrl.toString();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}