{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isRestError, RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { createPipelineRequest } from \"../pipelineRequest.js\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers.js\";\nimport { isReadableStream } from \"../util/typeGuards.js\";\nimport { buildMultipartBody } from \"./multipart.js\";\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport function sendRequest(_x, _x2, _x3) {\n  return _sendRequest.apply(this, arguments);\n}\n/**\n * Function to determine the request content type\n * @param options - request options InternalRequestParameters\n * @returns returns the content-type\n */\nfunction _sendRequest() {\n  _sendRequest = _asyncToGenerator(function* (method, url, pipeline, options = {}, customHttpClient) {\n    var _a;\n    const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();\n    const request = buildPipelineRequest(method, url, options);\n    try {\n      const response = yield pipeline.sendRequest(httpClient, request);\n      const headers = response.headers.toJSON();\n      const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;\n      const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n      const body = stream !== null && stream !== void 0 ? stream : parsedBody;\n      if (options === null || options === void 0 ? void 0 : options.onResponse) {\n        options.onResponse(Object.assign(Object.assign({}, response), {\n          request,\n          rawHeaders: headers,\n          parsedBody\n        }));\n      }\n      return {\n        request,\n        headers,\n        status: `${response.status}`,\n        body\n      };\n    } catch (e) {\n      if (isRestError(e) && e.response && options.onResponse) {\n        const {\n          response\n        } = e;\n        const rawHeaders = response.headers.toJSON();\n        // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property\n        options === null || options === void 0 ? void 0 : options.onResponse(Object.assign(Object.assign({}, response), {\n          request,\n          rawHeaders\n        }), e);\n      }\n      throw e;\n    }\n  });\n  return _sendRequest.apply(this, arguments);\n}\nfunction getRequestContentType(options = {}) {\n  var _a, _b, _c;\n  return (_c = (_a = options.contentType) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b[\"content-type\"]) !== null && _c !== void 0 ? _c : getContentType(options.body);\n}\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body) {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n  if (typeof body === \"string\") {\n    try {\n      JSON.parse(body);\n      return \"application/json\";\n    } catch (error) {\n      // If we fail to parse the body, it is not json\n      return undefined;\n    }\n  }\n  // By default return json\n  return \"application/json\";\n}\nfunction buildPipelineRequest(method, url, options = {}) {\n  var _a, _b, _c;\n  const requestContentType = getRequestContentType(options);\n  const {\n    body,\n    multipartBody\n  } = getRequestBody(options.body, requestContentType);\n  const hasContent = body !== undefined || multipartBody !== undefined;\n  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), {\n    accept: (_c = (_a = options.accept) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b.accept) !== null && _c !== void 0 ? _c : \"application/json\"\n  }), hasContent && requestContentType && {\n    \"content-type\": requestContentType\n  }));\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    multipartBody,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined\n  });\n}\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body, contentType = \"\") {\n  if (body === undefined) {\n    return {\n      body: undefined\n    };\n  }\n  if (typeof FormData !== \"undefined\" && body instanceof FormData) {\n    return {\n      body\n    };\n  }\n  if (isReadableStream(body)) {\n    return {\n      body\n    };\n  }\n  if (ArrayBuffer.isView(body)) {\n    return {\n      body: body instanceof Uint8Array ? body : JSON.stringify(body)\n    };\n  }\n  const firstType = contentType.split(\";\")[0];\n  switch (firstType) {\n    case \"application/json\":\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"multipart/form-data\":\n      if (Array.isArray(body)) {\n        return {\n          multipartBody: buildMultipartBody(body)\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"text/plain\":\n      return {\n        body: String(body)\n      };\n    default:\n      if (typeof body === \"string\") {\n        return {\n          body\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n  }\n}\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response) {\n  var _a, _b;\n  // Set the default response type\n  const contentType = (_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : \"\";\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\nfunction createParseError(response, err) {\n  var _a;\n  const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n  const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response\n  });\n}\n//# sourceMappingURL=sendRequest.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}