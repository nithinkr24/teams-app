{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\nconst CollectionFormatToDelimiterMap = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n  let isAbsolutePath = false;\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n  const {\n    queryParams,\n    sequenceParams\n  } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n  return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n    }\n  }\n  return result;\n}\nfunction isAbsoluteUrl(url) {\n  return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n  if (!pathToAppend) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n  parsedUrl.pathname = newPath;\n  return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  const sequenceParams = new Set();\n  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n      if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {\n        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map(item => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map(item => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams\n  };\n}\nfunction simpleParseQueryParams(queryString) {\n  const result = new Map();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n  return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n  if (queryParams.size === 0) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n  const searchPieces = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}\n//# sourceMappingURL=urlHelpers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}