{"ast":null,"code":"import _asyncToGenerator from \"D:/Project/github-teams/teams-app-new/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n  const stringifyXML = options.stringifyXML;\n  return {\n    name: serializationPolicyName,\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const operationInfo = getOperationRequestInfo(request);\n        const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n        const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n        if (operationSpec && operationArguments) {\n          serializeHeaders(request, operationArguments, operationSpec);\n          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n        }\n        return next(request);\n      })();\n    }\n  };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n  var _a, _b;\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n        }\n      }\n    }\n  }\n  const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n  throw new Error(\"XML serialization unsupported!\");\n}) {\n  var _a, _b, _c, _d, _e;\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY\n    }\n  };\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperTypeNames.Stream;\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n  return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return {\n      [elementName]: obj\n    };\n  }\n  const result = {\n    [elementName]: obj\n  };\n  result[XML_ATTRKEY] = {\n    [xmlNamespaceKey]: xmlNamespace\n  };\n  return result;\n}","map":{"version":3,"names":["XML_ATTRKEY","XML_CHARKEY","getOperationArgumentValueFromParameter","getOperationRequestInfo","MapperTypeNames","getPathStringFromParameter","serializationPolicyName","serializationPolicy","options","stringifyXML","name","sendRequest","request","next","_asyncToGenerator","operationInfo","operationSpec","operationArguments","serializeHeaders","serializeRequestBody","_a","_b","headerParameters","headerParameter","headerValue","undefined","mapper","required","serializer","serialize","headerCollectionPrefix","key","Object","keys","headers","set","serializedName","customHeaders","requestOptions","customHeaderName","Error","_c","_d","_e","serializerOptions","updatedOptions","xml","rootName","includeRoot","xmlCharKey","requestBody","body","bodyMapper","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","nullable","typeName","type","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","contentType","match","mediaType","JSON","stringify","error","message","formDataParameters","length","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","result","obj","elementName","xmlNamespaceKey","Array","isArray"],"sources":["D:/Project/github-teams/teams-app-new/node_modules/@azure/core-client/dist/browser/serializationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo, } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n    const stringifyXML = options.stringifyXML;\n    return {\n        name: serializationPolicyName,\n        async sendRequest(request, next) {\n            const operationInfo = getOperationRequestInfo(request);\n            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n            if (operationSpec && operationArguments) {\n                serializeHeaders(request, operationArguments, operationSpec);\n                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n            }\n            return next(request);\n        },\n    };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n    var _a, _b;\n    if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n                const headerCollectionPrefix = headerParameter.mapper\n                    .headerCollectionPrefix;\n                if (headerCollectionPrefix) {\n                    for (const key of Object.keys(headerValue)) {\n                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                }\n                else {\n                    request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                }\n            }\n        }\n    }\n    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n    if (customHeaders) {\n        for (const customHeaderName of Object.keys(customHeaders)) {\n            request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n        }\n    }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n    throw new Error(\"XML serialization unsupported!\");\n}) {\n    var _a, _b, _c, _d, _e;\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY,\n        },\n    };\n    const xmlCharKey = updatedOptions.xml.xmlCharKey;\n    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n        request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n        const bodyMapper = operationSpec.requestBody.mapper;\n        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;\n        const typeName = bodyMapper.type.name;\n        try {\n            if ((request.body !== undefined && request.body !== null) ||\n                (nullable && request.body === null) ||\n                required) {\n                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n                const isStream = typeName === MapperTypeNames.Stream;\n                if (operationSpec.isXML) {\n                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n                    if (typeName === MapperTypeNames.Sequence) {\n                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });\n                    }\n                    else if (!isStream) {\n                        request.body = stringifyXML(value, {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey,\n                        });\n                    }\n                }\n                else if (typeName === MapperTypeNames.String &&\n                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n                    // the String serializer has validated that request body is a string\n                    // so just send the string.\n                    return;\n                }\n                else if (!isStream) {\n                    request.body = JSON.stringify(request.body);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n        }\n    }\n    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n        request.formData = {};\n        for (const formDataParameter of operationSpec.formDataParameters) {\n            const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n            }\n        }\n    }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n    // Composite and Sequence schemas already got their root namespace set during serialization\n    // We just need to add xmlns to the other schema types\n    if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n        const result = {};\n        result[options.xml.xmlCharKey] = serializedValue;\n        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n        return result;\n    }\n    return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n    if (!Array.isArray(obj)) {\n        obj = [obj];\n    }\n    if (!xmlNamespaceKey || !xmlNamespace) {\n        return { [elementName]: obj };\n    }\n    const result = { [elementName]: obj };\n    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}